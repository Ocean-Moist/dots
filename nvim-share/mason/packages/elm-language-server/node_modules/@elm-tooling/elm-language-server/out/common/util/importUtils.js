"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportUtils = void 0;
const ranking_1 = require("../providers/ranking");
class ImportUtils {
    static getPossibleImports(program, sourceFile) {
        const currentModule = sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.moduleName;
        const exposedValues = [];
        // Find all exposed values that could be imported
        program.getImportableModules(sourceFile).forEach(({ uri, moduleName }) => {
            if (uri !== sourceFile.uri && moduleName !== "Basics") {
                const tree = program.getSourceFile(uri);
                if (tree) {
                    exposedValues.push(...ImportUtils.getPossibleImportsOfTree(tree));
                }
            }
        });
        exposedValues.sort((a, b) => {
            if (!a.package && b.package) {
                return -1;
            }
            else if (a.package && !b.package) {
                return 1;
            }
            else if (a.package && b.package) {
                return (0, ranking_1.comparePackageRanking)(a.package, b.package);
            }
            else {
                if (!currentModule) {
                    return 0;
                }
                // Sort packages that are in closest to the current module first
                const aScore = this.comparisonScore(currentModule, a.module);
                const bScore = this.comparisonScore(currentModule, b.module);
                if (aScore > bScore) {
                    return -1;
                }
                else if (bScore > aScore) {
                    return 1;
                }
                else {
                    return 0;
                }
            }
        });
        return exposedValues;
    }
    static getPossibleImportsOfTree(tree) {
        var _a;
        const exposedValues = [];
        const module = tree.moduleName;
        if (module) {
            (_a = tree.exposing) === null || _a === void 0 ? void 0 : _a.forEach((exposed) => {
                var _a;
                exposedValues.push({
                    module,
                    value: exposed.name,
                    package: tree.maintainerAndPackageName,
                    type: exposed.type,
                    node: exposed.node,
                });
                (_a = exposed.constructors) === null || _a === void 0 ? void 0 : _a.forEach((exp) => {
                    var _a;
                    if (exp.node.parent && exp.type === "UnionConstructor") {
                        const value = (_a = exp.node.parent.childForFieldName("name")) === null || _a === void 0 ? void 0 : _a.text;
                        if (value) {
                            exposedValues.push({
                                module,
                                value: exp.name,
                                valueToImport: `${value}(..)`,
                                package: tree.maintainerAndPackageName,
                                type: "UnionConstructor",
                                node: exp.node,
                            });
                        }
                    }
                });
            });
        }
        return exposedValues;
    }
    static comparisonScore(source, target) {
        let score = 0;
        while (score < Math.min(source.length, target.length) &&
            source.charAt(score) === target.charAt(score)) {
            score++;
        }
        return score;
    }
}
exports.ImportUtils = ImportUtils;
//# sourceMappingURL=importUtils.js.map