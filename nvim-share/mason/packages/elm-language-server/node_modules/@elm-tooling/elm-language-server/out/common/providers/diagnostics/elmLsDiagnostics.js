"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ElmLsDiagnostics = void 0;
const tsyringe_1 = require("tsyringe");
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const positionUtil_1 = require("../../positionUtil");
const elmWorkspaceMatcher_1 = require("../../util/elmWorkspaceMatcher");
const treeUtils_1 = require("../../util/treeUtils");
const utils_1 = require("../../util/utils");
const diagnosticsProvider_1 = require("./diagnosticsProvider");
const path = __importStar(require("path"));
const syntaxNodeMap_1 = require("../../../compiler/utils/syntaxNodeMap");
const diagnostics_1 = require("../../../compiler/diagnostics");
class ElmLsDiagnostics {
    constructor() {
        this.createDiagnostics = (sourceFile, program) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
            const elmAnalyseJson = this.elmAnalyseJsonService.getElmAnalyseJson(program.getRootPath().fsPath);
            if (this.excludedFolder(sourceFile, program, elmAnalyseJson)) {
                return [];
            }
            const uri = sourceFile.uri;
            const tree = sourceFile.tree;
            try {
                return [
                    ...(((_a = elmAnalyseJson.checks) === null || _a === void 0 ? void 0 : _a.UnusedImport) === false
                        ? []
                        : this.getUnusedImportDiagnostics(tree)),
                    ...(((_b = elmAnalyseJson.checks) === null || _b === void 0 ? void 0 : _b.UnusedImportedVariable) === false
                        ? []
                        : this.getUnusedImportValueAndTypeDiagnostics(tree)),
                    ...(((_c = elmAnalyseJson.checks) === null || _c === void 0 ? void 0 : _c.UnusedImportAlias) === false
                        ? []
                        : this.getUnusedImportAliasDiagnostics(tree)),
                    ...(((_d = elmAnalyseJson.checks) === null || _d === void 0 ? void 0 : _d.UnusedPatternVariable) === false
                        ? []
                        : this.getUnusedPatternVariableDiagnostics(tree)),
                    ...(((_e = elmAnalyseJson.checks) === null || _e === void 0 ? void 0 : _e.MapNothingToNothing) === false
                        ? []
                        : this.getCaseBranchMapNothingToNothingDiagnostics(tree)),
                    ...(((_f = elmAnalyseJson.checks) === null || _f === void 0 ? void 0 : _f.BooleanCase) === false
                        ? []
                        : this.getBooleanCaseExpressionDiagnostics(tree)),
                    ...(((_g = elmAnalyseJson.checks) === null || _g === void 0 ? void 0 : _g.DropConcatOfLists) === false
                        ? []
                        : this.getDropConcatOfListsDiagnostics(tree)),
                    ...(((_h = elmAnalyseJson.checks) === null || _h === void 0 ? void 0 : _h.DropConsOfItemAndList) === false
                        ? []
                        : this.getDropConsOfItemAndListDiagnostics(tree)),
                    ...(((_j = elmAnalyseJson.checks) === null || _j === void 0 ? void 0 : _j.UseConsOverConcat) === false
                        ? []
                        : this.getUseConsOverConcatDiagnostics(tree)),
                    ...(((_k = elmAnalyseJson.checks) === null || _k === void 0 ? void 0 : _k.SingleFieldRecord)
                        ? this.getSingleFieldRecordDiagnostics(tree, uri, program)
                        : []),
                    ...(((_l = elmAnalyseJson.checks) === null || _l === void 0 ? void 0 : _l.UnnecessaryListConcat) === false
                        ? []
                        : this.getUnnecessaryListConcatDiagnostics(tree)),
                    ...(((_m = elmAnalyseJson.checks) === null || _m === void 0 ? void 0 : _m.UnnecessaryPortModule) === false
                        ? []
                        : this.getUnnecessaryPortModuleDiagnostics(tree)),
                    ...(((_o = elmAnalyseJson.checks) === null || _o === void 0 ? void 0 : _o.NoUncurriedPrefix) === false
                        ? []
                        : this.getFullyAppliedOperatorAsPrefixDiagnostics(tree)),
                    ...(((_p = elmAnalyseJson.checks) === null || _p === void 0 ? void 0 : _p.UnusedTypeAlias) === false
                        ? []
                        : this.getUnusedTypeAliasDiagnostics(tree)),
                    ...(((_q = elmAnalyseJson.checks) === null || _q === void 0 ? void 0 : _q.UnusedValueConstructor) === false
                        ? []
                        : this.getUnusedValueConstructorDiagnostics(tree)),
                ];
            }
            catch (e) {
                this.connection.console.error(e);
            }
            return [];
        };
        this.createSuggestionDiagnostics = (sourceFile, program, serverCancellationToken) => {
            const elmAnalyseJson = this.elmAnalyseJsonService.getElmAnalyseJson(program.getRootPath().fsPath);
            if (this.excludedFolder(sourceFile, program, elmAnalyseJson)) {
                return [];
            }
            try {
                return program
                    .getSuggestionDiagnostics(sourceFile, serverCancellationToken)
                    .map(diagnosticsProvider_1.convertFromCompilerDiagnostic)
                    .filter((diagnostic) => {
                    var _a;
                    if (diagnostic.data.code === diagnostics_1.Diagnostics.MissingTypeAnnotation.code &&
                        elmAnalyseJson.checks &&
                        elmAnalyseJson.checks.MissingTypeAnnotation !== undefined) {
                        return (_a = elmAnalyseJson.checks) === null || _a === void 0 ? void 0 : _a.MissingTypeAnnotation;
                    }
                    else {
                        return true;
                    }
                });
            }
            catch (e) {
                this.connection.console.error(e);
            }
            return [];
        };
        this.language = tsyringe_1.container.resolve("Parser").getLanguage();
        this.elmWorkspaceMatcher = new elmWorkspaceMatcher_1.ElmWorkspaceMatcher((uri) => uri);
        this.connection = tsyringe_1.container.resolve("Connection");
        this.elmAnalyseJsonService = tsyringe_1.container.resolve("ElmAnalyseJsonService");
        this.exposedValuesAndTypesQuery = this.language.query(`
        (import_clause
          (exposing_list
            (exposed_value) @exposedValue
          )
        )
        (import_clause
          (exposing_list
            (exposed_type) @exposedType
          )
        )
      `);
        this.exposedValueAndTypeUsagesQuery = this.language.query(`
      (
        [
          (value_expr)
          (record_base_identifier)
        ] @value.reference
      )
      ((type_ref
        (upper_case_qid) @type.reference)
      )
      `);
        this.moduleImportsQuery = this.language.query(`
        (import_clause
          (upper_case_qid) @moduleName
        )
    `);
        this.moduleReferencesQuery = this.language.query(`
        (value_qid
          (
            (upper_case_identifier)
            (dot)
          )* @module.reference
        )
        (upper_case_qid
          (
            (upper_case_identifier)
            (dot)
          )* @module.reference
        )
      `);
        this.importModuleAliasesQuery = this.language.query(`
        (import_clause
          (as_clause
            (upper_case_identifier) @moduleAlias
          )
        )
      `);
        this.moduleAliasReferencesQuery = this.language.query(`
        (value_qid
          (
            (upper_case_identifier)
            (dot)
          )* @module.reference
        )
        (upper_case_qid
          (
            (upper_case_identifier)
            (dot)
          )* @module.reference
        )
      `);
        this.patternsQuery = this.language.query(`
        (value_declaration
          (function_declaration_left
            [
              (pattern)
              (record_pattern)
              (lower_pattern)
            ] @pattern
          )
        ) @patternScope

        ; For some reason, we can match on the let_in_expr
        (value_declaration
          [
            (pattern)
            (record_pattern)
          ] @pattern
        ) @patternScope

        ; For let expr variables
        (value_declaration
          (function_declaration_left
            (lower_case_identifier) @pattern
          )
        ) @patternScope

        (case_of_branch
          (pattern) @pattern
        ) @patternScope

        (anonymous_function_expr
          (pattern) @pattern
        ) @patternScope
      `);
        this.caseBranchesQuery = this.language.query(`
        (
          (case_of_branch
            (pattern) @casePattern
            (value_expr) @caseValue
          ) @caseBranch
          (#eq? @casePattern "Nothing")
          (#eq? @caseValue "Nothing")
        )
      `);
        this.booleanCaseExpressionsQuery = this.language.query(`
        (
          (case_of_branch
            pattern: (pattern) @casePattern1
            (#match? @casePattern1 "^(True|False)$")
          ) @caseBranch
          (case_of_branch
            pattern: (pattern) @casePattern2
            (#match? @casePattern2 "^(True|False|_)$")
          )
        )
      `);
        this.concatOfListsQuery = this.language.query(`
        (
          (list_expr) @startList
          .
          (operator
            (operator_identifier
              "++"
            )
          )
          .
          (list_expr) @endList
        )
      `);
        this.consOfItemAndListQuery = this.language.query(`
        (bin_op_expr
          (_) @itemExpr
          .
          (operator
            (operator_identifier
              "::"
            )
          )
          .
          (list_expr) @listExpr
        )
      `);
        this.useConsOverConcatQuery = this.language.query(`
        (bin_op_expr
          (list_expr
            "["
            .
            (_)
            .
            "]"
          ) @firstPart
          .
          (operator
            (operator_identifier
              "++"
            )
          )
          .
          (_) @lastPart
        )
      `);
        this.singleFieldRecordTypesQuery = this.language.query(`
        (record_type
          "{"
          .
          (_)
          .
          "}"
        ) @recordType
      `);
        this.unnecessaryListConcatQuery = this.language.query(`
        (
          (function_call_expr
            target: (_) @target
            arg: (list_expr
              "["
              .
              (list_expr)
              .
              ("," . (list_expr))*
              .
              "]"
            ) @listExpr
          ) @functionCall
          (#eq? @target "List.concat")
        )
      `);
        this.unusedPortModuleQuery = this.language.query(`
        (module_declaration
          (port)
        ) @portModule

        (port_annotation) @portAnnotation
        `);
        this.operatorFunctionsQuery = this.language.query(`
        (function_call_expr
          target: (operator_as_function_expr)
          .
          (_) @arg1
          .
          (_) @arg2
        ) @functionCall
        `);
        this.typeAliasesQuery = this.language.query(`
        (type_alias_declaration
          (upper_case_identifier) @typeAlias
        )
        `);
        this.typeAliasUsagesQuery = this.language.query(`
        (
          [
            (value_expr)
            (exposed_type)
          ] @value.reference
        )
        ((type_ref
          (upper_case_qid) @type.reference)
        )
        `);
        this.unionVariantsQuery = this.language.query(`
        (type_declaration
          (upper_case_identifier) @typeName
          (union_variant
            (upper_case_identifier) @unionVariant
          )
        )
        `);
        this.unionVariantUsagesQuery = this.language.query(`
      (
        (exposed_type) @exposed.reference
      )
      (
        (value_expr) @value.reference
      )
      ((type_ref
        (upper_case_qid) @type.reference)
      )
      ((case_of_branch
        (pattern
          (union_pattern
            (upper_case_qid) @variant.reference)))
      )
      `);
        this.patternReferencesQuery = this.language.query(`
        (
          [
            (value_expr)
            (record_base_identifier)
            (exposed_value)
          ] @patternVariable.reference
        )
        (
          (module_declaration
            (exposing_list
              (double_dot)
            ) @exposingAll
          )
        )
        `);
    }
    excludedFolder(sourceFile, program, elmAnalyseJson) {
        var _a;
        const uri = sourceFile.uri;
        const rootPath = program.getRootPath().fsPath;
        if ((_a = elmAnalyseJson.excludedPaths) === null || _a === void 0 ? void 0 : _a.some((excludedPath) => {
            if (excludedPath.startsWith(rootPath)) {
                // absolute path
                return uri.startsWith(vscode_uri_1.URI.file(excludedPath).toString());
            }
            else {
                // relative path
                return uri.startsWith(vscode_uri_1.URI.file(path.join(rootPath, excludedPath)).toString());
            }
        })) {
            return true;
        }
        return false;
    }
    getUnusedImportDiagnostics(tree) {
        const diagnostics = [];
        const moduleImports = this.moduleImportsQuery
            .matches(tree.rootNode)
            .map((match) => match.captures[0].node)
            .filter((node) => { var _a; return !((_a = node.parent) === null || _a === void 0 ? void 0 : _a.childForFieldName("exposing")); })
            .map((node) => {
            var _a, _b;
            const alias = (_b = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.childForFieldName("asClause")) === null || _b === void 0 ? void 0 : _b.childForFieldName("name");
            return alias ? alias : node;
        });
        const moduleReferences = this.moduleReferencesQuery
            .matches(tree.rootNode)
            .filter(utils_1.Utils.notUndefined)
            .filter((match) => {
            var _a, _b, _c;
            return match.captures.length > 0 &&
                ((_a = match.captures[0].node.parent) === null || _a === void 0 ? void 0 : _a.type) !== "import_clause" &&
                ((_c = (_b = match.captures[0].node.parent) === null || _b === void 0 ? void 0 : _b.parent) === null || _c === void 0 ? void 0 : _c.type) !== "import_clause";
        })
            .map((match) => match.captures.map((n) => n.node.text).join("."));
        // Would need to adjust tree-sitter (use fields) to get a better query
        moduleImports.forEach((moduleImport) => {
            var _a, _b;
            const references = moduleReferences.filter((moduleReference) => moduleReference === moduleImport.text);
            const importNode = ((_a = moduleImport.parent) === null || _a === void 0 ? void 0 : _a.type) === "as_clause"
                ? (_b = moduleImport.parent) === null || _b === void 0 ? void 0 : _b.parent
                : moduleImport.parent;
            if (references.length === 0 && importNode) {
                diagnostics.push({
                    range: this.getNodeRange(importNode),
                    message: `Unused import \`${moduleImport.text}\``,
                    severity: vscode_languageserver_1.DiagnosticSeverity.Warning,
                    source: "ElmLS",
                    tags: [vscode_languageserver_1.DiagnosticTag.Unnecessary],
                    data: { uri: tree.uri, code: "unused_import" },
                });
            }
        });
        return diagnostics;
    }
    getUnusedImportValueAndTypeDiagnostics(tree) {
        const diagnostics = [];
        const exposedValuesAndTypes = this.exposedValuesAndTypesQuery
            .matches(tree.rootNode)
            .map((match) => match.captures[0].node);
        const allUsages = this.exposedValueAndTypeUsagesQuery
            .matches(tree.rootNode)
            .filter(utils_1.Utils.notUndefined);
        exposedValuesAndTypes.forEach((exposedValueOrType) => {
            if (exposedValueOrType.text.endsWith("(..)")) {
                return;
            }
            const references = allUsages.filter((result) => result.captures[0].node.text === exposedValueOrType.text);
            if (references.length === 0) {
                diagnostics.push({
                    range: this.getNodeRange(exposedValueOrType),
                    message: `Unused imported ${exposedValueOrType.type === "exposed_type" ? "type" : "value"} \`${exposedValueOrType.text}\``,
                    severity: vscode_languageserver_1.DiagnosticSeverity.Warning,
                    source: "ElmLS",
                    tags: [vscode_languageserver_1.DiagnosticTag.Unnecessary],
                    data: { uri: tree.uri, code: "unused_imported_value" },
                });
            }
        });
        return diagnostics;
    }
    getUnusedImportAliasDiagnostics(tree) {
        const diagnostics = [];
        const moduleAliases = this.importModuleAliasesQuery
            .matches(tree.rootNode)
            .map((match) => match.captures[0].node);
        const allAliasReferences = this.moduleAliasReferencesQuery
            .matches(tree.rootNode)
            .filter(utils_1.Utils.notUndefined)
            .filter((match) => match.captures.length > 0)
            .map((match) => match.captures[0].node.text);
        moduleAliases.forEach((moduleAlias) => {
            var _a, _b;
            // This case is handled by unused_import
            if (!((_b = (_a = moduleAlias.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.childForFieldName("exposing"))) {
                return;
            }
            const references = allAliasReferences.filter((moduleReference) => moduleReference === moduleAlias.text);
            if (references.length === 0 && moduleAlias.parent) {
                diagnostics.push({
                    range: this.getNodeRange(moduleAlias.parent),
                    message: `Unused import alias \`${moduleAlias.text}\``,
                    severity: vscode_languageserver_1.DiagnosticSeverity.Warning,
                    source: "ElmLS",
                    tags: [vscode_languageserver_1.DiagnosticTag.Unnecessary],
                    data: { uri: tree.uri, code: "unused_alias" },
                });
            }
        });
        return diagnostics;
    }
    getUnusedPatternVariableDiagnostics(tree) {
        const diagnostics = [];
        const patternMatches = this.patternsQuery.matches(tree.rootNode);
        const scopeCache = new syntaxNodeMap_1.SyntaxNodeMap();
        patternMatches
            .filter(utils_1.Utils.notUndefined)
            .flatMap((match) => {
            var _a, _b, _c;
            let scope = match.captures[0].node;
            const patternMatch = match.captures[1].node;
            // Adjust the scope of let_in_expr due to the query bug above
            if (scope.type === "value_declaration" &&
                ((_a = scope.parent) === null || _a === void 0 ? void 0 : _a.type) === "let_in_expr" &&
                (patternMatch.type === "lower_case_identifier" ||
                    ((_b = patternMatch.parent) === null || _b === void 0 ? void 0 : _b.type) === "value_declaration")) {
                scope = scope.parent;
            }
            if (patternMatch.type === "lower_case_identifier" &&
                ((_c = scope.parent) === null || _c === void 0 ? void 0 : _c.type) === "file") {
                scope = scope.parent;
            }
            return patternMatch.type === "lower_pattern" ||
                patternMatch.type === "lower_case_identifier"
                ? [{ scope, pattern: patternMatch }]
                : patternMatch.descendantsOfType("lower_pattern").map((pattern) => {
                    return { scope, pattern };
                });
        })
            .forEach(({ scope, pattern }) => {
            var _a;
            const references = scopeCache
                .getOrSet(scope, () => this.patternReferencesQuery
                .matches(scope)
                .filter(utils_1.Utils.notUndefined))
                .filter((result) => result.captures[0].name !== "patternVariable.reference" ||
                result.captures[0].node.text === pattern.text);
            if (scope.type === "file") {
                let outsideRef = false;
                const topLevelDeclaration = treeUtils_1.TreeUtils.findParentOfType("value_declaration", pattern);
                for (const ref of references) {
                    const valueDeclaration = treeUtils_1.TreeUtils.findParentOfType("value_declaration", ref.captures[0].node, true);
                    if ((valueDeclaration === null || valueDeclaration === void 0 ? void 0 : valueDeclaration.id) !== (topLevelDeclaration === null || topLevelDeclaration === void 0 ? void 0 : topLevelDeclaration.id)) {
                        outsideRef = true;
                        break;
                    }
                }
                if (!outsideRef) {
                    diagnostics.push({
                        range: this.getNodeRange(pattern),
                        message: `Unused top level definition \`${pattern.text}\``,
                        severity: vscode_languageserver_1.DiagnosticSeverity.Warning,
                        source: "ElmLS",
                        tags: [vscode_languageserver_1.DiagnosticTag.Unnecessary],
                        data: { uri: tree.uri, code: "unused_top_level" },
                    });
                }
            }
            else if (references.length === 0) {
                diagnostics.push({
                    // Extend the range for cases of {}
                    range: this.getNodeRange(pattern.type === "lower_pattern" &&
                        pattern.text === "" &&
                        ((_a = pattern.parent) === null || _a === void 0 ? void 0 : _a.parent)
                        ? pattern.parent.parent
                        : pattern),
                    message: `Unused pattern variable \`${pattern.text}\``,
                    severity: vscode_languageserver_1.DiagnosticSeverity.Warning,
                    source: "ElmLS",
                    tags: [vscode_languageserver_1.DiagnosticTag.Unnecessary],
                    data: { uri: tree.uri, code: "unused_pattern" },
                });
            }
        });
        return diagnostics;
    }
    getCaseBranchMapNothingToNothingDiagnostics(tree) {
        const diagnostics = [];
        const caseBranches = this.caseBranchesQuery
            .matches(tree.rootNode)
            .map((match) => match.captures[0].node);
        caseBranches.forEach((caseBranch) => {
            diagnostics.push({
                range: this.getNodeRange(caseBranch),
                message: `\`Nothing\` mapped to \`Nothing\` in case expression. Use Maybe.map or Maybe.andThen instead.`,
                severity: vscode_languageserver_1.DiagnosticSeverity.Warning,
                source: "ElmLS",
                data: { uri: tree.uri, code: "map_nothing_to_nothing" },
            });
        });
        return diagnostics;
    }
    getBooleanCaseExpressionDiagnostics(tree) {
        const diagnostics = [];
        // For some reason, we can't match on case_expr, tree-sitter throws a memory access error
        const caseExpressions = this.booleanCaseExpressionsQuery
            .matches(tree.rootNode)
            .map((match) => match.captures[0].node.parent)
            .filter(utils_1.Utils.notUndefinedOrNull);
        caseExpressions.forEach((caseExpr) => {
            diagnostics.push({
                range: this.getNodeRange(caseExpr),
                message: `Use an if expression instead of a case expression.`,
                severity: vscode_languageserver_1.DiagnosticSeverity.Warning,
                source: "ElmLS",
                data: { uri: tree.uri, code: "boolean_case_expr" },
            });
        });
        return diagnostics;
    }
    getDropConcatOfListsDiagnostics(tree) {
        const diagnostics = [];
        const listExpressions = this.concatOfListsQuery
            .matches(tree.rootNode)
            .map((match) => [match.captures[0].node, match.captures[1].node])
            .filter(utils_1.Utils.notUndefinedOrNull);
        listExpressions.forEach(([startList, endList]) => {
            diagnostics.push({
                range: {
                    start: this.getNodeRange(startList).start,
                    end: this.getNodeRange(endList).end,
                },
                message: `If you concatenate two lists, then you can merge them into one list.`,
                severity: vscode_languageserver_1.DiagnosticSeverity.Warning,
                source: "ElmLS",
                data: { uri: tree.uri, code: "drop_concat_of_lists" },
            });
        });
        return diagnostics;
    }
    getDropConsOfItemAndListDiagnostics(tree) {
        const diagnostics = [];
        const consExpressions = this.consOfItemAndListQuery
            .matches(tree.rootNode)
            .map((match) => [match.captures[0].node, match.captures[1].node])
            .filter(utils_1.Utils.notUndefinedOrNull);
        consExpressions.forEach(([itemExpr, listExpr]) => {
            diagnostics.push({
                range: {
                    start: this.getNodeRange(itemExpr).start,
                    end: this.getNodeRange(listExpr).end,
                },
                message: `If you cons an item to a literal list, then you can just put the item into the list.`,
                severity: vscode_languageserver_1.DiagnosticSeverity.Warning,
                source: "ElmLS",
                data: { uri: tree.uri, code: "drop_cons_of_item_and_list" },
            });
        });
        return diagnostics;
    }
    getUseConsOverConcatDiagnostics(tree) {
        const diagnostics = [];
        const concatExpressions = this.useConsOverConcatQuery
            .matches(tree.rootNode)
            .map((match) => [match.captures[0].node, match.captures[1].node])
            .filter(utils_1.Utils.notUndefinedOrNull);
        concatExpressions.forEach(([firstPart, lastPart]) => {
            diagnostics.push({
                range: {
                    start: this.getNodeRange(firstPart).start,
                    end: this.getNodeRange(lastPart).end,
                },
                message: `If you concatenate two lists, but the first item is a single element list, then you should use the cons operator.`,
                severity: vscode_languageserver_1.DiagnosticSeverity.Warning,
                source: "ElmLS",
                data: { uri: tree.uri, code: "use_cons_over_concat" },
            });
        });
        return diagnostics;
    }
    getSingleFieldRecordDiagnostics(tree, uri, program) {
        const diagnostics = [];
        const recordTypes = this.singleFieldRecordTypesQuery
            .matches(tree.rootNode)
            .map((match) => match.captures[0].node)
            .filter(utils_1.Utils.notUndefinedOrNull);
        recordTypes.forEach((recordType) => {
            var _a;
            let isSingleField = true;
            if (((_a = recordType.parent) === null || _a === void 0 ? void 0 : _a.type) === "type_ref" && recordType.parent.parent) {
                const type = program.getTypeChecker().findType(recordType.parent);
                const singleField = recordType.descendantsOfType("lower_case_identifier")[0];
                if (type.nodeType === "Record" &&
                    Object.keys(type.fields).length > 1 &&
                    type.fields[singleField.text]) {
                    isSingleField = false;
                }
            }
            if (isSingleField) {
                diagnostics.push({
                    range: this.getNodeRange(recordType),
                    message: `Using a record is obsolete if you only plan to store a single field in it.`,
                    severity: vscode_languageserver_1.DiagnosticSeverity.Warning,
                    source: "ElmLS",
                    data: { uri: tree.uri, code: "single_field_record" },
                });
            }
        });
        return diagnostics;
    }
    getUnnecessaryListConcatDiagnostics(tree) {
        const diagnostics = [];
        const listConcats = this.unnecessaryListConcatQuery
            .matches(tree.rootNode)
            .filter((match) => {
            var _a;
            return (_a = match.captures[2].node) === null || _a === void 0 ? void 0 : _a.namedChildren.every((c) => c.type === "list_expr");
        })
            .map((match) => match.captures[0].node)
            .filter(utils_1.Utils.notUndefinedOrNull);
        listConcats.forEach((listConcat) => {
            diagnostics.push({
                range: this.getNodeRange(listConcat),
                message: `You should just merge the arguments of \`List.concat\` to a single list.`,
                severity: vscode_languageserver_1.DiagnosticSeverity.Warning,
                source: "ElmLS",
                data: { uri: tree.uri, code: "unnecessary_list_concat" },
            });
        });
        return diagnostics;
    }
    getUnnecessaryPortModuleDiagnostics(tree) {
        var _a;
        const diagnostics = [];
        const unusedPortMatches = this.unusedPortModuleQuery.matches(tree.rootNode);
        if (((_a = unusedPortMatches[0]) === null || _a === void 0 ? void 0 : _a.captures[0].name) === "portModule" &&
            !unusedPortMatches[1]) {
            diagnostics.push({
                range: this.getNodeRange(unusedPortMatches[0].captures[0].node),
                message: `Module is defined as a \`port\` module, but does not define any ports.`,
                severity: vscode_languageserver_1.DiagnosticSeverity.Warning,
                source: "ElmLS",
                data: { uri: tree.uri, code: "unnecessary_port_module" },
            });
        }
        return diagnostics;
    }
    getFullyAppliedOperatorAsPrefixDiagnostics(tree) {
        const diagnostics = [];
        const operatorFunctions = this.operatorFunctionsQuery
            .matches(tree.rootNode)
            .map((match) => match.captures[0].node)
            .filter(utils_1.Utils.notUndefinedOrNull);
        operatorFunctions.forEach((operatorFunction) => {
            diagnostics.push({
                range: this.getNodeRange(operatorFunction),
                message: `Don't use fully applied prefix notation for operators.`,
                severity: vscode_languageserver_1.DiagnosticSeverity.Warning,
                source: "ElmLS",
                data: { uri: tree.uri, code: "no_uncurried_prefix" },
            });
        });
        return diagnostics;
    }
    getUnusedTypeAliasDiagnostics(tree) {
        var _a, _b;
        const diagnostics = [];
        // Currently if the file exports the variant, either through an explicit
        // reference to the type, or through a '(..)' to expose everything, then
        // we won't mark the value constructor as unused. Ideally this should take
        // multiple files into account, then these conditions can be removed.
        const exposingAll = !!((_b = (_a = tree.rootNode
            .childForFieldName("moduleDeclaration")) === null || _a === void 0 ? void 0 : _a.childForFieldName("exposing")) === null || _b === void 0 ? void 0 : _b.childForFieldName("doubleDot"));
        if (exposingAll) {
            return diagnostics;
        }
        const typeAliases = this.typeAliasesQuery
            .matches(tree.rootNode)
            .map((match) => match.captures[0].node)
            .filter(utils_1.Utils.notUndefinedOrNull);
        const typeAliasUsages = this.typeAliasUsagesQuery
            .matches(tree.rootNode)
            .filter(utils_1.Utils.notUndefined);
        typeAliases.forEach((typeAlias) => {
            const references = typeAliasUsages.filter((result) => result.captures[0].node.text === typeAlias.text);
            if (references.length === 0 && typeAlias.parent) {
                diagnostics.push({
                    range: this.getNodeRange(typeAlias.parent),
                    message: `Type alias \`${typeAlias.text}\` is not used.`,
                    severity: vscode_languageserver_1.DiagnosticSeverity.Warning,
                    source: "ElmLS",
                    tags: [vscode_languageserver_1.DiagnosticTag.Unnecessary],
                    data: { uri: tree.uri, code: "unused_type_alias" },
                });
            }
        });
        return diagnostics;
    }
    getUnusedValueConstructorDiagnostics(tree) {
        var _a, _b;
        const diagnostics = [];
        // Currently if the file exports the variant, either through an explicit
        // reference to the type, or through a '(..)' to expose everything, then
        // we won't mark the value constructor as unused. Ideally this should take
        // multiple files into account, then these conditions can be removed.
        const exposingAll = !!((_b = (_a = tree.rootNode
            .childForFieldName("moduleDeclaration")) === null || _a === void 0 ? void 0 : _a.childForFieldName("exposing")) === null || _b === void 0 ? void 0 : _b.childForFieldName("doubleDot"));
        if (exposingAll) {
            return diagnostics;
        }
        const unionVariants = this.unionVariantsQuery
            .matches(tree.rootNode)
            .map((match) => [match.captures[1].node, match.captures[0].node])
            .filter(utils_1.Utils.notUndefinedOrNull);
        const unionVariantUsages = this.unionVariantUsagesQuery
            .matches(tree.rootNode)
            .filter(utils_1.Utils.notUndefined);
        unionVariants.forEach(([unionVariant, typeName]) => {
            const references = unionVariantUsages.filter((result) => result.captures[0].node.text ===
                (result.captures[0].name === "exposed.reference"
                    ? `${typeName.text}(..)`
                    : unionVariant.text));
            if (references.length === 0 && unionVariant.parent) {
                diagnostics.push({
                    range: this.getNodeRange(unionVariant.parent),
                    message: `Value constructor \`${unionVariant.text}\` is not used.`,
                    severity: vscode_languageserver_1.DiagnosticSeverity.Warning,
                    source: "ElmLS",
                    tags: [vscode_languageserver_1.DiagnosticTag.Unnecessary],
                    data: { uri: tree.uri, code: "unused_value_constructor" },
                });
            }
        });
        return diagnostics;
    }
    getNodeRange(node) {
        const end = positionUtil_1.PositionUtil.FROM_TS_POSITION(node.endPosition).toVSPosition();
        return {
            start: positionUtil_1.PositionUtil.FROM_TS_POSITION(node.startPosition).toVSPosition(),
            end: Object.assign(Object.assign({}, end), { character: end.character }),
        };
    }
}
exports.ElmLsDiagnostics = ElmLsDiagnostics;
//# sourceMappingURL=elmLsDiagnostics.js.map