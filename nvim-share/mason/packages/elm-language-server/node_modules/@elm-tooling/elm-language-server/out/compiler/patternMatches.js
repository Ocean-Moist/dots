"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PatternMatches = void 0;
const treeUtils_1 = require("../common/util/treeUtils");
const utils_1 = require("../common/util/utils");
const diagnostics_1 = require("./diagnostics");
const Anything = { type: "Anything" };
const Literal = (literalType, value) => ({
    type: "Literal",
    literalType,
    value,
});
const Ctor = (union, name, args) => ({
    type: "Ctor",
    union,
    name,
    args,
});
function nodeToCanCtor(node) {
    return {
        name: node.firstNamedChild.text,
        arity: node.namedChildren
            .slice(1)
            .filter((n) => !n.type.includes("comment")).length,
    };
}
const unitName = "#0";
const pairName = "#2";
const tripleName = "#3";
const consName = "::";
const nilName = "[]";
const unit = { alts: [{ name: unitName, arity: 0 }], numAlts: 1 };
const pair = { alts: [{ name: pairName, arity: 2 }], numAlts: 1 };
const triple = { alts: [{ name: tripleName, arity: 3 }], numAlts: 1 };
const list = {
    alts: [
        { name: nilName, arity: 0 },
        { name: consName, arity: 2 },
    ],
    numAlts: 2,
};
const nil = Ctor(list, nilName, []);
class PatternMatches {
    constructor(program, sourceFile) {
        this.program = program;
        this.sourceFile = sourceFile;
    }
    static check(region, patterns, program) {
        return new PatternMatches(program, program.getSourceFile(patterns[0].tree.uri)).checkPatterns(region, patterns);
    }
    static missing(patterns, program) {
        return new PatternMatches(program, program.getSourceFile(patterns[0].tree.uri)).getMissing(patterns);
    }
    getMissing(patterns) {
        const result = this.toNonRedundantRows(patterns[0], patterns);
        if (!Array.isArray(result)) {
            return [];
        }
        else {
            return this.isExhaustive(result, 1).map((p) => patternToDoc(p[0], "Unambiguous"));
        }
    }
    checkPatterns(region, patterns) {
        const result = this.toNonRedundantRows(region, patterns);
        if (!Array.isArray(result)) {
            return [result];
        }
        else {
            const badPatterns = this.isExhaustive(result, 1);
            if (badPatterns.length === 0) {
                return [];
            }
            else {
                // TODO: Handle other incomplete patterns
                const badPatternsText = badPatterns.map((p) => patternToDoc(p[0], "Unambiguous"));
                return [
                    (0, diagnostics_1.error)(region, diagnostics_1.Diagnostics.IncompleteCasePattern(badPatternsText.length), ...badPatternsText),
                ];
            }
        }
    }
    isExhaustive(matrix, n) {
        if (matrix.length === 0) {
            return [replicate(Anything, n)];
        }
        else {
            if (n === 0) {
                return [];
            }
            else {
                const ctors = this.collectCtors(matrix);
                const numSeen = ctors.size;
                if (numSeen === 0) {
                    return this.isExhaustive(matrix
                        .map(this.specializeRowByAnything.bind(this))
                        .filter(utils_1.Utils.notUndefined), n - 1).map((result) => [Anything, ...result]);
                }
                else {
                    const alts = findMin(ctors)[1];
                    if (numSeen < alts.numAlts) {
                        const missing = alts.alts
                            .map((alt) => isMissing(alts, ctors, alt))
                            .filter(utils_1.Utils.notUndefined);
                        return this.isExhaustive(matrix
                            .map(this.specializeRowByAnything.bind(this))
                            .filter(utils_1.Utils.notUndefined), n - 1).flatMap((ex) => missing.map((m) => [m, ...ex]));
                    }
                    else {
                        const isAltExhaustive = (ctor) => {
                            return this.isExhaustive(matrix
                                .map((row) => this.specializeRowByCtor(ctor.name, ctor.arity, row))
                                .filter(utils_1.Utils.notUndefined), ctor.arity + n - 1).map((patterns) => recoverCtor(alts, ctor.name, ctor.arity, patterns));
                        };
                        return alts.alts.flatMap(isAltExhaustive);
                    }
                }
            }
        }
    }
    toNonRedundantRows(region, patterns) {
        return this.toSimplifiedUsefulRows(region, [], patterns);
    }
    toSimplifiedUsefulRows(overalRegion, checkedRows, uncheckedPatterns) {
        if (uncheckedPatterns.length === 0) {
            return checkedRows;
        }
        else {
            const nextRow = [this.simplify(uncheckedPatterns[0])];
            if (this.isUseful(checkedRows, nextRow)) {
                return this.toSimplifiedUsefulRows(overalRegion, [nextRow, ...checkedRows], uncheckedPatterns.slice(1));
            }
            else {
                return (0, diagnostics_1.error)(uncheckedPatterns[0], diagnostics_1.Diagnostics.RedundantPattern, checkedRows.length + 1);
            }
        }
    }
    isUseful(matrix, vector) {
        if (matrix.length === 0) {
            return true;
        }
        else {
            if (vector.length === 0) {
                return false;
            }
            else {
                const patterns = vector.slice(1);
                switch (vector[0].type) {
                    case "Ctor": {
                        const args = vector[0].args;
                        const name = vector[0].name;
                        return this.isUseful(matrix
                            .map((row) => this.specializeRowByCtor(name, args.length, row))
                            .filter(utils_1.Utils.notUndefined), [...args, ...patterns]);
                    }
                    case "Anything": {
                        const alts = this.isComplete(matrix);
                        if (!alts) {
                            return this.isUseful(matrix
                                .map(this.specializeRowByAnything.bind(this))
                                .filter(utils_1.Utils.notUndefined), patterns);
                        }
                        else {
                            return alts.some((alt) => {
                                return this.isUseful(matrix
                                    .map((row) => this.specializeRowByCtor(alt.name, alt.arity, row))
                                    .filter(utils_1.Utils.notUndefined), [...replicate(Anything, alt.arity), ...patterns]);
                            });
                        }
                    }
                    case "Literal": {
                        const literal = vector[0];
                        return this.isUseful(matrix
                            .map((row) => this.specializeRowByLiteral(literal, row))
                            .filter(utils_1.Utils.notUndefined), patterns);
                    }
                }
            }
        }
    }
    specializeRowByCtor(name, arity, row) {
        const patterns = row.slice(1);
        switch (row[0].type) {
            case "Ctor":
                if (row[0].name === name) {
                    return [...row[0].args, ...patterns];
                }
                else {
                    return;
                }
            case "Anything":
                return [...replicate(Anything, arity), ...patterns];
            default:
                throw new Error("Compiler bug");
        }
    }
    specializeRowByLiteral(literal, row) {
        const patterns = row.slice(1);
        switch (row[0].type) {
            case "Literal":
                if (row[0].literalType === literal.literalType &&
                    row[0].value === literal.value) {
                    return patterns;
                }
                else {
                    return;
                }
            case "Anything":
                return patterns;
            default:
                throw new Error("Compiler bug");
        }
    }
    specializeRowByAnything(row) {
        if (row.length === 0) {
            return;
        }
        switch (row[0].type) {
            case "Ctor":
            case "Literal":
                return;
            case "Anything":
                return row.slice(1);
        }
    }
    isComplete(matrix) {
        const ctors = this.collectCtors(matrix);
        const numSeen = ctors.size;
        if (numSeen === 0) {
            return;
        }
        else {
            const union = findMin(ctors)[1];
            if (numSeen === union.numAlts) {
                return union.alts;
            }
            else {
                return;
            }
        }
    }
    collectCtors(matrix) {
        const ctors = new Map();
        matrix.forEach((row) => {
            var _a;
            if (((_a = row[0]) === null || _a === void 0 ? void 0 : _a.type) === "Ctor") {
                ctors.set(row[0].name, row[0].union);
            }
        });
        return ctors;
    }
    cons(head, tail) {
        return Ctor(list, consName, [this.simplify(head), tail]);
    }
    simplify(pattern) {
        var _a, _b, _c, _d, _e, _f, _g;
        const patternAs = pattern.childForFieldName("patternAs");
        if (patternAs) {
            return this.simplify((_a = pattern.childForFieldName("child")) !== null && _a !== void 0 ? _a : patternAs);
        }
        switch (pattern.type) {
            case "anything_pattern":
            case "lower_pattern":
            case "record_pattern":
                return Anything;
            case "unit_expr":
                return Ctor(unit, unitName, []);
            case "tuple_pattern": {
                const patterns = pattern.children
                    .filter((n) => n.type === "pattern")
                    .map((n) => n.childForFieldName("child"));
                if (patterns.length === 3) {
                    return Ctor(triple, tripleName, patterns.map(this.simplify.bind(this)));
                }
                else {
                    return Ctor(pair, pairName, patterns.map(this.simplify.bind(this)));
                }
            }
            case "union_pattern":
            case "nullary_constructor_argument_pattern": {
                const ctor = (_e = (_c = (_b = pattern.childForFieldName("constructor")) === null || _b === void 0 ? void 0 : _b.lastNamedChild) !== null && _c !== void 0 ? _c : (_d = pattern.firstNamedChild) === null || _d === void 0 ? void 0 : _d.lastNamedChild) !== null && _e !== void 0 ? _e : pattern.firstNamedChild;
                const definition = this.program
                    .getTypeChecker()
                    .findDefinition(ctor, this.sourceFile);
                const unionVariants = definition.symbol
                    ? (_g = (_f = treeUtils_1.TreeUtils.findParentOfType("type_declaration", definition.symbol.node)) === null || _f === void 0 ? void 0 : _f.namedChildren.filter((n) => n.type === "union_variant").map(nodeToCanCtor)) !== null && _g !== void 0 ? _g : []
                    : [];
                const numAlts = unionVariants.length;
                return Ctor({ alts: unionVariants, numAlts }, ctor.text, pattern.namedChildren.slice(1).map(this.simplify.bind(this)));
            }
            case "list_pattern":
                return foldr(this.cons.bind(this), nil, pattern.namedChildren.filter((n) => n.type === "pattern"));
            case "cons_pattern": {
                const patterns = pattern.namedChildren.filter((n) => n.type.includes("pattern") ||
                    n.type.includes("constant") ||
                    n.type === "unit_expr");
                return this.cons(patterns[0], this.simplify(patterns[1]));
            }
            case "pattern":
                return this.simplify(pattern.childForFieldName("child"));
            case "char_constant_expr":
                return Literal("Chr", pattern.text);
            case "string_constant_expr":
                return Literal("Str", pattern.text);
            case "number_constant_expr":
                return Literal("Int", pattern.text);
            default:
                throw new Error("Unknown pattern type");
        }
    }
}
exports.PatternMatches = PatternMatches;
function isMissing(union, ctors, ctor) {
    if (ctors.has(ctor.name)) {
        return;
    }
    else {
        return Ctor(union, ctor.name, replicate(Anything, ctor.arity));
    }
}
function recoverCtor(union, name, arity, patterns) {
    const args = patterns.slice(0, arity);
    const rest = patterns.slice(arity);
    return [Ctor(union, name, args), ...rest];
}
function findMin(ctors) {
    return Array.from(ctors.entries()).sort(([a], [b]) => a < b ? -1 : a > b ? 1 : 0)[0];
}
function patternToDoc(pattern, context) {
    const result = delist(pattern, []);
    if (result.type === "NonList") {
        if (result.pattern.type === "Anything") {
            return "_";
        }
        else if (result.pattern.type === "Literal") {
            return result.pattern.value;
        }
        else {
            if (result.pattern.name === "#0") {
                return "()";
            }
            else if (result.pattern.name === "#2") {
                return `( ${patternToDoc(result.pattern.args[0], "Unambiguous")}, ${patternToDoc(result.pattern.args[1], "Unambiguous")} )`;
            }
            else if (result.pattern.name === "#3") {
                return `( ${patternToDoc(result.pattern.args[0], "Unambiguous")}, ${patternToDoc(result.pattern.args[1], "Unambiguous")}, ${patternToDoc(result.pattern.args[2], "Unambiguous")} )`;
            }
            else {
                const ctorDoc = `${result.pattern.name}${result.pattern.args.length > 0 ? " " : ""}${result.pattern.args
                    .map((arg) => patternToDoc(arg, "Arg"))
                    .join(" ")}`;
                if (context === "Arg" && result.pattern.args.length > 0) {
                    return `(${ctorDoc})`;
                }
                else {
                    return ctorDoc;
                }
            }
        }
    }
    else if (result.type === "FiniteList") {
        if (result.entries.length === 0) {
            return "[]";
        }
        else {
            return `[${result.entries
                .map((entry) => patternToDoc(entry, "Unambiguous"))
                .join(", ")}]`;
        }
    }
    else {
        const consDoc = foldr((hd, tl) => `${patternToDoc(hd, "Head")} :: ${tl}`, patternToDoc(result.finalPattern, "Unambiguous"), result.conses);
        if (context === "Unambiguous") {
            return consDoc;
        }
        else {
            return `(${consDoc})`;
        }
    }
}
function delist(pattern, revEntries) {
    if (pattern.type === "Ctor" && pattern.name === "[]") {
        return { type: "FiniteList", entries: revEntries };
    }
    else if (pattern.type === "Ctor" && pattern.name === "::") {
        return delist(pattern.args[1], [pattern.args[0], ...revEntries]);
    }
    else {
        if (revEntries.length === 0) {
            return { type: "NonList", pattern };
        }
        else {
            return {
                type: "Conses",
                conses: revEntries.reverse(),
                finalPattern: pattern,
            };
        }
    }
}
function replicate(value, length) {
    return Array.from(Array(length)).map(() => value);
}
function foldr(func, start, array) {
    return array.reduceRight((prev, cur) => func(cur, prev), start);
}
//# sourceMappingURL=patternMatches.js.map