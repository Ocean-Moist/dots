"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_1 = require("vscode-languageserver");
const treeUtils_1 = require("../../util/treeUtils");
const diagnostics_1 = require("../../../compiler/diagnostics");
const codeActionProvider_1 = require("../codeActionProvider");
const errorCodes = [diagnostics_1.Diagnostics.MissingValue.code];
const fixId = "add_new_function_parameter";
codeActionProvider_1.CodeActionProvider.registerCodeAction({
    errorCodes,
    fixId,
    getCodeActions: (params) => getActions(params, params.range),
    getFixAllCodeAction: () => undefined,
});
function getActions(params, range) {
    var _a, _b, _c, _d, _e;
    const nodeAtPosition = treeUtils_1.TreeUtils.getNamedDescendantForRange(params.sourceFile, range);
    if (nodeAtPosition.type === "lower_case_identifier" &&
        ((_b = (_a = nodeAtPosition.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.type) === "value_expr" &&
        ((_d = (_c = nodeAtPosition.parent) === null || _c === void 0 ? void 0 : _c.parent) === null || _d === void 0 ? void 0 : _d.parent) &&
        ((_e = nodeAtPosition.previousSibling) === null || _e === void 0 ? void 0 : _e.type) !== "dot") {
        return treeUtils_1.TreeUtils.getAllAncestorsOfType("value_declaration", nodeAtPosition)
            .map((valueDeclaration) => getActionsForValueDeclaration(valueDeclaration, nodeAtPosition, params))
            .filter((e) => e != undefined);
    }
}
function getActionsForValueDeclaration(valueDeclaration, nodeAtPosition, params) {
    var _a, _b, _c;
    const lastFunctionParameter = (_a = valueDeclaration === null || valueDeclaration === void 0 ? void 0 : valueDeclaration.firstChild) === null || _a === void 0 ? void 0 : _a.lastChild;
    if (!lastFunctionParameter)
        return;
    const valueParameterPosition = vscode_languageserver_1.Position.create(lastFunctionParameter.endPosition.row, lastFunctionParameter.endPosition.column + 1);
    const edits = getEditsForSignatureUpdate(params, nodeAtPosition, valueDeclaration);
    edits.push(vscode_languageserver_1.TextEdit.insert(valueParameterPosition, nodeAtPosition.text + " "));
    const functionName = (_c = (_b = valueDeclaration.firstChild) === null || _b === void 0 ? void 0 : _b.firstChild) === null || _c === void 0 ? void 0 : _c.text;
    if (!functionName)
        return;
    return codeActionProvider_1.CodeActionProvider.getCodeAction(params, `Add new parameter to '${functionName}'`, edits);
}
function getEditsForSignatureUpdate(params, nodeAtPosition, valueDeclaration) {
    var _a;
    const typeAnnotation = treeUtils_1.TreeUtils.getTypeAnnotation(valueDeclaration);
    const lastParameterType = (_a = typeAnnotation === null || typeAnnotation === void 0 ? void 0 : typeAnnotation.childForFieldName("typeExpression")) === null || _a === void 0 ? void 0 : _a.lastChild;
    if (!lastParameterType)
        return [];
    const checker = params.program.getTypeChecker();
    const type = checker.findType(nodeAtPosition);
    let typeString = type.nodeType == "Var"
        ? nodeAtPosition.text
        : checker.typeToString(type, params.sourceFile);
    if (typeString.includes(" ")) {
        typeString = `(${typeString})`;
    }
    const typeParameterPosition = vscode_languageserver_1.Position.create(lastParameterType.startPosition.row, lastParameterType.startPosition.column);
    return [vscode_languageserver_1.TextEdit.insert(typeParameterPosition, `${typeString} -> `)];
}
//# sourceMappingURL=addNewFunctionParameter.js.map