"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Forest = void 0;
const imports_1 = require("./imports");
const treeUtils_1 = require("../common/util/treeUtils");
class Forest {
    constructor(rootProject) {
        this.rootProject = rootProject;
        this.sourceFiles = new Map();
        this.kernelSourceFiles = new Map();
    }
    getTree(uri) {
        var _a;
        return (_a = this.getByUri(uri)) === null || _a === void 0 ? void 0 : _a.tree;
    }
    getByUri(uri) {
        return this.sourceFiles.get(uri);
    }
    setSourceFile(uri, writeable, tree, isTestFile, isDependency, project = this.rootProject, maintainerAndPackageName) {
        // Kernel sources do not have trees
        if (tree) {
            tree.uri = uri;
        }
        const sourceFile = {
            maintainerAndPackageName,
            tree,
            uri,
            writeable,
            project,
            isTestFile,
            isDependency,
            parseDiagnostics: [],
            bindDiagnostics: [],
        };
        this.sourceFiles.set(uri, sourceFile);
        return sourceFile;
    }
    removeTree(uri) {
        this.sourceFiles.delete(uri);
    }
    synchronize() {
        this.sourceFiles.forEach((sourceFile) => {
            var _a;
            if (!sourceFile.tree) {
                return;
            }
            // Resolve import modules
            if (!sourceFile.resolvedModules) {
                sourceFile.resolvedModules = this.resolveModules(sourceFile);
            }
            if (!sourceFile.moduleName) {
                const moduleName = (_a = treeUtils_1.TreeUtils.getModuleNameNode(sourceFile.tree)) === null || _a === void 0 ? void 0 : _a.text;
                if (moduleName) {
                    sourceFile.moduleName = moduleName;
                    if (sourceFile.project === this.rootProject &&
                        !this.getModuleMap(sourceFile).has(moduleName)) {
                        this.getModuleMap(sourceFile).set(moduleName, sourceFile.uri);
                    }
                }
            }
        });
    }
    invalidateResolvedModules() {
        this.sourceFiles.forEach((sourceFile) => {
            sourceFile.resolvedModules = undefined;
        });
    }
    setKernelSourceFile(uri, project, maintainerAndPackageName, moduleName) {
        const sourceFile = {
            uri,
            project,
            maintainerAndPackageName,
            moduleName,
        };
        this.kernelSourceFiles.set(uri, sourceFile);
        return sourceFile;
    }
    getKernelSourceFile(uri) {
        return this.kernelSourceFiles.get(uri);
    }
    resolveModules(sourceFile) {
        var _a;
        const importClauses = [
            ...imports_1.Imports.getVirtualImports(),
            ...((_a = treeUtils_1.TreeUtils.findAllImportClauseNodes(sourceFile.tree)) !== null && _a !== void 0 ? _a : []),
        ];
        const resolvedModules = new Map();
        importClauses.forEach((importClause) => {
            var _a;
            const moduleName = (_a = importClause.childForFieldName("moduleName")) === null || _a === void 0 ? void 0 : _a.text;
            if (moduleName) {
                let found = sourceFile.project.moduleToUriMap.get(moduleName);
                if (!found && sourceFile.isTestFile) {
                    found = sourceFile.project.testModuleToUriMap.get(moduleName);
                }
                if (found) {
                    resolvedModules.set(moduleName, found);
                }
            }
        });
        return resolvedModules;
    }
    getModuleMap(sourceFile) {
        return sourceFile.isTestFile
            ? sourceFile.project.testModuleToUriMap
            : sourceFile.project.moduleToUriMap;
    }
}
exports.Forest = Forest;
//# sourceMappingURL=forest.js.map