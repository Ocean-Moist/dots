"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LinkedEditingRangesProvider = void 0;
const tsyringe_1 = require("tsyringe");
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const positionUtil_1 = require("../positionUtil");
const elmWorkspaceMatcher_1 = require("../util/elmWorkspaceMatcher");
const treeUtils_1 = require("../util/treeUtils");
class LinkedEditingRangesProvider {
    constructor() {
        this.provideLinkedEditingRanges = (params) => {
            var _a, _b, _c;
            const ranges = [];
            const nodeAtPosition = treeUtils_1.TreeUtils.getNamedDescendantForPosition(params.sourceFile.tree.rootNode, params.position);
            const range = {
                start: positionUtil_1.PositionUtil.FROM_TS_POSITION(nodeAtPosition.startPosition).toVSPosition(),
                end: positionUtil_1.PositionUtil.FROM_TS_POSITION(nodeAtPosition.endPosition).toVSPosition(),
            };
            if (((_a = nodeAtPosition.parent) === null || _a === void 0 ? void 0 : _a.type) === "function_declaration_left" &&
                treeUtils_1.TreeUtils.getTypeAnnotation((_b = nodeAtPosition.parent.parent) !== null && _b !== void 0 ? _b : undefined)) {
                ranges.push(this.addLinesToRange(range, -1));
                ranges.push(range);
            }
            if (((_c = nodeAtPosition.parent) === null || _c === void 0 ? void 0 : _c.type) === "type_annotation" &&
                nodeAtPosition.type === "lower_case_identifier") {
                ranges.push(range);
                ranges.push(this.addLinesToRange(range, 1));
            }
            if (ranges.length === 0) {
                const lines = params.sourceFile.tree.rootNode.text.split(/\r\n|\r|\n/);
                const line = lines[params.position.line].trim();
                const positionRange = vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(params.position.line, 0), vscode_languageserver_1.Position.create(params.position.line, 0));
                if (line.startsWith(":")) {
                    const nextLine = lines[params.position.line + 1].trim();
                    if (nextLine.endsWith("=")) {
                        ranges.push(positionRange);
                        ranges.push(this.addLinesToRange(positionRange, 1));
                    }
                }
                else if (line.endsWith("=")) {
                    const previousLine = lines[params.position.line - 1].trim();
                    if (previousLine.startsWith(":")) {
                        ranges.push(this.addLinesToRange(positionRange, -1));
                        ranges.push(positionRange);
                    }
                }
            }
            return { ranges };
        };
        this.connection = tsyringe_1.container.resolve("Connection");
        this.connection.onRequest(vscode_languageserver_1.LinkedEditingRangeRequest.type, new elmWorkspaceMatcher_1.ElmWorkspaceMatcher((params) => vscode_uri_1.URI.parse(params.textDocument.uri)).handle(this.provideLinkedEditingRanges.bind(this)));
    }
    addLinesToRange(range, linesToAdd) {
        return {
            start: {
                line: range.start.line + linesToAdd,
                character: range.start.character,
            },
            end: {
                line: range.end.line + linesToAdd,
                character: range.end.character,
            },
        };
    }
}
exports.LinkedEditingRangesProvider = LinkedEditingRangesProvider;
//# sourceMappingURL=linkedEditingRangesProvider.js.map