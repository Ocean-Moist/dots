"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const refactorEditUtils_1 = require("../../util/refactorEditUtils");
const treeUtils_1 = require("../../util/treeUtils");
const diagnostics_1 = require("../../../compiler/diagnostics");
const codeActionProvider_1 = require("../codeActionProvider");
const errorCodes = [diagnostics_1.Diagnostics.MissingValue.code];
const fixId = "make_declaration_from_usage";
codeActionProvider_1.CodeActionProvider.registerCodeAction({
    errorCodes,
    fixId,
    getCodeActions: (params) => {
        const edits = getEdits(params, params.range);
        if (edits.length > 0) {
            return [
                codeActionProvider_1.CodeActionProvider.getCodeAction(params, "Create local function", edits),
            ];
        }
        return [];
    },
    getFixAllCodeAction: (params) => {
        return codeActionProvider_1.CodeActionProvider.getFixAllCodeAction("Create all missing local functions", params, errorCodes, fixId, (edits, diagnostic) => {
            edits.push(...getEdits(params, diagnostic.range));
        });
    },
});
function getEdits(params, range) {
    var _a, _b, _c, _d, _e;
    const nodeAtPosition = treeUtils_1.TreeUtils.getNamedDescendantForRange(params.sourceFile, range);
    if (nodeAtPosition.type === "lower_case_identifier" &&
        ((_b = (_a = nodeAtPosition.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.type) === "value_expr" &&
        ((_d = (_c = nodeAtPosition.parent) === null || _c === void 0 ? void 0 : _c.parent) === null || _d === void 0 ? void 0 : _d.parent) &&
        ((_e = nodeAtPosition.previousSibling) === null || _e === void 0 ? void 0 : _e.type) !== "dot") {
        const funcName = nodeAtPosition.text;
        const tree = params.sourceFile.tree;
        const checker = params.program.getTypeChecker();
        const insertLineNumber = refactorEditUtils_1.RefactorEditUtils.findLineNumberAfterCurrentFunction(nodeAtPosition);
        const type = checker.findType(nodeAtPosition);
        const typeString = checker.typeToString(type, params.sourceFile);
        const edit = refactorEditUtils_1.RefactorEditUtils.createTopLevelFunction(insertLineNumber !== null && insertLineNumber !== void 0 ? insertLineNumber : tree.rootNode.endPosition.row, funcName, typeString, type.nodeType === "Function" ? type.params.length : 0, `Debug.todo "TODO"`);
        if (edit) {
            return [edit];
        }
    }
    return [];
}
//# sourceMappingURL=makeDeclarationFromUsageCodeAction.js.map