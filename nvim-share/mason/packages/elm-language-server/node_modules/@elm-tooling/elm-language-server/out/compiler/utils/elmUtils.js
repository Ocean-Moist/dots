"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isCoreProject = exports.isKernelProject = exports.nameIsKernel = exports.flattenExposedModules = exports.getModuleUri = exports.getModuleName = exports.constraintIntersect = exports.versionSatisfiesConstraint = exports.parseConstraint = exports.parseVersion = exports.solveDependencies = exports.getEmptyTypes = void 0;
const path = __importStar(require("../../common/util/path"));
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
// Special type that has no core mock https://github.com/elm/compiler/blob/51e20357137ebc9c3f6136cf0a3fe21c24027f39/compiler/src/Canonicalize/Environment/Foreign.hs#L62
function getEmptyTypes() {
    return [
        {
            markdown: `An \`List\` is a list of items. Every item must be of the same type. Valid syntax for lists includes:

    []
    [42, 43]
    ["one", "two", "three"]
    [3.14, 0.1234]
    ['a', 'Z', '0']

    `,
            name: "List",
            symbolKind: vscode_languageserver_1.CompletionItemKind.Enum,
        },
    ];
}
exports.getEmptyTypes = getEmptyTypes;
function solveDependencies(packageCache, deps) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield solveDependenciesWorker(packageCache, deps, new Map());
        if (result) {
            return result.solutions;
        }
    });
}
exports.solveDependencies = solveDependencies;
function solveDependenciesWorker(packageCache, deps, solutions) {
    return __awaiter(this, void 0, void 0, function* () {
        function pickDep() {
            const restDeps = new Map(deps);
            const firstDep = Array.from(deps.keys()).sort()[0];
            restDeps.delete(firstDep);
            return [
                firstDep && deps.has(firstDep)
                    ? { name: firstDep, constraint: deps.get(firstDep) }
                    : undefined,
                restDeps,
            ];
        }
        function combineDeps(a, b) {
            const deps = new Map();
            for (const key of new Set([...a.keys(), ...b.keys()])) {
                const v1 = a.get(key);
                const v2 = b.get(key);
                if (v1 && v2) {
                    const intersect = constraintIntersect(v1, v2);
                    if (!intersect) {
                        return;
                    }
                    deps.set(key, intersect);
                }
                else if (v1) {
                    deps.set(key, v1);
                }
                else if (v2) {
                    deps.set(key, v2);
                }
                else {
                    throw new Error("impossible");
                }
            }
            return deps;
        }
        const [dep, restDeps] = pickDep();
        if (!dep) {
            return { pending: deps, solutions };
        }
        // Find versions that satisfy the constraint
        let candidates = (yield packageCache.getVersions(dep.name))
            .filter((version) => versionSatisfiesConstraint(version, dep.constraint))
            .sort((a, b) => (a < b ? -1 : a > b ? 1 : 0))
            .reverse();
        const solvedVersion = solutions.get(dep.name);
        if (solvedVersion) {
            candidates = candidates.filter((a) => a.string === solvedVersion.string);
        }
        for (const candidate of candidates) {
            const candidateDeps = yield packageCache.getDependencies(dep.name, candidate);
            const tentativeDeps = combineDeps(restDeps, candidateDeps);
            if (!tentativeDeps) {
                continue;
            }
            const tentativeSolutions = new Map(solutions);
            tentativeSolutions.set(dep.name, candidate);
            const result = yield solveDependenciesWorker(packageCache, tentativeDeps, tentativeSolutions);
            if (result) {
                return solveDependenciesWorker(packageCache, result.pending, result.solutions);
            }
        }
    });
}
function parseVersion(version) {
    const [major, minor, patch] = version.split(".");
    return {
        major: parseInt(major),
        minor: parseInt(minor),
        patch: parseInt(patch),
        string: version,
    };
}
exports.parseVersion = parseVersion;
function parseConstraint(contraint) {
    const regex = /^(\d+\.\d+\.\d+) (<|<=) v (<|<=) (\d+\.\d+\.\d+)$/gm;
    const m = regex.exec(contraint);
    if (m) {
        const lowerRange = m[1];
        const lowerOperator = m[2];
        const upperOperator = m[3];
        const upperRange = m[4];
        return {
            lower: parseVersion(lowerRange),
            upper: parseVersion(upperRange),
            lowerOperator: lowerOperator,
            upperOperator: upperOperator,
        };
    }
    throw new Error("Could not parse version constraint");
}
exports.parseConstraint = parseConstraint;
function versionSatisfiesConstraint(version, constraint) {
    return (filterSemver(constraint.lower, version, constraint.lowerOperator) &&
        filterSemver(version, constraint.upper, constraint.upperOperator));
}
exports.versionSatisfiesConstraint = versionSatisfiesConstraint;
function filterSemver(lower, upper, operator) {
    const currentCompare = versionCompare(lower, upper);
    switch (operator) {
        case "<=":
            return currentCompare === -1 || currentCompare === 0;
        case "<":
            return currentCompare === -1;
    }
}
function versionCompare(a, b) {
    const pa = a.string.split(".");
    const pb = b.string.split(".");
    for (let i = 0; i < 3; i++) {
        const na = Number(pa[i]);
        const nb = Number(pb[i]);
        if (na > nb) {
            return 1;
        }
        if (nb > na) {
            return -1;
        }
    }
    return 0;
}
function constraintIntersect(a, b) {
    function merge(op1, op2) {
        return op1 === "<" || op2 === "<" ? "<" : "<=";
    }
    let newLower;
    let newLowerOp;
    let newUpper;
    let newUpperOp;
    const lowerCompare = versionCompare(a.lower, b.lower);
    switch (lowerCompare) {
        case -1:
            newLower = b.lower;
            newLowerOp = b.lowerOperator;
            break;
        case 0:
            newLower = a.lower;
            newLowerOp = merge(a.lowerOperator, b.lowerOperator);
            break;
        case 1:
            newLower = a.lower;
            newLowerOp = a.lowerOperator;
            break;
    }
    const upperCompare = versionCompare(a.upper, b.upper);
    switch (upperCompare) {
        case -1:
            newUpper = a.upper;
            newUpperOp = a.upperOperator;
            break;
        case 0:
            newUpper = a.upper;
            newUpperOp = merge(a.upperOperator, b.upperOperator);
            break;
        case 1:
            newUpper = b.upper;
            newUpperOp = b.upperOperator;
            break;
    }
    if (!newLower ||
        !newUpper ||
        !newLowerOp ||
        !newUpperOp ||
        versionCompare(newLower, newUpper) !== -1) {
        return;
    }
    return {
        lower: newLower,
        upper: newUpper,
        lowerOperator: newLowerOp,
        upperOperator: newUpperOp,
    };
}
exports.constraintIntersect = constraintIntersect;
function getModuleName(uri, sourceDir) {
    return path.relative(sourceDir, uri).replace(".elm", "").split("/").join(".");
}
exports.getModuleName = getModuleName;
function getModuleUri(moduleName, sourceDir, project) {
    if (isKernelProject(project) && nameIsKernel(moduleName)) {
        return vscode_uri_1.Utils.joinPath(sourceDir, moduleName.split(".").join("/") + ".js");
    }
    return vscode_uri_1.Utils.joinPath(sourceDir, moduleName.split(".").join("/") + ".elm");
}
exports.getModuleUri = getModuleUri;
function flattenExposedModules(exposedModules) {
    if (Array.isArray(exposedModules)) {
        return exposedModules;
    }
    return Object.values(exposedModules).flatMap((a) => a);
}
exports.flattenExposedModules = flattenExposedModules;
function nameIsKernel(name) {
    return name.startsWith("Elm.Kernel.");
}
exports.nameIsKernel = nameIsKernel;
function isKernelProject(project) {
    if (project.type === "package") {
        const author = project.maintainerAndPackageName.split("/")[0];
        return author === "elm" || author === "elm-explorations";
    }
    return false;
}
exports.isKernelProject = isKernelProject;
function isCoreProject(project) {
    return (project.type === "package" &&
        project.maintainerAndPackageName === "elm/core");
}
exports.isCoreProject = isCoreProject;
//# sourceMappingURL=elmUtils.js.map