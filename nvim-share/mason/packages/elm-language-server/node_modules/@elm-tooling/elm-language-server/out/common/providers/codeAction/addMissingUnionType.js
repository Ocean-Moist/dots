"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
const refactorEditUtils_1 = require("../../util/refactorEditUtils");
const treeUtils_1 = require("../../util/treeUtils");
const diagnostics_1 = require("../../../compiler/diagnostics");
const utils_1 = require("../../util/utils");
const errorCodes = [diagnostics_1.Diagnostics.MissingValue.code];
const fixId = "add_missing_union_type";
__1.CodeActionProvider.registerCodeAction({
    errorCodes,
    fixId,
    getCodeActions: (params) => {
        const edits = getEdits(params, params.range);
        if (Object.values(edits).some((edit) => edit.length > 0)) {
            return [
                __1.CodeActionProvider.getCodeAction(params, `Create missing union constructor`, edits),
            ];
        }
        return [];
    },
    getFixAllCodeAction: (params) => {
        return __1.CodeActionProvider.getFixAllCodeAction("Create all missing union constructors", params, errorCodes, fixId, () => {
            // Not used
        }, (changes, diagnostic) => {
            utils_1.Utils.mergeChanges(changes, getEdits(params, diagnostic.range));
        });
    },
});
function getEdits(params, range) {
    var _a;
    const nodeAtPosition = treeUtils_1.TreeUtils.getNamedDescendantForRange(params.sourceFile, range);
    const nodeParent = nodeAtPosition.parent;
    if (nodeAtPosition.type === "upper_case_identifier" &&
        (nodeParent === null || nodeParent === void 0 ? void 0 : nodeParent.type) === "upper_case_qid") {
        const checker = params.program.getTypeChecker();
        let type = checker.findType(nodeAtPosition);
        let paramTypes = [];
        if (type.nodeType === "Function" && type.return.nodeType === "Union") {
            paramTypes = type.params;
            type = type.return;
        }
        if (type.nodeType === "Union") {
            const typeDeclaration = type.module === params.sourceFile.moduleName
                ? treeUtils_1.TreeUtils.findTypeDeclaration(params.sourceFile.tree, type.name)
                : (_a = checker
                    .getAllImports(params.sourceFile)
                    .getType(type.name, type.module)[0]) === null || _a === void 0 ? void 0 : _a.node;
            if (typeDeclaration) {
                const typeDeclarationSourceFile = params.program.getSourceFile(typeDeclaration.tree.uri);
                const edit = refactorEditUtils_1.RefactorEditUtils.addUnionVariant(typeDeclaration, nodeAtPosition.text, paramTypes.map((type) => checker.typeToString(type, typeDeclarationSourceFile)));
                if (edit) {
                    return {
                        [typeDeclaration.tree.uri]: [edit],
                    };
                }
            }
        }
    }
    return {};
}
//# sourceMappingURL=addMissingUnionType.js.map