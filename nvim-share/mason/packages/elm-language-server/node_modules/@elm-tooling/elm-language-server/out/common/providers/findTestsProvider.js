"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringLiteralToLabel = exports.findTestSuite = exports.findTestFunctionCall = exports.findAllTestSuites = exports.FindTestsProvider = void 0;
const tsyringe_1 = require("tsyringe");
const vscode_languageserver_1 = require("vscode-languageserver");
const expressionTree_1 = require("../../compiler/utils/expressionTree");
const protocol_1 = require("../protocol");
const noWorkspaceContainsError_1 = require("../util/noWorkspaceContainsError");
const treeUtils_1 = require("../util/treeUtils");
const utils_1 = require("../util/utils");
const vscode_uri_1 = require("vscode-uri");
class FindTestsProvider {
    constructor() {
        const connection = tsyringe_1.container.resolve("Connection");
        connection.onRequest(protocol_1.FindTestsRequest, (params) => __awaiter(this, void 0, void 0, function* () {
            const projectFolderUri = vscode_uri_1.URI.parse(params.projectFolder);
            connection.console.info(`Finding tests is requested ${projectFolderUri.toString()}`);
            try {
                const elmWorkspaces = tsyringe_1.container.resolve("ElmWorkspaces");
                yield Promise.all(elmWorkspaces
                    .filter((ws) => !ws.isInitialized)
                    .map((ws) => ws.init()));
                const program = elmWorkspaces.find((program) => program.getRootPath().toString() == projectFolderUri.toString());
                if (!program) {
                    throw new noWorkspaceContainsError_1.NoWorkspaceContainsError(projectFolderUri);
                }
                const suites = findAllTestSuites(program);
                connection.console.info(`Found ${suites.length} top test suites in ${projectFolderUri.toString()}`);
                return { suites };
            }
            catch (error) {
                connection.console.error(`Error finding tests ${error}`);
                return new vscode_languageserver_1.ResponseError(1, `Error finding tests ${error}`);
            }
        }));
    }
}
exports.FindTestsProvider = FindTestsProvider;
// export for testing
function findAllTestSuites(program) {
    const typeChecker = program.getTypeChecker();
    return program
        .getSourceFiles()
        .filter((sourceFile) => sourceFile.isTestFile)
        .map((sourceFile) => {
        var _a;
        const topSuites = (_a = treeUtils_1.TreeUtils.findAllTopLevelFunctionDeclarations(sourceFile.tree)) === null || _a === void 0 ? void 0 : _a.map((top) => {
            return (top &&
                findTestSuite(findTestFunctionCall(top, typeChecker), sourceFile, typeChecker));
        }).filter(utils_1.Utils.notUndefined);
        return topSuites ? rootSuite(sourceFile, topSuites) : undefined;
    })
        .filter(utils_1.Utils.notUndefined);
}
exports.findAllTestSuites = findAllTestSuites;
function rootSuite(sourceFile, topSuites) {
    const file = sourceFile.uri.toString();
    const label = sourceFile.moduleName;
    return label && topSuites.length > 0
        ? {
            label,
            tests: topSuites,
            file,
            position: { line: 0, character: 0 },
        }
        : undefined;
}
// export for testing
function findTestFunctionCall(node, typeChecker) {
    const letIn = findChildExpr("LetInExpr", node);
    if (letIn) {
        return findTestFunctionCall(letIn.body, typeChecker);
    }
    const call = findExpr("FunctionCallExpr", node);
    if (!call) {
        return undefined;
    }
    const t = typeChecker.findType(call);
    const isTest = (t) => t.nodeType === "Union" && t.module === "Test.Internal" && t.name === "Test";
    if (isTest(t)) {
        return call;
    }
    if (t.nodeType === "Function" && isTest(t.return)) {
        // TODO do we need this case?
        return call;
    }
}
exports.findTestFunctionCall = findTestFunctionCall;
function isTestSuite(call, sourceFile, typeChecker) {
    var _a, _b;
    const funName = (_a = findExpr("ValueExpr", call.target)) === null || _a === void 0 ? void 0 : _a.name;
    const dot = (_b = funName === null || funName === void 0 ? void 0 : funName.lastIndexOf(".")) !== null && _b !== void 0 ? _b : -1;
    const prefix = dot > -1 ? funName === null || funName === void 0 ? void 0 : funName.substring(0, dot) : undefined;
    const qualifier = prefix !== undefined
        ? typeChecker.getQualifierForName(sourceFile, "Test", "describe")
        : "";
    return (funName === `${qualifier}describe` &&
        (!prefix ||
            typeChecker
                .findImportModuleNameNodes(prefix, sourceFile)
                .some((n) => n.text === "Test")));
}
function findFirstStringArg(call, typeChecker) {
    const stringArg = call.args.find((arg) => {
        const t = typeChecker.findType(arg);
        return typeChecker.typeToString(t) === "String";
    });
    return stringArg;
}
// export for testing
function findTestSuite(call, sourceFile, typeChecker) {
    var _a, _b;
    if (!call) {
        return undefined;
    }
    const stringArg = findFirstStringArg(call, typeChecker);
    const labelParts = (_a = findAllExprs("StringConstant", stringArg)) === null || _a === void 0 ? void 0 : _a.map((e) => e.text).map((l) => stringLiteralToLabel(l));
    const position = {
        line: call.startPosition.row,
        character: call.startPosition.column,
    };
    const file = sourceFile.uri.toString();
    const label = (labelParts === null || labelParts === void 0 ? void 0 : labelParts.length) === 1 ? labelParts[0] : undefined;
    if (label && isTestSuite(call, sourceFile, typeChecker)) {
        const testExprs = (_b = findExpr("ListExpr", call.args[1])) === null || _b === void 0 ? void 0 : _b.exprList;
        const tests = testExprs === null || testExprs === void 0 ? void 0 : testExprs.map((e) => findTestFunctionCall(e, typeChecker)).map((call) => findTestSuite(call, sourceFile, typeChecker)).filter(utils_1.Utils.notUndefined);
        return tests && tests.length > 0
            ? { label, tests, file, position }
            : undefined;
    }
    return label ? { label, file, position } : undefined;
}
exports.findTestSuite = findTestSuite;
const typeByNodeType = new Map([
    ["ValueExpr", "value_expr"],
    ["StringConstant", "string_constant_expr"],
    ["ListExpr", "list_expr"],
    ["FunctionCallExpr", "function_call_expr"],
    ["LetInExpr", "let_in_expr"],
]);
function findExpr(key, node) {
    if (!node) {
        return undefined;
    }
    const type = typeByNodeType.get(key);
    if (!type) {
        return undefined;
    }
    const n = node.type === type ? node : treeUtils_1.TreeUtils.descendantsOfType(node, type)[0];
    const e = (0, expressionTree_1.mapSyntaxNodeToExpression)(n);
    return e && mapExpr(key, e);
}
function findChildExpr(key, node) {
    if (!node) {
        return undefined;
    }
    const type = typeByNodeType.get(key);
    if (!type) {
        return undefined;
    }
    const n = node.type === type ? node : treeUtils_1.TreeUtils.findFirstNamedChildOfType(type, node);
    const e = (0, expressionTree_1.mapSyntaxNodeToExpression)(n);
    return e && mapExpr(key, e);
}
function findAllExprs(key, node) {
    if (!node) {
        return undefined;
    }
    const type = typeByNodeType.get(key);
    if (!type) {
        return undefined;
    }
    const children = treeUtils_1.TreeUtils.descendantsOfType(node, type);
    const es = children === null || children === void 0 ? void 0 : children.map((n) => (0, expressionTree_1.mapSyntaxNodeToExpression)(n));
    return es === null || es === void 0 ? void 0 : es.map((e) => e && mapExpr(key, e)).flatMap((v) => (v ? [v] : []));
}
function mapExpr(k, e) {
    return (e === null || e === void 0 ? void 0 : e.nodeType) === k ? e : undefined;
}
// export for testing
function stringLiteralToLabel(literal) {
    if (literal.startsWith('"""')) {
        // without unescaping
        return literal.substring(3, literal.length - 3);
    }
    // with unescaping
    return String(JSON.parse(literal));
}
exports.stringLiteralToLabel = stringLiteralToLabel;
//# sourceMappingURL=findTestsProvider.js.map