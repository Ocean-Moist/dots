"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findDefinition = exports.mapTypeAnnotation = exports.mapTypeDeclaration = exports.mapTypeAliasDeclaration = exports.mapSyntaxNodeToExpression = exports.resetDefinitionAndMappingTime = exports.mappingTime = exports.definitionTime = void 0;
const treeUtils_1 = require("../../common/util/treeUtils");
const utils_1 = require("../../common/util/utils");
const perf_hooks_1 = require("perf_hooks");
/* eslint-disable @typescript-eslint/naming-convention */
exports.definitionTime = 0;
exports.mappingTime = 0;
function resetDefinitionAndMappingTime() {
    exports.definitionTime = 0;
    exports.mappingTime = 0;
}
exports.resetDefinitionAndMappingTime = resetDefinitionAndMappingTime;
function mapSyntaxNodeToExpression(node) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
    if (!node)
        return;
    const start = perf_hooks_1.performance.now();
    try {
        switch (node.type) {
            case "lower_case_identifier":
                return node;
            case "value_declaration":
                {
                    const valueDeclaration = node;
                    valueDeclaration.nodeType = "ValueDeclaration";
                    valueDeclaration.params =
                        (_b = (_a = node.firstNamedChild) === null || _a === void 0 ? void 0 : _a.namedChildren.slice(1).map((a) => a.text)) !== null && _b !== void 0 ? _b : [];
                    valueDeclaration.body = (_c = node.childForFieldName("body")) !== null && _c !== void 0 ? _c : undefined;
                    valueDeclaration.typeAnnotation = treeUtils_1.TreeUtils.getTypeAnnotation(node);
                    valueDeclaration.pattern =
                        (_d = node.childForFieldName("pattern")) !== null && _d !== void 0 ? _d : undefined;
                    return valueDeclaration;
                }
                break;
            case "value_expr": {
                const valueExpr = node;
                valueExpr.nodeType = "ValueExpr";
                valueExpr.name = node.text;
                return valueExpr;
            }
            case "bin_op_expr": {
                {
                    const binOpExpr = node;
                    binOpExpr.nodeType = "BinOpExpr";
                    binOpExpr.parts = node.children
                        .map(mapSyntaxNodeToExpression)
                        .filter(utils_1.Utils.notUndefined);
                    return binOpExpr;
                }
            }
            case "operator_identifier": {
                const operatorIdentifier = node;
                operatorIdentifier.nodeType = "Operator";
                return operatorIdentifier;
            }
            case "number_constant_expr": {
                const numberConstantExpr = node;
                numberConstantExpr.nodeType = "NumberConstant";
                numberConstantExpr.isFloat = node.text.includes(".");
                return numberConstantExpr;
            }
            case "string_constant_expr": {
                const stringConstantExpr = node;
                stringConstantExpr.nodeType = "StringConstant";
                return stringConstantExpr;
            }
            case "parenthesized_expr":
                return mapSyntaxNodeToExpression(node.childForFieldName("expression"));
            case "function_call_expr":
                {
                    const target = mapSyntaxNodeToExpression(node.childForFieldName("target"));
                    if (target) {
                        const functionCallExpr = node;
                        functionCallExpr.nodeType = "FunctionCallExpr";
                        functionCallExpr.target = target;
                        functionCallExpr.args = node.children
                            .slice(1)
                            .filter((n) => !n.type.includes("comment"))
                            .map(mapSyntaxNodeToExpression);
                        return functionCallExpr;
                    }
                }
                break;
            case "type_annotation": {
                const typeAnnotation = node;
                typeAnnotation.nodeType = "TypeAnnotation";
                return typeAnnotation;
            }
            case "type_expression": {
                const typeExpression = node;
                typeExpression.nodeType = "TypeExpression";
                typeExpression.segments = node.children
                    .map(mapSyntaxNodeToExpression)
                    .filter(utils_1.Utils.notUndefined);
                return typeExpression;
            }
            case "type_variable": {
                const typeVariable = node;
                typeVariable.nodeType = "TypeVariable";
                return typeVariable;
            }
            case "type_ref": {
                const typeRef = node;
                typeRef.nodeType = "TypeRef";
                return typeRef;
            }
            case "type_declaration": {
                const typeDeclaration = node;
                typeDeclaration.nodeType = "TypeDeclaration";
                return typeDeclaration;
            }
            case "infix_declaration": {
                const infixDeclaration = node;
                infixDeclaration.nodeType = "InfixDeclaration";
                infixDeclaration.precedence = parseInt((_f = (_e = node.childForFieldName("precedence")) === null || _e === void 0 ? void 0 : _e.text) !== null && _f !== void 0 ? _f : "");
                infixDeclaration.associativity =
                    (_h = (_g = node
                        .childForFieldName("associativity")) === null || _g === void 0 ? void 0 : _g.text.toUpperCase()) !== null && _h !== void 0 ? _h : "NON";
                return infixDeclaration;
            }
            case "function_declaration_left": {
                const functionDeclarationLeft = node;
                functionDeclarationLeft.nodeType = "FunctionDeclarationLeft";
                functionDeclarationLeft.params = (_j = node.namedChildren
                    .filter((n) => n.type.includes("pattern") || n.type === "unit_expr")) === null || _j === void 0 ? void 0 : _j.map(mapSyntaxNodeToExpression).filter(utils_1.Utils.notUndefined);
                return functionDeclarationLeft;
            }
            case "pattern": {
                const patternAs = node.childForFieldName("patternAs");
                const pattern = node;
                pattern.nodeType = "Pattern";
                if (patternAs) {
                    pattern.patternAs = mapSyntaxNodeToExpression(patternAs);
                }
                return pattern;
            }
            case "lower_pattern": {
                const lowerPattern = node;
                lowerPattern.nodeType = "LowerPattern";
                return lowerPattern;
            }
            case "lower_type_name": {
                const lowerTypeName = node;
                lowerTypeName.nodeType = "LowerTypeName";
                return lowerTypeName;
            }
            case "union_variant": {
                const unionVariant = node;
                unionVariant.nodeType = "UnionVariant";
                unionVariant.name = (_l = (_k = node.childForFieldName("name")) === null || _k === void 0 ? void 0 : _k.text) !== null && _l !== void 0 ? _l : "";
                unionVariant.params = node.children
                    .slice(1)
                    .filter((n) => !n.type.includes("comment"))
                    .map(mapSyntaxNodeToExpression)
                    .filter(utils_1.Utils.notUndefined);
                return unionVariant;
            }
            case "if_else_expr": {
                const ifElseExpr = node;
                ifElseExpr.nodeType = "IfElseExpr";
                ifElseExpr.exprList = node.namedChildren
                    .map((n) => mapSyntaxNodeToExpression(n))
                    .filter(utils_1.Utils.notUndefined);
                return ifElseExpr;
            }
            case "let_in_expr": {
                const letInExpr = node;
                letInExpr.nodeType = "LetInExpr";
                letInExpr.valueDeclarations =
                    (_o = (_m = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("value_declaration", node)) === null || _m === void 0 ? void 0 : _m.map(mapSyntaxNodeToExpression)) !== null && _o !== void 0 ? _o : [];
                letInExpr.body = mapSyntaxNodeToExpression(node.lastNamedChild);
                return letInExpr;
            }
            case "case_of_expr": {
                const caseOfExpr = node;
                caseOfExpr.nodeType = "CaseOfExpr";
                caseOfExpr.expr = mapSyntaxNodeToExpression(node.namedChildren[1]);
                caseOfExpr.branches = node.namedChildren
                    .slice(3)
                    .map(mapSyntaxNodeToExpression)
                    .filter(utils_1.Utils.notUndefined);
                return caseOfExpr;
            }
            case "case_of_branch": {
                const caseOfBranch = node;
                caseOfBranch.nodeType = "CaseOfBranch";
                caseOfBranch.pattern = mapSyntaxNodeToExpression(node.childForFieldName("pattern"));
                caseOfBranch.expr = mapSyntaxNodeToExpression(node.childForFieldName("expr"));
                return caseOfBranch;
            }
            case "anonymous_function_expr": {
                const anonymousFunctionExpr = node;
                anonymousFunctionExpr.nodeType = "AnonymousFunctionExpr";
                anonymousFunctionExpr.params = (_p = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("pattern", node)) === null || _p === void 0 ? void 0 : _p.map(mapSyntaxNodeToExpression).filter((n) => (n === null || n === void 0 ? void 0 : n.nodeType) === "Pattern");
                anonymousFunctionExpr.expr = mapSyntaxNodeToExpression(node.lastNamedChild);
                return anonymousFunctionExpr;
            }
            case "unit_expr": {
                const unitExpr = node;
                unitExpr.nodeType = "UnitExpr";
                return unitExpr;
            }
            case "tuple_expr": {
                const tupleExpr = node;
                tupleExpr.nodeType = "TupleExpr";
                tupleExpr.exprList = node.namedChildren
                    .map(mapSyntaxNodeToExpression)
                    .filter(utils_1.Utils.notUndefined);
                return tupleExpr;
            }
            case "anything_pattern": {
                const anythingPattern = node;
                anythingPattern.nodeType = "AnythingPattern";
                return anythingPattern;
            }
            case "tuple_pattern": {
                const tuplePattern = node;
                tuplePattern.nodeType = "TuplePattern";
                tuplePattern.patterns = (_q = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("pattern", node)) === null || _q === void 0 ? void 0 : _q.map(mapSyntaxNodeToExpression).filter(utils_1.Utils.notUndefined);
                return tuplePattern;
            }
            case "tuple_type": {
                const tupleType = node;
                tupleType.nodeType = "TupleType";
                tupleType.typeExpressions = (_r = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("type_expression", node)) === null || _r === void 0 ? void 0 : _r.map(mapSyntaxNodeToExpression).filter(utils_1.Utils.notUndefined);
                tupleType.unitExpr = mapSyntaxNodeToExpression(node.childForFieldName("unitExpr"));
                return tupleType;
            }
            case "list_expr": {
                const listExpr = node;
                listExpr.nodeType = "ListExpr";
                listExpr.exprList = node.children
                    .filter((n) => n.type.endsWith("expr"))
                    .map(mapSyntaxNodeToExpression);
                return listExpr;
            }
            case "list_pattern": {
                const listPattern = node;
                listPattern.nodeType = "ListPattern";
                listPattern.parts = node.namedChildren
                    .filter((n) => n.type.includes("pattern"))
                    .map(mapSyntaxNodeToExpression)
                    .filter(utils_1.Utils.notUndefined);
                return listPattern;
            }
            case "union_pattern": {
                const unionPattern = node;
                unionPattern.nodeType = "UnionPattern";
                unionPattern.constructor = node.firstNamedChild;
                unionPattern.namedParams = node
                    .descendantsOfType("lower_pattern")
                    .map(mapSyntaxNodeToExpression)
                    .filter(utils_1.Utils.notUndefined);
                unionPattern.argPatterns = node.namedChildren
                    .slice(1)
                    .filter((node) => node.type.includes("pattern") ||
                    node.type.includes("constant") ||
                    node.type === "unit_expr")
                    .map((node) => { var _a; return (_a = mapSyntaxNodeToExpression(node)) !== null && _a !== void 0 ? _a : node; });
                return unionPattern;
            }
            case "cons_pattern":
                return Object.assign(node, {
                    nodeType: "ConsPattern",
                    parts: node.namedChildren
                        .filter((n) => n.type.includes("pattern"))
                        .map(mapSyntaxNodeToExpression)
                        .filter(utils_1.Utils.notUndefined),
                });
            case "record_type": {
                const recordType = node;
                recordType.nodeType = "RecordType";
                recordType.baseType = mapSyntaxNodeToExpression(node.childForFieldName("baseRecord"));
                recordType.fieldTypes = (_s = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("field_type", node)) === null || _s === void 0 ? void 0 : _s.map(mapSyntaxNodeToExpression).filter(utils_1.Utils.notUndefined);
                return recordType;
            }
            case "field_type": {
                const fieldType = node;
                fieldType.nodeType = "FieldType";
                fieldType.name = (_u = (_t = node.childForFieldName("name")) === null || _t === void 0 ? void 0 : _t.text) !== null && _u !== void 0 ? _u : "";
                fieldType.typeExpression = mapSyntaxNodeToExpression(node.childForFieldName("typeExpression"));
                return fieldType;
            }
            case "type_alias_declaration": {
                const typeAliasDeclaration = node;
                typeAliasDeclaration.nodeType = "TypeAliasDeclaration";
                return typeAliasDeclaration;
            }
            case "field": {
                const field = node;
                field.nodeType = "Field";
                field.name = mapSyntaxNodeToExpression(node.firstNamedChild);
                field.expression = mapSyntaxNodeToExpression(node.lastNamedChild);
                return field;
            }
            case "field_access_expr": {
                const fieldAccessExpr = node;
                fieldAccessExpr.nodeType = "FieldAccessExpr";
                fieldAccessExpr.target = mapSyntaxNodeToExpression(node.firstNamedChild);
                return fieldAccessExpr;
            }
            case "field_accessor_function_expr": {
                const fieldAccessorFunctionExpr = node;
                fieldAccessorFunctionExpr.nodeType = "FieldAccessorFunctionExpr";
                return fieldAccessorFunctionExpr;
            }
            case "record_pattern": {
                const recordPattern = node;
                recordPattern.nodeType = "RecordPattern";
                recordPattern.patternList = (_v = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("lower_pattern", node)) === null || _v === void 0 ? void 0 : _v.map(mapSyntaxNodeToExpression).filter(utils_1.Utils.notUndefined).filter((pattern) => pattern.text !== "");
                return recordPattern;
            }
            case "record_expr": {
                const recordExpr = node;
                recordExpr.nodeType = "RecordExpr";
                recordExpr.baseRecord = node.childForFieldName("baseRecord");
                recordExpr.fields =
                    (_x = (_w = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("field", node)) === null || _w === void 0 ? void 0 : _w.map(mapSyntaxNodeToExpression).filter(utils_1.Utils.notUndefined)) !== null && _x !== void 0 ? _x : [];
                return recordExpr;
            }
            case "port_annotation":
                return Object.assign(node, {
                    nodeType: "PortAnnotation",
                    name: (_z = (_y = node.childForFieldName("name")) === null || _y === void 0 ? void 0 : _y.text) !== null && _z !== void 0 ? _z : "",
                    typeExpression: mapSyntaxNodeToExpression(node.childForFieldName("typeExpression")),
                });
            case "char_constant_expr": {
                const charConstantExpr = node;
                charConstantExpr.nodeType = "CharConstantExpr";
                return charConstantExpr;
            }
            case "glsl_code_expr":
                return Object.assign(node, {
                    nodeType: "GlslCodeExpr",
                    content: node.childForFieldName("content"),
                });
            case "operator_as_function_expr":
                return Object.assign(node, {
                    nodeType: "OperatorAsFunctionExpr",
                    operator: mapSyntaxNodeToExpression(node.childForFieldName("operator")),
                });
            case "negate_expr": {
                const negateExpr = node;
                negateExpr.nodeType = "NegateExpr";
                negateExpr.expression = mapSyntaxNodeToExpression(node.lastNamedChild);
                return negateExpr;
            }
            case "nullary_constructor_argument_pattern":
                return Object.assign(node, {
                    nodeType: "NullaryConstructorArgumentPattern",
                });
            default:
                return mapSyntaxNodeToExpression(node.firstNamedChild);
        }
    }
    finally {
        exports.mappingTime += perf_hooks_1.performance.now() - start;
    }
}
exports.mapSyntaxNodeToExpression = mapSyntaxNodeToExpression;
function mapTypeAliasDeclaration(typeAliasDeclaration) {
    var _a, _b;
    typeAliasDeclaration.name = typeAliasDeclaration.childForFieldName("name");
    typeAliasDeclaration.typeVariables =
        (_b = (_a = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("lower_type_name", typeAliasDeclaration)) === null || _a === void 0 ? void 0 : _a.map(mapSyntaxNodeToExpression).filter(utils_1.Utils.notUndefined)) !== null && _b !== void 0 ? _b : [];
    typeAliasDeclaration.typeExpression = mapSyntaxNodeToExpression(typeAliasDeclaration.childForFieldName("typeExpression"));
}
exports.mapTypeAliasDeclaration = mapTypeAliasDeclaration;
function mapTypeDeclaration(typeDeclaration) {
    var _a, _b, _c, _d;
    typeDeclaration.name = (_b = (_a = typeDeclaration.childForFieldName("name")) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : "";
    typeDeclaration.typeNames =
        (_d = (_c = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("lower_type_name", typeDeclaration)) === null || _c === void 0 ? void 0 : _c.map(mapSyntaxNodeToExpression)) !== null && _d !== void 0 ? _d : [];
}
exports.mapTypeDeclaration = mapTypeDeclaration;
function mapTypeAnnotation(typeAnnotation) {
    var _a, _b;
    typeAnnotation.name = (_b = (_a = typeAnnotation.firstNamedChild) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : "";
    typeAnnotation.typeExpression = mapSyntaxNodeToExpression(typeAnnotation.childForFieldName("typeExpression"));
}
exports.mapTypeAnnotation = mapTypeAnnotation;
function findDefinition(e, program) {
    var _a;
    if (!e) {
        return { diagnostics: [] };
    }
    const sourceFile = program.getSourceFile(e.tree.uri);
    if (!sourceFile) {
        return { diagnostics: [] };
    }
    const start = perf_hooks_1.performance.now();
    const definition = program
        .getTypeChecker()
        .findDefinitionShallow(e, sourceFile);
    exports.definitionTime += perf_hooks_1.performance.now() - start;
    const mappedNode = mapSyntaxNodeToExpression((_a = definition.symbol) === null || _a === void 0 ? void 0 : _a.node);
    return {
        expr: mappedNode,
        diagnostics: definition.diagnostics,
    };
}
exports.findDefinition = findDefinition;
//# sourceMappingURL=expressionTree.js.map