"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSpaces = exports.RefactorEditUtils = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const treeUtils_1 = require("./treeUtils");
class RefactorEditUtils {
    static findLineNumberAfterCurrentFunction(nodeAtPosition) {
        var _a;
        if (!nodeAtPosition.parent) {
            return undefined;
        }
        if (((_a = nodeAtPosition.parent) === null || _a === void 0 ? void 0 : _a.type) === "file") {
            return nodeAtPosition.endPosition.row + 1;
        }
        return this.findLineNumberAfterCurrentFunction(nodeAtPosition.parent);
    }
    static findLineNumberBeforeCurrentFunction(nodeAtPosition) {
        var _a;
        if (!nodeAtPosition.parent) {
            return undefined;
        }
        if (((_a = nodeAtPosition.parent) === null || _a === void 0 ? void 0 : _a.type) === "file") {
            return nodeAtPosition.startPosition.row - 1;
        }
        return this.findLineNumberBeforeCurrentFunction(nodeAtPosition.parent);
    }
    static unexposedValueInModule(tree, valueName) {
        const exposedNodes = treeUtils_1.TreeUtils.getModuleExposingListNodes(tree);
        if (exposedNodes.length <= 1) {
            // We can't remove the last exposed one and removing the whole module annotation would just lead to elm-format readding it
            return undefined;
        }
        else {
            return this.removeValueFromExposingList(exposedNodes, valueName);
        }
    }
    static createTopLevelFunction(insertLineNumber, valueName, typeString, args, content) {
        return this.createFunction(insertLineNumber, valueName, typeString, args, content);
    }
    static createFunction(insertLineNumber, valueName, typeString, args, content, contentIndendation = 0, targetIndendation = 0) {
        const hasArity0 = args === 0 || (Array.isArray(args) && args.length === 0);
        const argList = typeof args === "number" ? this.argListFromArity(args) : args.join(" ");
        const bodyTargetIndendation = targetIndendation + 4;
        const spaces = getSpaces(targetIndendation);
        const bodySpaces = getSpaces(bodyTargetIndendation);
        const diffIndentation = bodyTargetIndendation - contentIndendation;
        if (diffIndentation > 0) {
            const diffSpaces = getSpaces(diffIndentation);
            content = content.split("\n").join(`\n${diffSpaces}`);
        }
        else if (diffIndentation < 0) {
            content = content
                .split("\n")
                .map((line) => {
                let i = 0;
                while (i < Math.abs(diffIndentation) && line[i] === " ") {
                    i++;
                }
                return line.slice(i);
            })
                .join("\n");
        }
        if (hasArity0) {
            return vscode_languageserver_1.TextEdit.insert(vscode_languageserver_1.Position.create(insertLineNumber, 0), `\n\n${typeString ? `${spaces}${valueName}` + " : " + typeString + "\n" : ""}${spaces}${valueName} =\n${bodySpaces}${content}\n`);
        }
        else {
            return vscode_languageserver_1.TextEdit.insert(vscode_languageserver_1.Position.create(insertLineNumber, 0), `\n\n${typeString ? `${spaces}${valueName}` + " : " + typeString + "\n" : ""}${spaces}${valueName} ${argList} =\n${bodySpaces}${content}\n`);
        }
    }
    static createTypeAlias(insertLineNumber, aliasName, typeString, typeVariables) {
        const typeVariablesString = typeVariables.length > 0 ? ` ${typeVariables.join(" ")}` : "";
        return vscode_languageserver_1.TextEdit.insert(vscode_languageserver_1.Position.create(insertLineNumber, 0), `\ntype alias ${aliasName}${typeVariablesString} = ${typeString}\n\n`);
    }
    static argListFromArity(arity) {
        return [...Array(arity).keys()].map((a) => `arg${a + 1}`).join(" ");
    }
    static exposeValueInModule(tree, valueName, withVariants = false) {
        const exposedNodes = treeUtils_1.TreeUtils.getModuleExposingListNodes(tree);
        if (exposedNodes.length > 0) {
            const lastExposedNode = exposedNodes[exposedNodes.length - 1];
            if (withVariants) {
                valueName += "(..)";
            }
            if (exposedNodes.findIndex((n) => n.text === valueName) !== -1) {
                return;
            }
            if (lastExposedNode) {
                return vscode_languageserver_1.TextEdit.insert(vscode_languageserver_1.Position.create(lastExposedNode.endPosition.row, lastExposedNode.endPosition.column), `, ${valueName}`);
            }
        }
    }
    static removeValueFromImport(tree, moduleName, valueName, forceRemoveLastComma = false) {
        const importClause = treeUtils_1.TreeUtils.findImportClauseByName(tree, moduleName);
        if (importClause) {
            const exposedValuesAndTypes = [
                ...importClause.descendantsOfType(["exposed_value", "exposed_type"]),
            ];
            if (exposedValuesAndTypes.length === 1 &&
                exposedValuesAndTypes[0].text === valueName) {
                // Remove the entire exposing list if it was the only one
                const exposingList = treeUtils_1.TreeUtils.findFirstNamedChildOfType("exposing_list", importClause);
                if (exposingList) {
                    return vscode_languageserver_1.TextEdit.del(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(exposingList.startPosition.row, exposingList.startPosition.column - 1), vscode_languageserver_1.Position.create(exposingList.endPosition.row, exposingList.endPosition.column)));
                }
            }
            else {
                return this.removeValueFromExposingList(exposedValuesAndTypes, valueName, forceRemoveLastComma);
            }
        }
    }
    static removeImportExposingList(tree, moduleName) {
        const importClause = treeUtils_1.TreeUtils.findImportClauseByName(tree, moduleName);
        const exposingList = importClause === null || importClause === void 0 ? void 0 : importClause.childForFieldName("exposing");
        if (exposingList) {
            return vscode_languageserver_1.TextEdit.del(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(exposingList.startPosition.row, exposingList.startPosition.column - 1), vscode_languageserver_1.Position.create(exposingList.endPosition.row, exposingList.endPosition.column)));
        }
    }
    static addImport(tree, moduleName, valueName, moduleAlias) {
        var _a, _b, _c;
        const lastImportNode = (_b = (_a = treeUtils_1.TreeUtils.getLastImportNode(tree)) !== null && _a !== void 0 ? _a : treeUtils_1.TreeUtils.getModuleNameCommentNode(tree)) !== null && _b !== void 0 ? _b : (_c = treeUtils_1.TreeUtils.getModuleNameNode(tree)) === null || _c === void 0 ? void 0 : _c.parent;
        const aliasText = moduleAlias && moduleAlias !== moduleName ? ` as ${moduleAlias}` : "";
        return vscode_languageserver_1.TextEdit.insert(vscode_languageserver_1.Position.create((lastImportNode === null || lastImportNode === void 0 ? void 0 : lastImportNode.endPosition.row)
            ? (lastImportNode === null || lastImportNode === void 0 ? void 0 : lastImportNode.endPosition.row) + 1
            : 1, 0), valueName
            ? `import ${moduleName}${aliasText} exposing (${valueName})\n`
            : `import ${moduleName}${aliasText}\n`);
    }
    static changeQualifiedReferenceModule(node, newModuleName) {
        if (node.parent && node.parent.type === "value_qid") {
            const moduleNode = treeUtils_1.TreeUtils.findFirstNamedChildOfType("upper_case_identifier", node.parent);
            if (moduleNode) {
                return vscode_languageserver_1.TextEdit.replace(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(moduleNode.startPosition.row, moduleNode.startPosition.column), vscode_languageserver_1.Position.create(moduleNode.endPosition.row, moduleNode.endPosition.column)), newModuleName);
            }
        }
    }
    static removeQualifiedReference(node) {
        if (node.parent && node.parent.type === "value_qid") {
            const moduleNode = treeUtils_1.TreeUtils.findFirstNamedChildOfType("upper_case_identifier", node.parent);
            if (moduleNode) {
                return vscode_languageserver_1.TextEdit.del(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(moduleNode.startPosition.row, moduleNode.startPosition.column), vscode_languageserver_1.Position.create(moduleNode.endPosition.row, moduleNode.endPosition.column + 1)));
            }
        }
    }
    static addImports(tree, importData) {
        var _a, _b;
        const lastImportNode = (_a = treeUtils_1.TreeUtils.getLastImportNode(tree)) !== null && _a !== void 0 ? _a : (_b = treeUtils_1.TreeUtils.getModuleNameNode(tree)) === null || _b === void 0 ? void 0 : _b.parent;
        const imports = importData
            .filter((data, i, array) => array.findIndex((d) => d.moduleName === data.moduleName &&
            d.valueName === data.valueName) === i)
            .map((data) => data.valueName
            ? `import ${data.moduleName} exposing (${data.valueName})`
            : `import ${data.moduleName}`)
            .join("\n")
            .concat("\n");
        return vscode_languageserver_1.TextEdit.insert(vscode_languageserver_1.Position.create((lastImportNode === null || lastImportNode === void 0 ? void 0 : lastImportNode.endPosition.row)
            ? (lastImportNode === null || lastImportNode === void 0 ? void 0 : lastImportNode.endPosition.row) + 1
            : 1, 0), imports);
    }
    static addModuleDeclaration(moduleName) {
        return vscode_languageserver_1.TextEdit.insert(vscode_languageserver_1.Position.create(0, 0), `module ${moduleName} exposing (..)`);
    }
    static renameModuleDeclaration(tree, newModuleName) {
        const moduleNameNode = treeUtils_1.TreeUtils.getModuleNameNode(tree);
        if (moduleNameNode) {
            return vscode_languageserver_1.TextEdit.replace(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(moduleNameNode.startPosition.row, moduleNameNode.startPosition.column), vscode_languageserver_1.Position.create(moduleNameNode.endPosition.row, moduleNameNode.endPosition.column)), newModuleName);
        }
    }
    static removeRecordPatternValue(pattern) {
        var _a, _b, _c;
        let startPosition = pattern.startPosition;
        let endPosition = pattern.endPosition;
        if (((_a = pattern.previousSibling) === null || _a === void 0 ? void 0 : _a.text) === ",") {
            startPosition = pattern.previousSibling.startPosition;
        }
        if (((_b = pattern.previousSibling) === null || _b === void 0 ? void 0 : _b.text) !== "," &&
            ((_c = pattern.nextSibling) === null || _c === void 0 ? void 0 : _c.text) === "," &&
            pattern.nextSibling.nextSibling) {
            endPosition = pattern.nextSibling.nextSibling.startPosition;
        }
        return vscode_languageserver_1.TextEdit.del(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(startPosition.row, startPosition.column), vscode_languageserver_1.Position.create(endPosition.row, endPosition.column)));
    }
    static removeFunction(nodeAtPosition) {
        var _a, _b, _c, _d;
        const valueDeclaration = treeUtils_1.TreeUtils.findParentOfType("value_declaration", nodeAtPosition);
        if (valueDeclaration) {
            let startPosition = valueDeclaration.startPosition;
            const endPosition = valueDeclaration.endPosition;
            if (((_a = valueDeclaration.previousSibling) === null || _a === void 0 ? void 0 : _a.type) === "type_annotation") {
                startPosition = valueDeclaration.previousSibling.startPosition;
                if (((_c = (_b = valueDeclaration.previousSibling) === null || _b === void 0 ? void 0 : _b.previousSibling) === null || _c === void 0 ? void 0 : _c.type) ===
                    "block_comment") {
                    startPosition =
                        valueDeclaration.previousSibling.previousSibling.startPosition;
                }
            }
            else if (((_d = valueDeclaration.previousSibling) === null || _d === void 0 ? void 0 : _d.type) === "block_comment") {
                startPosition = valueDeclaration.previousSibling.startPosition;
            }
            return vscode_languageserver_1.TextEdit.del(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(startPosition.row, startPosition.column), vscode_languageserver_1.Position.create(endPosition.row, endPosition.column)));
        }
    }
    static removeTypeAlias(node) {
        if (!node) {
            return undefined;
        }
        const typeAliasDeclarationNode = treeUtils_1.TreeUtils.findParentOfType("type_alias_declaration", node);
        if (!typeAliasDeclarationNode) {
            return undefined;
        }
        return vscode_languageserver_1.TextEdit.del(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(typeAliasDeclarationNode.startPosition.row, typeAliasDeclarationNode.startPosition.column), vscode_languageserver_1.Position.create(typeAliasDeclarationNode.endPosition.row, typeAliasDeclarationNode.endPosition.column)));
    }
    static removeTypeValue(nodeAtPosition) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const unionVariants = (_a = treeUtils_1.TreeUtils.findParentOfType("type_declaration", nodeAtPosition)) === null || _a === void 0 ? void 0 : _a.children.filter((child) => child.type == "union_variant");
        if ((unionVariants === null || unionVariants === void 0 ? void 0 : unionVariants.length) == 1) {
            return this.removeType(unionVariants[0].parent);
        }
        let startPosition = nodeAtPosition.startPosition;
        let endPosition = nodeAtPosition.endPosition;
        const unionVariant = unionVariants === null || unionVariants === void 0 ? void 0 : unionVariants.find((a) => a.text.startsWith(`${nodeAtPosition.text} `) ||
            a.text === nodeAtPosition.text);
        if (((_b = unionVariant === null || unionVariant === void 0 ? void 0 : unionVariant.previousSibling) === null || _b === void 0 ? void 0 : _b.type) == "eq") {
            startPosition = (_c = unionVariant.previousSibling) === null || _c === void 0 ? void 0 : _c.endPosition;
            if (((_d = unionVariant.nextSibling) === null || _d === void 0 ? void 0 : _d.type) == "|") {
                endPosition = (_e = unionVariant.nextSibling) === null || _e === void 0 ? void 0 : _e.endPosition;
            }
        }
        else if (((_f = unionVariant === null || unionVariant === void 0 ? void 0 : unionVariant.previousSibling) === null || _f === void 0 ? void 0 : _f.type) == "|" &&
            ((_g = unionVariant === null || unionVariant === void 0 ? void 0 : unionVariant.previousSibling) === null || _g === void 0 ? void 0 : _g.previousSibling)) {
            startPosition = (_h = unionVariant.previousSibling) === null || _h === void 0 ? void 0 : _h.previousSibling.endPosition;
        }
        return vscode_languageserver_1.TextEdit.del(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(startPosition.row, startPosition.column), vscode_languageserver_1.Position.create(endPosition.row, endPosition.column)));
    }
    static removeType(node) {
        if (!node) {
            return undefined;
        }
        const typeDeclarationNode = treeUtils_1.TreeUtils.findParentOfType("type_declaration", node);
        if (!typeDeclarationNode) {
            return undefined;
        }
        return vscode_languageserver_1.TextEdit.del(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(typeDeclarationNode.startPosition.row, typeDeclarationNode.startPosition.column), vscode_languageserver_1.Position.create(typeDeclarationNode.endPosition.row, typeDeclarationNode.endPosition.column)));
    }
    static addUnionVariant(typeDeclaration, name, params) {
        var _a, _b;
        const lastUnionVariant = typeDeclaration.lastNamedChild;
        if (lastUnionVariant) {
            // Get the '|' unnamed node
            const spaces = getSpaces((_b = (_a = lastUnionVariant.previousSibling) === null || _a === void 0 ? void 0 : _a.startPosition.column) !== null && _b !== void 0 ? _b : lastUnionVariant.startPosition.column);
            return vscode_languageserver_1.TextEdit.insert(vscode_languageserver_1.Position.create(lastUnionVariant.endPosition.row, lastUnionVariant.endPosition.column), `\n${spaces}| ${name}${params.length > 0 ? " " : ""}${params
                .map((param) => (param.includes(" ") ? `(${param})` : param))
                .join(" ")}`);
        }
    }
    static removeValueFromExposingList(exposedNodes, valueName, forceRemoveLastComma = false) {
        var _a, _b, _c, _d;
        const exposedNode = exposedNodes.find((node) => node.text === valueName || node.text === `${valueName}(..)`);
        if (exposedNode) {
            let startPosition = exposedNode.startPosition;
            let endPosition = exposedNode.endPosition;
            if (((_a = exposedNode.previousSibling) === null || _a === void 0 ? void 0 : _a.text) === "," &&
                (((_b = exposedNode.nextSibling) === null || _b === void 0 ? void 0 : _b.text) === ")" || forceRemoveLastComma)) {
                startPosition = exposedNode.previousSibling.startPosition;
            }
            if (((_c = exposedNode.nextSibling) === null || _c === void 0 ? void 0 : _c.text) === "," &&
                ((_d = exposedNode.nextSibling) === null || _d === void 0 ? void 0 : _d.nextSibling)) {
                endPosition = exposedNode.nextSibling.nextSibling.startPosition;
            }
            return vscode_languageserver_1.TextEdit.del(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(startPosition.row, startPosition.column), vscode_languageserver_1.Position.create(endPosition.row, endPosition.column)));
        }
    }
}
exports.RefactorEditUtils = RefactorEditUtils;
function getSpaces(n) {
    return Array(n + 1)
        .map(() => "")
        .join(" ");
}
exports.getSpaces = getSpaces;
//# sourceMappingURL=refactorEditUtils.js.map