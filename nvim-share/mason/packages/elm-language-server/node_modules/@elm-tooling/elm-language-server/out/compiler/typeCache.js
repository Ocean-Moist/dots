"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeCache = void 0;
const multiMap_1 = require("../common/util/multiMap");
const treeUtils_1 = require("../common/util/treeUtils");
const syntaxNodeMap_1 = require("./utils/syntaxNodeMap");
class TypeCache {
    constructor() {
        this.packageTypeAnnotation = new syntaxNodeMap_1.SyntaxNodeMap();
        this.packageTypeAndTypeAlias = new syntaxNodeMap_1.SyntaxNodeMap();
        this.packageValueDeclaration = new syntaxNodeMap_1.SyntaxNodeMap();
        this.packageUnionVariant = new syntaxNodeMap_1.SyntaxNodeMap();
        this.projectTypeAnnotation = new syntaxNodeMap_1.SyntaxNodeMap();
        this.projectTypeAndTypeAlias = new syntaxNodeMap_1.SyntaxNodeMap();
        this.projectValueDeclaration = new syntaxNodeMap_1.SyntaxNodeMap();
        this.projectUnionVariant = new syntaxNodeMap_1.SyntaxNodeMap();
        this.declarationAnnotations = new multiMap_1.MultiMap();
        this.typeUnionVariants = new multiMap_1.MultiMap();
    }
    getOrSet(key, node, setter) {
        switch (key) {
            case "PACKAGE_TYPE_ANNOTATION":
                return this.packageTypeAnnotation.getOrSet(node, setter);
            case "PACKAGE_TYPE_AND_TYPE_ALIAS":
                return this.packageTypeAndTypeAlias.getOrSet(node, setter);
            case "PACKAGE_VALUE_DECLARATION":
                return this.packageValueDeclaration.getOrSet(node, setter);
            case "PACKAGE_UNION_VARIANT":
                return this.packageUnionVariant.getOrSet(node, setter);
            case "PROJECT_TYPE_ANNOTATION":
                return this.projectTypeAnnotation.getOrSet(node, setter);
            case "PROJECT_TYPE_AND_TYPE_ALIAS":
                return this.projectTypeAndTypeAlias.getOrSet(node, setter);
            case "PROJECT_VALUE_DECLARATION":
                return this.projectValueDeclaration.getOrSet(node, setter);
            case "PROJECT_UNION_VARIANT":
                return this.projectUnionVariant.getOrSet(node, setter);
        }
    }
    invalidateProject() {
        this.projectTypeAnnotation.clear();
        this.projectTypeAndTypeAlias.clear();
        this.projectValueDeclaration.clear();
        this.projectUnionVariant.clear();
    }
    invalidateValueDeclaration(node) {
        var _a;
        this.projectValueDeclaration.delete(node);
        (_a = this.declarationAnnotations
            .getAll(node.id)) === null || _a === void 0 ? void 0 : _a.forEach((annotation) => this.projectTypeAnnotation.delete(annotation));
    }
    invalidateTypeAnnotation(node) {
        this.projectTypeAnnotation.delete(node);
    }
    invalidateTypeOrTypeAlias(node) {
        var _a;
        this.projectTypeAndTypeAlias.delete(node);
        (_a = this.typeUnionVariants
            .getAll(node.id)) === null || _a === void 0 ? void 0 : _a.forEach((variant) => this.projectUnionVariant.delete(variant));
    }
    /**
     * Track a type annotation
     *
     * We associate type annotations with its top level declaration
     * so we can clear its cache when we invalidate that declaration
     */
    trackTypeAnnotation(annotation) {
        var _a;
        const declaration = ((_a = annotation.parent) === null || _a === void 0 ? void 0 : _a.type) === "file"
            ? treeUtils_1.TreeUtils.getValueDeclaration(annotation)
            : treeUtils_1.TreeUtils.findParentOfType("value_declaration", annotation, 
            /* topLevel */ true);
        if (declaration) {
            this.declarationAnnotations.set(declaration.id, annotation);
        }
    }
    trackUnionVariant(unionVariant) {
        const typeDeclaration = treeUtils_1.TreeUtils.findParentOfType("type_declaration", unionVariant);
        if (typeDeclaration) {
            this.typeUnionVariants.set(typeDeclaration.id, unionVariant);
        }
    }
}
exports.TypeCache = TypeCache;
//# sourceMappingURL=typeCache.js.map