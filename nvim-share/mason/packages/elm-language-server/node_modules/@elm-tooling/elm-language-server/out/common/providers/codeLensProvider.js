"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeLensProvider = void 0;
const tsyringe_1 = require("tsyringe");
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const elmWorkspaceMatcher_1 = require("../util/elmWorkspaceMatcher");
const references_1 = require("../../compiler/references");
const treeUtils_1 = require("../util/treeUtils");
class CodeLensProvider {
    constructor() {
        this.handleCodeLensRequest = (param) => {
            this.connection.console.info(`A code lens was requested for ${param.textDocument.uri}`);
            const codeLens = [];
            const tree = param.sourceFile.tree;
            codeLens.push(...this.getExposingCodeLenses(tree, param.textDocument.uri));
            codeLens.push(...this.getReferencesCodeLenses(tree, param.textDocument.uri));
            return codeLens;
        };
        this.handleCodeLensResolveRequest = (codelens, program, sourceFile) => {
            var _a;
            const data = codelens.data;
            this.connection.console.info(`A code lens resolve was requested for ${data.uri}`);
            const checker = program.getTypeChecker();
            if (sourceFile) {
                const tree = sourceFile.tree;
                switch (data.codeLensType) {
                    case "exposed": {
                        const exposed = data.isFunctionOrPort
                            ? treeUtils_1.TreeUtils.isExposedFunctionOrPort(tree, data.nameNode)
                            : treeUtils_1.TreeUtils.isExposedTypeOrTypeAlias(tree, data.nameNode);
                        codelens.command = ((_a = this.settings.extendedCapabilities) === null || _a === void 0 ? void 0 : _a.exposeUnexposeSupport)
                            ? exposed
                                ? vscode_languageserver_1.Command.create("exposed", "elm.unexpose-" + program.getRootPath().toString(), {
                                    uri: data.uri,
                                    name: data.nameNode,
                                })
                                : vscode_languageserver_1.Command.create("local", "elm.expose-" + program.getRootPath().toString(), {
                                    uri: data.uri,
                                    name: data.nameNode,
                                })
                            : exposed
                                ? vscode_languageserver_1.Command.create("exposed", "")
                                : vscode_languageserver_1.Command.create("local", "");
                        break;
                    }
                    case "referenceCounter": {
                        const nodeAtPosition = treeUtils_1.TreeUtils.getNamedDescendantForPosition(tree.rootNode, codelens.range.start);
                        const definitionNode = checker.findDefinition(nodeAtPosition, sourceFile).symbol;
                        const references = references_1.References.find(definitionNode, program);
                        let refLocations = [];
                        if (references) {
                            refLocations = references.map((a) => vscode_languageserver_1.Location.create(a.uri, vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(a.node.startPosition.row, a.node.startPosition.column), vscode_languageserver_1.Position.create(a.node.endPosition.row, a.node.endPosition.column))));
                        }
                        codelens.command = vscode_languageserver_1.Command.create(references.length === 1
                            ? "1 reference"
                            : `${references.length} references`, "editor.action.showReferences", {
                            range: codelens.range,
                            references: refLocations,
                            uri: data.uri,
                        });
                        break;
                    }
                    default:
                        break;
                }
            }
            return codelens;
        };
        this.connection = tsyringe_1.container.resolve("Connection");
        this.settings = tsyringe_1.container.resolve("Settings");
        this.connection.onCodeLens(new elmWorkspaceMatcher_1.ElmWorkspaceMatcher((param) => vscode_uri_1.URI.parse(param.textDocument.uri)).handle(this.handleCodeLensRequest));
        this.connection.onCodeLensResolve((params) => new elmWorkspaceMatcher_1.ElmWorkspaceMatcher((param) => vscode_uri_1.URI.parse(param.data.uri)).handleResolve(this.handleCodeLensResolveRequest)(params));
    }
    createExposingCodeLens(node, nameNode, uri, isFunctionOrPort) {
        return {
            range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(node.startPosition.row, node.startPosition.column), vscode_languageserver_1.Position.create(node.endPosition.row, node.endPosition.column)),
            data: {
                codeLensType: "exposed",
                nameNode: nameNode.text,
                isFunctionOrPort,
                uri,
            },
        };
    }
    createReferenceCodeLens(placementNode, uri) {
        return {
            range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(placementNode.startPosition.row, placementNode.startPosition.column), vscode_languageserver_1.Position.create(placementNode.endPosition.row, placementNode.endPosition.column)),
            data: {
                codeLensType: "referenceCounter",
                uri,
            },
        };
    }
    getExposingCodeLenses(tree, uri) {
        const codeLens = [];
        tree.rootNode.children.forEach((node) => {
            if (node.type === "value_declaration") {
                const functionName = treeUtils_1.TreeUtils.getFunctionNameNodeFromDefinition(node);
                if (functionName) {
                    if (node.previousNamedSibling &&
                        node.previousNamedSibling.type === "type_annotation") {
                        codeLens.push(this.createExposingCodeLens(node.previousNamedSibling, functionName, uri, true));
                    }
                    else {
                        codeLens.push(this.createExposingCodeLens(node, functionName, uri, true));
                    }
                }
            }
            else if (node.type === "type_declaration" ||
                node.type === "type_alias_declaration") {
                const typeNode = treeUtils_1.TreeUtils.findFirstNamedChildOfType("upper_case_identifier", node);
                if (typeNode) {
                    codeLens.push(this.createExposingCodeLens(node, typeNode, uri, false));
                }
            }
            else if (node.type === "port_annotation") {
                const typeNode = treeUtils_1.TreeUtils.findFirstNamedChildOfType("lower_case_identifier", node);
                if (typeNode) {
                    codeLens.push(this.createExposingCodeLens(node, typeNode, uri, true));
                }
            }
        });
        return codeLens;
    }
    getReferencesCodeLenses(tree, uri) {
        const codeLens = [];
        tree.rootNode.children.forEach((node) => {
            if (node.type === "type_declaration" ||
                node.type === "type_alias_declaration") {
                const typeNode = node.childForFieldName("name");
                if (typeNode) {
                    codeLens.push(this.createReferenceCodeLens(typeNode, uri));
                }
            }
            if (node.type === "port_annotation") {
                const portNameNode = treeUtils_1.TreeUtils.findFirstNamedChildOfType("lower_case_identifier", node);
                if (portNameNode) {
                    codeLens.push(this.createReferenceCodeLens(portNameNode, uri));
                }
            }
        });
        treeUtils_1.TreeUtils.descendantsOfType(tree.rootNode, "value_declaration")
            .filter((valueDeclaration) => !valueDeclaration.childForFieldName("pattern"))
            .forEach((node) => {
            var _a;
            codeLens.push(this.createReferenceCodeLens(((_a = node.previousNamedSibling) === null || _a === void 0 ? void 0 : _a.type) === "type_annotation"
                ? node.previousNamedSibling
                : node, uri));
        });
        const moduleNameNode = treeUtils_1.TreeUtils.getModuleNameNode(tree);
        if (moduleNameNode && moduleNameNode.lastChild) {
            codeLens.push(this.createReferenceCodeLens(moduleNameNode, uri));
        }
        return codeLens;
    }
}
exports.CodeLensProvider = CodeLensProvider;
//# sourceMappingURL=codeLensProvider.js.map