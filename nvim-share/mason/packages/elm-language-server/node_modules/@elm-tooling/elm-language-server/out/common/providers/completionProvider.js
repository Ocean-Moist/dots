"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CompletionProvider = void 0;
const tsyringe_1 = require("tsyringe");
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const positionUtil_1 = require("../positionUtil");
const elmUtils_1 = require("../../compiler/utils/elmUtils");
const elmWorkspaceMatcher_1 = require("../util/elmWorkspaceMatcher");
const hintHelper_1 = require("../util/hintHelper");
const importUtils_1 = require("../util/importUtils");
const refactorEditUtils_1 = require("../util/refactorEditUtils");
const treeUtils_1 = require("../util/treeUtils");
const ranking_1 = __importDefault(require("./ranking"));
const _1 = require(".");
const escape_string_regexp_1 = __importDefault(require("escape-string-regexp"));
const utils_1 = require("../util/utils");
class CompletionProvider {
    constructor() {
        this.qidRegex = /[_\d\p{L}.]+/u;
        this.handleCompletionRequest = (params) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
            this.connection.console.info(`A completion was requested`);
            const completions = [];
            const checker = params.program.getTypeChecker();
            const sourceFile = params.sourceFile;
            if (sourceFile) {
                const tree = sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.tree;
                const nodeAtPosition = treeUtils_1.TreeUtils.getNamedDescendantForPosition(tree.rootNode, params.position);
                const nodeAtLineBefore = treeUtils_1.TreeUtils.getNamedDescendantForLineBeforePosition(tree.rootNode, params.position);
                const nodeAtLineAfter = treeUtils_1.TreeUtils.getNamedDescendantForLineAfterPosition(tree.rootNode, params.position);
                const targetLine = tree.rootNode.text.split("\n")[params.position.line];
                let currentCharacter = params.position.character;
                while (currentCharacter - 1 >= 0 &&
                    this.qidRegex.test(targetLine[currentCharacter - 1])) {
                    currentCharacter--;
                }
                let replaceRange = vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(params.position.line, currentCharacter), params.position);
                const previousWord = this.findPreviousWord(currentCharacter, targetLine);
                const isAtStartOfLine = replaceRange.start.character === 0;
                let targetWord = targetLine.substring(replaceRange.start.character, replaceRange.end.character);
                let contextNode = treeUtils_1.TreeUtils.findPreviousNode(tree.rootNode, params.position);
                // If we are in a partial identifier, skip that and adjust the contextNode to be the previous node
                if (contextNode &&
                    (0, positionUtil_1.comparePosition)(params.position, contextNode.endPosition) <= 0 &&
                    treeUtils_1.TreeUtils.isIdentifier(contextNode)) {
                    contextNode = treeUtils_1.TreeUtils.findPreviousNode(tree.rootNode, positionUtil_1.PositionUtil.FROM_TS_POSITION(contextNode.startPosition).toVSPosition());
                }
                const isAfterDot = (contextNode === null || contextNode === void 0 ? void 0 : contextNode.type) === "dot";
                if (treeUtils_1.TreeUtils.findParentOfType("block_comment", nodeAtPosition) ||
                    treeUtils_1.TreeUtils.findParentOfType("line_comment", nodeAtPosition)) {
                    // Don't complete in comments
                    return [];
                }
                else if (((_a = nodeAtPosition.parent) === null || _a === void 0 ? void 0 : _a.type) === "lower_pattern" ||
                    nodeAtPosition.type === "record_pattern") {
                    if (((_c = (_b = nodeAtPosition.parent) === null || _b === void 0 ? void 0 : _b.parent) === null || _c === void 0 ? void 0 : _c.type) === "record_pattern" ||
                        nodeAtPosition.type === "record_pattern") {
                        return this.getRecordCompletionsUsingInference(checker, (_d = treeUtils_1.TreeUtils.findParentOfType("record_pattern", nodeAtPosition)) !== null && _d !== void 0 ? _d : nodeAtPosition, replaceRange);
                    }
                    else {
                        // Don't complete on pattern names
                        return [];
                    }
                }
                else if (((_e = nodeAtPosition.parent) === null || _e === void 0 ? void 0 : _e.type) === "as_clause" &&
                    ((_f = nodeAtPosition.parent.parent) === null || _f === void 0 ? void 0 : _f.type) === "import_clause") {
                    // Don't complete on import alias
                    return [];
                }
                else if (isAtStartOfLine &&
                    nodeAtLineBefore.type === "lower_case_identifier" &&
                    nodeAtLineBefore.parent &&
                    nodeAtLineBefore.parent.type === "type_annotation") {
                    return [
                        this.createCompletion({
                            kind: vscode_languageserver_1.CompletionItemKind.Text,
                            label: nodeAtLineBefore.text,
                            range: replaceRange,
                            sortPrefix: "a",
                        }),
                    ];
                }
                else if (isAtStartOfLine &&
                    nodeAtLineAfter.type === "lower_case_identifier" &&
                    nodeAtLineAfter.parent &&
                    (nodeAtLineAfter.parent.type === "value_qid" ||
                        nodeAtLineAfter.parent.type === "function_declaration_left" ||
                        nodeAtLineAfter.parent.type === "lower_pattern")) {
                    return [
                        this.createCompletion({
                            kind: vscode_languageserver_1.CompletionItemKind.Text,
                            label: `${nodeAtLineAfter.text} : `,
                            range: replaceRange,
                            sortPrefix: "a",
                        }),
                    ];
                }
                else if (isAtStartOfLine) {
                    const topLevelFunctions = treeUtils_1.TreeUtils.findAllTopLevelFunctionDeclarations(tree);
                    const exposedValues = treeUtils_1.TreeUtils.descendantsOfType(tree.rootNode, "exposed_value");
                    const possibleMissingImplementations = treeUtils_1.TreeUtils.descendantsOfType(tree.rootNode, "function_call_expr")
                        .filter((a) => a.firstChild && !a.firstChild.text.includes("."))
                        .filter((a) => !exposedValues.some((b) => { var _a, _b; return ((_a = b.firstChild) === null || _a === void 0 ? void 0 : _a.text) === ((_b = a.firstChild) === null || _b === void 0 ? void 0 : _b.text); }))
                        .filter((a) => !(topLevelFunctions === null || topLevelFunctions === void 0 ? void 0 : topLevelFunctions.some((b) => { var _a, _b; return ((_a = b.firstChild) === null || _a === void 0 ? void 0 : _a.text) === ((_b = a.firstChild) === null || _b === void 0 ? void 0 : _b.text); })));
                    const snippetsFroMissingImplementations = possibleMissingImplementations.map((a) => this.createSnippet("func " + a.firstChild.text, [
                        a.firstChild.text + " : ${1:ArgumentType} -> ${2:ReturnType}",
                        a.firstChild.text + " ${3:arguments} =",
                        "    ${4}",
                    ], "Function with type annotation"));
                    return [
                        ...snippetsFroMissingImplementations,
                        ...possibleMissingImplementations.map((a) => this.createCompletion({
                            kind: vscode_languageserver_1.CompletionItemKind.Text,
                            label: a.firstChild.text,
                            range: replaceRange,
                            sortPrefix: "a",
                        })), // Add plain text recommendations
                        ...this.getKeywordsStartOfLine(),
                        ...this.createSnippetsStartOfLine(),
                    ];
                }
                else if (previousWord && previousWord === "module") {
                    return undefined;
                }
                else if (treeUtils_1.TreeUtils.findParentOfType("module_declaration", nodeAtPosition) &&
                    treeUtils_1.TreeUtils.findParentOfType("exposing_list", nodeAtPosition)) {
                    const exposingList = (_h = (_g = treeUtils_1.TreeUtils.findParentOfType("exposing_list", nodeAtPosition)) === null || _g === void 0 ? void 0 : _g.namedChildren.map((n) => n.text)) !== null && _h !== void 0 ? _h : [];
                    return this.getSameFileTopLevelCompletions(checker, sourceFile, replaceRange, true).filter((completion) => !exposingList.includes(completion.label));
                }
                else if (nodeAtPosition.type === "exposing_list" &&
                    ((_j = nodeAtPosition.parent) === null || _j === void 0 ? void 0 : _j.type) === "import_clause" &&
                    ((_k = nodeAtPosition.firstNamedChild) === null || _k === void 0 ? void 0 : _k.type) === "exposing") {
                    return this.getExposedFromModule(params.program, params.sourceFile, nodeAtPosition, replaceRange);
                }
                else if (((_m = (_l = nodeAtPosition.parent) === null || _l === void 0 ? void 0 : _l.parent) === null || _m === void 0 ? void 0 : _m.type) === "exposing_list") {
                    return this.getExposedFromModule(params.program, params.sourceFile, nodeAtPosition.parent.parent, replaceRange);
                }
                else if (((_p = (_o = nodeAtPosition.parent) === null || _o === void 0 ? void 0 : _o.parent) === null || _p === void 0 ? void 0 : _p.type) === "record_expr") {
                    return this.getRecordCompletions(nodeAtPosition, sourceFile, replaceRange, params.program);
                }
                let targetNode;
                if (contextNode) {
                    const parent = contextNode.parent;
                    if (isAfterDot) {
                        targetWord = targetLine.substring(replaceRange.start.character, contextNode.startPosition.column);
                        replaceRange = vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(params.position.line, contextNode.startPosition.column + 1), params.position);
                        if ((parent === null || parent === void 0 ? void 0 : parent.type) === "value_qid") {
                            // Qualified submodule and value access
                            targetNode = contextNode.previousNamedSibling;
                        }
                        else if ((parent === null || parent === void 0 ? void 0 : parent.type) === "field_access_expr") {
                            // Record field access
                            targetNode =
                                (_s = (_r = (_q = contextNode === null || contextNode === void 0 ? void 0 : contextNode.previousNamedSibling) === null || _q === void 0 ? void 0 : _q.lastNamedChild) === null || _r === void 0 ? void 0 : _r.lastNamedChild) !== null && _s !== void 0 ? _s : (_t = contextNode.previousNamedSibling) === null || _t === void 0 ? void 0 : _t.lastNamedChild;
                        }
                        else if ((parent === null || parent === void 0 ? void 0 : parent.type) === "upper_case_qid") {
                            // Imports
                            targetNode = contextNode.previousNamedSibling;
                        }
                        else if ((parent === null || parent === void 0 ? void 0 : parent.type) === "ERROR") {
                            targetNode = treeUtils_1.TreeUtils.findPreviousNode(tree.rootNode, positionUtil_1.PositionUtil.FROM_TS_POSITION(contextNode.startPosition).toVSPosition());
                        }
                    }
                    else {
                        if (contextNode.type === "import") {
                            return this.getImportableModules(params.program, params.sourceFile, replaceRange);
                        }
                    }
                }
                if (targetNode) {
                    const moduleCompletions = this.getSubmodulesOrValues(targetNode, sourceFile, params.program, replaceRange, targetWord);
                    if (moduleCompletions.length > 0) {
                        return moduleCompletions;
                    }
                    const recordCompletions = this.getRecordCompletions(targetNode, sourceFile, replaceRange, params.program);
                    if (recordCompletions.length > 0) {
                        return recordCompletions;
                    }
                    return this.getRecordCompletionsUsingInference(checker, targetNode, replaceRange);
                }
                completions.push(...this.getSameFileTopLevelCompletions(checker, sourceFile, replaceRange));
                completions.push(...this.findDefinitionsForScope(checker, nodeAtPosition, sourceFile, replaceRange));
                completions.push(...this.getCompletionsFromOtherFile(checker, sourceFile, replaceRange, targetWord));
                completions.push(...this.createSnippetsInline());
                completions.push(...this.getKeywordsInline());
                const possibleImportCompletions = this.getPossibleImports(params.program, replaceRange, tree, params.textDocument.uri, nodeAtPosition.text);
                completions.push(...possibleImportCompletions.list);
                return {
                    items: completions,
                    isIncomplete: possibleImportCompletions.isIncomplete,
                };
            }
        };
        this.connection = tsyringe_1.container.resolve("Connection");
        this.diagnostics = tsyringe_1.container.resolve(_1.DiagnosticsProvider);
        this.connection.onCompletion(this.diagnostics.interruptDiagnostics(() => new elmWorkspaceMatcher_1.ElmWorkspaceMatcher((params) => vscode_uri_1.URI.parse(params.textDocument.uri)).handle(this.handleCompletionRequest.bind(this))));
    }
    findPreviousWord(currentCharacter, targetLine) {
        currentCharacter--;
        const previousWordEnd = currentCharacter;
        while (currentCharacter - 1 >= 0 &&
            this.qidRegex.test(targetLine[currentCharacter - 1])) {
            currentCharacter--;
        }
        return targetLine.slice(currentCharacter, previousWordEnd);
    }
    getImportableModules(program, sourceFile, range, targetModule) {
        return program
            .getImportableModules(sourceFile)
            .filter(({ moduleName }) => (!targetModule || (moduleName === null || moduleName === void 0 ? void 0 : moduleName.startsWith(targetModule + "."))) &&
            moduleName !== sourceFile.moduleName &&
            moduleName !== targetModule)
            .map(({ moduleName, uri }) => {
            var _a, _b;
            const sourceFileToImport = program.getSourceFile(uri);
            const moduleNode = treeUtils_1.TreeUtils.findModuleDeclaration(sourceFileToImport.tree);
            const markdownDocumentation = hintHelper_1.HintHelper.createHint(moduleNode);
            return this.createModuleCompletion({
                label: (_b = (targetModule
                    ? (_a = moduleName === null || moduleName === void 0 ? void 0 : moduleName.slice(targetModule.length + 1)) !== null && _a !== void 0 ? _a : moduleName
                    : moduleName)) !== null && _b !== void 0 ? _b : "",
                sortPrefix: "b",
                range,
                markdownDocumentation,
            });
        });
    }
    getExposedFromModule(program, sourceFile, exposingListNode, range) {
        var _a, _b, _c, _d;
        // Skip as clause to always get Module Name
        if (((_a = exposingListNode.previousNamedSibling) === null || _a === void 0 ? void 0 : _a.type) === "as_clause" &&
            ((_b = exposingListNode.previousNamedSibling) === null || _b === void 0 ? void 0 : _b.previousNamedSibling)) {
            exposingListNode = exposingListNode.previousNamedSibling;
        }
        if (((_c = exposingListNode.previousNamedSibling) === null || _c === void 0 ? void 0 : _c.type) === "upper_case_qid") {
            const sortPrefix = "c";
            const moduleName = exposingListNode.previousNamedSibling.text;
            const exposedByModule = (_d = program.getSourceFileOfImportableModule(sourceFile, moduleName)) === null || _d === void 0 ? void 0 : _d.exposing;
            if (exposedByModule) {
                return Array.from(exposedByModule.values()).flatMap((a) => {
                    var _a;
                    const markdownDocumentation = hintHelper_1.HintHelper.createHint(a.node);
                    switch (a.type) {
                        case "TypeAlias":
                            return [
                                this.createTypeAliasCompletion({
                                    markdownDocumentation,
                                    label: a.name,
                                    range,
                                    sortPrefix,
                                }),
                            ];
                        case "Type":
                            return ((_a = a.constructors) === null || _a === void 0 ? void 0 : _a.length)
                                ? [
                                    this.createTypeCompletion({
                                        markdownDocumentation,
                                        label: `${a.name}(..)`,
                                        range,
                                        sortPrefix,
                                    }),
                                    this.createTypeCompletion({
                                        markdownDocumentation,
                                        label: a.name,
                                        range,
                                        sortPrefix,
                                    }),
                                ]
                                : [
                                    this.createTypeCompletion({
                                        markdownDocumentation,
                                        label: a.name,
                                        range,
                                        sortPrefix,
                                    }),
                                ];
                        default:
                            return [
                                this.createFunctionCompletion({
                                    markdownDocumentation,
                                    label: a.name,
                                    range,
                                    sortPrefix,
                                }),
                            ];
                    }
                });
            }
        }
    }
    getCompletionsFromOtherFile(checker, sourceFile, range, inputText) {
        const completions = [];
        const imports = checker.getAllImports(sourceFile);
        imports.forEach((element) => {
            var _a;
            const markdownDocumentation = hintHelper_1.HintHelper.createHint(element.node);
            const label = element.name;
            const labelDescription = element.fromModule.name;
            let filterText = label;
            const dotIndex = label.lastIndexOf(".");
            const valuePart = label.slice(dotIndex + 1);
            const importNode = (_a = checker
                .getAllImports(sourceFile)
                .getModule(element.fromModule.name)) === null || _a === void 0 ? void 0 : _a.importNode;
            // Check if a value is already imported for this module using the exposing list
            // In this case, we want to prefex the unqualified value since they are using the import exposing list
            const valuesAlreadyExposed = importNode &&
                !!treeUtils_1.TreeUtils.findFirstNamedChildOfType("exposing_list", importNode);
            // Try to determine if just the value is being typed
            if (!valuesAlreadyExposed &&
                element.fromModule.name !== "Basics" &&
                valuePart.toLowerCase().startsWith(inputText.toLowerCase())) {
                filterText = valuePart;
            }
            let sortPrefix = "d";
            // If the value is imported directly already, then the qualified import should be sorted after
            if (dotIndex >= 0) {
                const valueImport = imports.getVar(valuePart, element.fromModule.name);
                if (valueImport.length > 0) {
                    sortPrefix = "e";
                }
            }
            if (element.fromModule.maintainerAndPackageName) {
                const matchedRanking = ranking_1.default[element.fromModule.maintainerAndPackageName];
                if (matchedRanking) {
                    sortPrefix = `e${matchedRanking}`;
                }
            }
            switch (element.type) {
                case "Function":
                    completions.push(this.createFunctionCompletion({
                        markdownDocumentation,
                        label,
                        range,
                        sortPrefix,
                        filterText,
                        labelDescription,
                    }));
                    break;
                case "UnionConstructor":
                    completions.push(this.createUnionConstructorCompletion({
                        label,
                        range,
                        sortPrefix,
                        filterText,
                        labelDescription,
                    }));
                    break;
                case "Operator":
                    completions.push(this.createOperatorCompletion({
                        markdownDocumentation,
                        label,
                        range,
                        sortPrefix,
                        labelDescription,
                    }));
                    break;
                case "Type":
                    completions.push(this.createTypeCompletion({
                        markdownDocumentation,
                        label,
                        range,
                        sortPrefix,
                        filterText,
                        labelDescription,
                    }));
                    break;
                case "TypeAlias":
                    completions.push(this.createTypeAliasCompletion({
                        markdownDocumentation,
                        label,
                        range,
                        sortPrefix,
                        filterText,
                        labelDescription,
                    }));
                    break;
            }
        });
        completions.push(...(0, elmUtils_1.getEmptyTypes)().map((a) => this.createCompletion({
            markdownDocumentation: a.markdown,
            kind: a.symbolKind,
            label: a.name,
            range,
            sortPrefix: "d0000",
        })));
        return completions;
    }
    getSameFileTopLevelCompletions(checker, sourceFile, range, moduleDefinition = false) {
        const completions = [];
        const sortPrefix = "b";
        checker
            .getSymbolsInScope(sourceFile.tree.rootNode, sourceFile)
            .forEach((symbol) => {
            var _a;
            if (symbol.type === "Function" || symbol.type === "Port") {
                const markdownDocumentation = hintHelper_1.HintHelper.createHint(symbol.node);
                completions.push(this.createFunctionCompletion({
                    markdownDocumentation,
                    label: symbol.name,
                    range,
                    sortPrefix,
                }));
            }
            if (symbol.type === "Type") {
                const markdownDocumentation = hintHelper_1.HintHelper.createHint(symbol.node);
                completions.push(this.createTypeCompletion({
                    markdownDocumentation,
                    label: symbol.name,
                    range,
                    sortPrefix,
                }));
                if (moduleDefinition) {
                    completions.push(this.createTypeCompletion({
                        markdownDocumentation,
                        label: `${symbol.name}(..)`,
                        range,
                        sortPrefix,
                    }));
                }
                (_a = symbol.constructors) === null || _a === void 0 ? void 0 : _a.forEach((unionVariant) => {
                    completions.push(this.createUnionConstructorCompletion({
                        label: unionVariant.name,
                        range,
                        sortPrefix,
                    }));
                });
            }
            if (symbol.type === "TypeAlias") {
                const markdownDocumentation = hintHelper_1.HintHelper.createHint(symbol.node);
                completions.push(this.createTypeAliasCompletion({
                    markdownDocumentation,
                    label: symbol.name,
                    range,
                    sortPrefix,
                }));
            }
        });
        return completions;
    }
    getRecordCompletions(node, sourceFile, range, program) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const checker = program.getTypeChecker();
        const result = [];
        let typeDeclarationNode = treeUtils_1.TreeUtils.getTypeAliasOfRecord(node, sourceFile, program);
        if (!typeDeclarationNode && ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent)) {
            typeDeclarationNode = treeUtils_1.TreeUtils.getTypeAliasOfRecordField(node.parent.parent, sourceFile, program);
        }
        let recordType;
        if (!typeDeclarationNode && ((_b = node.parent) === null || _b === void 0 ? void 0 : _b.parent)) {
            recordType = treeUtils_1.TreeUtils.getRecordTypeOfFunctionRecordParameter(node.parent.parent, program);
        }
        if (!typeDeclarationNode &&
            !recordType &&
            ((_d = (_c = node.parent) === null || _c === void 0 ? void 0 : _c.parent) === null || _d === void 0 ? void 0 : _d.type) === "record_expr") {
            const recordExpr = node.parent.parent;
            const foundType = checker.findType(recordExpr);
            if (foundType.nodeType === "Record") {
                recordType = foundType;
            }
        }
        if (recordType) {
            if (((_e = recordType.baseType) === null || _e === void 0 ? void 0 : _e.nodeType) === "Record") {
                for (const field in recordType.baseType.fields) {
                    const hint = hintHelper_1.HintHelper.createHintForTypeAliasReference(checker.typeToString(recordType.fields[field]), field, (_g = (_f = recordType.alias) === null || _f === void 0 ? void 0 : _f.name) !== null && _g !== void 0 ? _g : "");
                    result.push(this.createFieldOrParameterCompletion(hint, field, range));
                }
            }
            for (const field in recordType.fields) {
                const hint = hintHelper_1.HintHelper.createHintForTypeAliasReference(checker.typeToString(recordType.fields[field]), field, (_j = (_h = recordType.alias) === null || _h === void 0 ? void 0 : _h.name) !== null && _j !== void 0 ? _j : "");
                result.push(this.createFieldOrParameterCompletion(hint, field, range));
            }
        }
        if (typeDeclarationNode) {
            const fields = treeUtils_1.TreeUtils.getAllFieldsFromTypeAlias(typeDeclarationNode);
            const typeName = (_l = (_k = typeDeclarationNode.childForFieldName("name")) === null || _k === void 0 ? void 0 : _k.text) !== null && _l !== void 0 ? _l : "";
            fields === null || fields === void 0 ? void 0 : fields.forEach((element) => {
                const hint = hintHelper_1.HintHelper.createHintForTypeAliasReference(element.type, element.field, typeName);
                result.push(this.createFieldOrParameterCompletion(hint, element.field, range));
            });
        }
        return result;
    }
    getRecordCompletionsUsingInference(checker, targetNode, replaceRange) {
        var _a, _b;
        const result = [];
        const foundType = checker.findType(targetNode);
        if (foundType.nodeType === "Record") {
            for (const field in foundType.fields) {
                const hint = hintHelper_1.HintHelper.createHintForTypeAliasReference(checker.typeToString(foundType.fields[field]), field, (_b = (_a = foundType.alias) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "");
                result.push(this.createFieldOrParameterCompletion(hint, field, replaceRange));
            }
        }
        return result;
    }
    createFunctionCompletion(options) {
        options.kind = vscode_languageserver_1.CompletionItemKind.Function;
        return this.createCompletion(options);
    }
    createVariableCompletion(options) {
        options.kind = vscode_languageserver_1.CompletionItemKind.Variable;
        return this.createCompletion(options);
    }
    createFieldOrParameterCompletion(markdownDocumentation, label, range) {
        return this.createPreselectedCompletion(markdownDocumentation, vscode_languageserver_1.CompletionItemKind.Field, label, range);
    }
    createTypeCompletion(options) {
        options.kind = vscode_languageserver_1.CompletionItemKind.Enum;
        return this.createCompletion(options);
    }
    createTypeAliasCompletion(options) {
        options.kind = vscode_languageserver_1.CompletionItemKind.Struct;
        return this.createCompletion(options);
    }
    createOperatorCompletion(options) {
        options.kind = vscode_languageserver_1.CompletionItemKind.Operator;
        return this.createCompletion(options);
    }
    createUnionConstructorCompletion(options) {
        options.kind = vscode_languageserver_1.CompletionItemKind.EnumMember;
        return this.createCompletion(options);
    }
    createModuleCompletion(options) {
        options.kind = vscode_languageserver_1.CompletionItemKind.Module;
        return this.createCompletion(options);
    }
    createCompletion(options) {
        var _a;
        return {
            documentation: options.markdownDocumentation
                ? {
                    kind: vscode_languageserver_1.MarkupKind.Markdown,
                    value: (_a = options.markdownDocumentation) !== null && _a !== void 0 ? _a : "",
                }
                : undefined,
            kind: options.kind,
            label: options.label,
            sortText: `${options.sortPrefix}_${options.label}`,
            textEdit: vscode_languageserver_1.TextEdit.replace(options.range, options.label),
            detail: options.detail,
            additionalTextEdits: options.additionalTextEdits,
            filterText: options.filterText,
            labelDetails: {
                description: options.labelDescription,
                detail: options.labelDetail,
            },
        };
    }
    createPreselectedCompletion(markdownDocumentation, kind, label, range) {
        return {
            documentation: markdownDocumentation
                ? {
                    kind: vscode_languageserver_1.MarkupKind.Markdown,
                    value: markdownDocumentation !== null && markdownDocumentation !== void 0 ? markdownDocumentation : "",
                }
                : undefined,
            kind,
            label,
            preselect: true,
            textEdit: vscode_languageserver_1.TextEdit.replace(range, label),
        };
    }
    findDefinitionsForScope(checker, node, sourceFile, range) {
        const result = [];
        checker.getSymbolsInScope(node, sourceFile).forEach((symbol, i) => {
            var _a, _b;
            // getSymbolsInScope returns ths symbols in order of inner scope to outer scope,
            // so we add the index to the sort order so the variables that are "closer" to the position are sorted first
            const sortPrefix = `a${i}`;
            if (symbol.type === "Function") {
                // Only get let functions here
                if ((_b = (_a = symbol.node.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.parent) {
                    const markdownDocumentation = hintHelper_1.HintHelper.createHintFromDefinitionInLet(symbol.node);
                    result.push(this.createFunctionCompletion({
                        markdownDocumentation,
                        label: symbol.name,
                        range,
                        sortPrefix: sortPrefix,
                    }));
                }
            }
            if (symbol.type === "CasePattern") {
                const markdownDocumentation = hintHelper_1.HintHelper.createHintFromDefinitionInCaseBranch();
                result.push(this.createVariableCompletion({
                    markdownDocumentation,
                    label: symbol.name,
                    range,
                    sortPrefix,
                }));
            }
            if (symbol.type === "FunctionParameter" ||
                symbol.type === "AnonymousFunctionParameter") {
                const markdownDocumentation = hintHelper_1.HintHelper.createHintFromFunctionParameter(symbol.node);
                result.push(this.createVariableCompletion({
                    markdownDocumentation,
                    label: symbol.name,
                    range,
                    sortPrefix,
                }));
                const parameterType = checker.findType(symbol.node);
                if (parameterType.nodeType === "Record") {
                    for (const field in parameterType.fields) {
                        const hint = hintHelper_1.HintHelper.createHintForTypeAliasReference(checker.typeToString(parameterType.fields[field]), field, symbol.name);
                        result.push(this.createFieldOrParameterCompletion(hint, `${symbol.name}.${field}`, range));
                    }
                }
            }
        });
        return result;
    }
    getPossibleImportsFiltered(program, uri, filterText) {
        const possibleImportsCache = program.getPossibleImportsCache();
        const sourceFile = program.getSourceFile(uri);
        if (sourceFile) {
            const checker = program.getTypeChecker();
            const allImportedValues = checker.getAllImports(sourceFile);
            const cached = possibleImportsCache.get(uri);
            const possibleImports = cached !== null && cached !== void 0 ? cached : importUtils_1.ImportUtils.getPossibleImports(program, sourceFile);
            if (!cached) {
                possibleImportsCache.set(uri, possibleImports);
            }
            // Filter out already imported values
            // Then sort by startsWith filter text, then matches filter text
            return possibleImports
                .filter((possibleImport) => ![
                ...allImportedValues.getVar(possibleImport.value),
                ...allImportedValues.getType(possibleImport.value),
                ...allImportedValues.getConstructor(possibleImport.value),
            ].some((imp) => imp.fromModule.name === possibleImport.module))
                .sort((a, b) => {
                const aValue = a.value.toLowerCase();
                const bValue = b.value.toLowerCase();
                filterText = filterText.toLowerCase();
                const aStartsWith = aValue.startsWith(filterText);
                const bStartsWith = bValue.startsWith(filterText);
                if (aStartsWith && !bStartsWith) {
                    return -1;
                }
                else if (!aStartsWith && bStartsWith) {
                    return 1;
                }
                else {
                    const regex = new RegExp((0, escape_string_regexp_1.default)(filterText));
                    const aMatches = regex.exec(aValue);
                    const bMatches = regex.exec(bValue);
                    if (aMatches && !bMatches) {
                        return -1;
                    }
                    else if (!aMatches && bMatches) {
                        return 1;
                    }
                    else {
                        const aModuleImported = !!checker
                            .getAllImports(sourceFile)
                            .getModule(a.module);
                        const bModuleImported = !!checker
                            .getAllImports(sourceFile)
                            .getModule(b.module);
                        if (aModuleImported && !bModuleImported) {
                            return -1;
                        }
                        else if (!aModuleImported && bModuleImported) {
                            return 1;
                        }
                        else {
                            return 0;
                        }
                    }
                }
            });
        }
        return [];
    }
    getPossibleImports(program, range, tree, uri, filterText) {
        const result = [];
        const possibleImports = this.getPossibleImportsFiltered(program, uri, filterText);
        const isIncomplete = possibleImports.length > 50;
        possibleImports.splice(0, 49).forEach((possibleImport, i) => {
            var _a;
            const markdownDocumentation = hintHelper_1.HintHelper.createHint(possibleImport.node);
            const detail = `Auto import from module '${possibleImport.module}'`;
            const importTextEdit = refactorEditUtils_1.RefactorEditUtils.addImport(tree, possibleImport.module, (_a = possibleImport.valueToImport) !== null && _a !== void 0 ? _a : possibleImport.value);
            const sortText = i < 10 ? `0${i}` : i;
            const completionOptions = {
                markdownDocumentation,
                label: possibleImport.value,
                range,
                sortPrefix: `f${sortText}`,
                detail,
                additionalTextEdits: importTextEdit ? [importTextEdit] : undefined,
                labelDescription: possibleImport.module,
            };
            if (possibleImport.type === "Function" ||
                possibleImport.type === "Port") {
                result.push(this.createFunctionCompletion(completionOptions));
            }
            else if (possibleImport.type === "TypeAlias") {
                result.push(this.createTypeAliasCompletion(completionOptions));
            }
            else if (possibleImport.type === "Type") {
                result.push(this.createTypeCompletion(completionOptions));
            }
            else if (possibleImport.type === "UnionConstructor") {
                result.push(this.createUnionConstructorCompletion({
                    label: possibleImport.value,
                    range,
                    sortPrefix: `f${i}`,
                    detail,
                    additionalTextEdits: importTextEdit ? [importTextEdit] : undefined,
                    labelDescription: possibleImport.module,
                }));
            }
        });
        return { list: result, isIncomplete };
    }
    getSubmodulesOrValues(node, sourceFile, program, range, targetModule) {
        var _a, _b, _c, _d;
        const result = [];
        const checker = program.getTypeChecker();
        const tree = sourceFile.tree;
        // Handle possible submodules
        result.push(...this.getImportableModules(program, sourceFile, range, targetModule));
        // If we are in an import completion, don't return any values
        if (treeUtils_1.TreeUtils.isImport(node)) {
            return result;
        }
        const matchedSourceFiles = [];
        const imports = (_d = (_c = (_b = (_a = sourceFile.symbolLinks) === null || _a === void 0 ? void 0 : _a.get(sourceFile.tree.rootNode)) === null || _b === void 0 ? void 0 : _b.getAll(targetModule)) === null || _c === void 0 ? void 0 : _c.filter((symbol) => symbol.type === "Import")) !== null && _d !== void 0 ? _d : [];
        if (imports.length > 0) {
            matchedSourceFiles.push(...imports
                .map((imp) => {
                var _a, _b;
                const moduleName = (_b = (_a = imp.node.childForFieldName("moduleName")) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : "";
                const importSourceFile = program.getSourceFileOfImportableModule(sourceFile, moduleName);
                if (importSourceFile) {
                    return [importSourceFile, true];
                }
                return undefined;
            })
                .filter(utils_1.Utils.notUndefined));
        }
        else if (!checker.getAllImports(sourceFile).getModule(targetModule)) {
            // Try to find a module that may not be imported
            // If it incudes a dot then we don't look for an alias, only an exact module
            if (targetModule.includes(".")) {
                const moduleSourceFile = program.getSourceFileOfImportableModule(sourceFile, targetModule);
                if (moduleSourceFile) {
                    matchedSourceFiles.push([moduleSourceFile, false]);
                }
            }
            else {
                program
                    .getImportableModules(sourceFile)
                    .filter(({ moduleName }) => moduleName === targetModule ||
                    moduleName.endsWith(`.${targetModule}`))
                    .forEach((module) => {
                    const moduleSourceFile = program.getSourceFile(module.uri);
                    if (moduleSourceFile) {
                        matchedSourceFiles.push([moduleSourceFile, false]);
                    }
                });
            }
        }
        // Get exposed values
        matchedSourceFiles
            .flatMap(([importSourceFile, alreadyImported]) => importUtils_1.ImportUtils.getPossibleImportsOfTree(importSourceFile).map((value) => [value, alreadyImported]))
            .forEach(([value, alreadyImported]) => {
            const type = checker.findType(value.node);
            const typeString = checker.typeToString(type, sourceFile);
            const markdownDocumentation = hintHelper_1.HintHelper.createHint(value.node, typeString);
            let additionalTextEdits;
            let detail;
            // Add the import text edit if not imported
            if (!alreadyImported) {
                const importEdit = refactorEditUtils_1.RefactorEditUtils.addImport(tree, value.module, undefined, targetModule);
                if (importEdit) {
                    const aliasDetail = targetModule !== value.module ? ` as '${targetModule}'` : "";
                    additionalTextEdits = [importEdit];
                    detail = `Auto import module '${value.module}'${aliasDetail}`;
                }
            }
            const completionOptions = {
                label: value.value,
                sortPrefix: "a",
                range,
                markdownDocumentation,
                additionalTextEdits,
                detail,
            };
            switch (value.type) {
                case "Function":
                case "Port":
                    result.push(this.createFunctionCompletion(completionOptions));
                    break;
                case "Type":
                    result.push(this.createTypeCompletion(completionOptions));
                    break;
                case "TypeAlias":
                    result.push(this.createTypeAliasCompletion(completionOptions));
                    break;
                case "UnionConstructor":
                    result.push(this.createUnionConstructorCompletion(completionOptions));
                    break;
            }
        });
        return result;
    }
    createSnippet(label, snippetText, markdownDocumentation, kind) {
        return {
            documentation: markdownDocumentation
                ? {
                    kind: vscode_languageserver_1.MarkupKind.Markdown,
                    value: markdownDocumentation !== null && markdownDocumentation !== void 0 ? markdownDocumentation : "",
                }
                : undefined,
            insertText: Array.isArray(snippetText)
                ? snippetText.join("\n")
                : snippetText,
            insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
            kind: kind !== null && kind !== void 0 ? kind : vscode_languageserver_1.CompletionItemKind.Snippet,
            label,
            sortText: `s_${label}`,
        };
    }
    createSnippetsInline() {
        return [
            this.createSnippet("of", ["of", "    $0"], "The of keyword", vscode_languageserver_1.CompletionItemKind.Keyword),
            this.createSnippet("case of", ["case ${1:expression} of$0"], "Case of expression ready to extend (you need to save first)"),
            this.createSnippet("if", [" if ${1:expression} then", "    ${2}", " else", "    ${3}"], "If-Else statement"),
            this.createSnippet("record update", ["{ ${1:recordName} | ${2:key} = ${3} }"], "Update record"),
            this.createSnippet("anonymous", ["\\ ${1:argument} -> ${1:argument}"], "Anonymous function"),
            this.createSnippet("let in", ["let", "    ${1}", "in", "${0}"], "Let expression"),
        ];
    }
    createSnippetsStartOfLine() {
        return [
            this.createSnippet("module", "module ${1:Name} exposing (${2:..})", "Module definition"),
            this.createSnippet("import", "import ${1:Name} exposing (${2:..})", "Unqualified import"),
            this.createSnippet("comment", ["{-", "${0}", "-}"], "Multi-line comment"),
            this.createSnippet("record", [
                "${1:recordName} =",
                "    { ${2:key1} = ${3:value1}",
                "    , ${4:key2} = ${5:value2}",
                "    }",
            ], "Record"),
            this.createSnippet("type alias", [
                "type alias ${1:RecordName} =",
                "    { ${2:key1} : ${3:ValueType1}",
                "    , ${4:key2} : ${5:ValueType2}",
                "    }",
            ], "Type alias"),
            this.createSnippet("type", ["type ${1:Typename}", "    = ${2:Value1}", "    | ${3:Value2}"], "Custom type"),
            this.createSnippet("msg", ["type Msg", "    = ${1:Message}", "    | ${2:Message}"], "Default message custom type"),
            this.createSnippet("func", [
                "${1:functionName} : ${2:ArgumentType} -> ${3:ReturnType}",
                "${1:functionName} ${4:arguments} =",
                "    ${5}",
            ], "Function with type annotation"),
            this.createSnippet("update", [
                "update : Msg -> Model -> ${1|Model, ( Model\\, Cmd Msg )|}",
                "update msg model =",
                "    case msg of",
                "        ${2:option1} ->",
                "            ${1|Model, ( Model\\, Cmd Msg )|}",
                "",
                "        ${3:option2} ->",
                "            ${1|Model, ( Model\\, Cmd Msg )|}",
            ], "Default update function"),
            this.createSnippet("view", ["view : Model -> Html Msg", "view model =", "    ${0}"], "Default view function"),
            this.createSnippet("port in", ["port ${1:portName} : (${2:Typename} -> msg) -> Sub msg"], "Incoming port"),
            this.createSnippet("port out", ["port ${1:portName} : ${2:Typename} -> Cmd msg"], "Outgoing port"),
            this.createSnippet("main sandbox", [
                "main : Program () Model Msg",
                "main =",
                "    Browser.sandbox",
                "        { init = init",
                "        , view = view",
                "        , update = update",
                "        }",
            ], "Main Browser Sandbox"),
            this.createSnippet("main element", [
                "main : Program () Model Msg",
                "main =",
                "    Browser.element",
                "        { init = init",
                "        , view = view",
                "        , update = update",
                "        , subscriptions = subscriptions",
                "        }",
            ], "Main Browser Element"),
            this.createSnippet("main document", [
                "main : Program () Model Msg",
                "main =",
                "    Browser.document",
                "        { init = init",
                "        , view = view",
                "        , update = update",
                "        , subscriptions = subscriptions",
                "        }",
            ], "Main Browser Document"),
            this.createSnippet("main application", [
                "main : Program () Model Msg",
                "main =",
                "    Browser.application",
                "        { init = init",
                "        , view = view",
                "        , update = update",
                "        , subscriptions = subscriptions",
                "        , onUrlChange = onUrlChange",
                "        , onUrlRequest = onUrlRequest",
                "        }",
            ], "Main Browser Application"),
            this.createSnippet("subscriptions", [
                "subscriptions : Model -> Sub Msg",
                "subscriptions model =",
                "    Sub.none",
            ], "Subscriptions"),
            this.createSnippet("default model", [
                "type alias Model =",
                "    { statusText : String",
                "    }",
                "",
                "",
                "model : Model",
                "model =",
                '    { statusText = "Ready"',
                "    }",
            ], "A default model with type declaration"),
            this.createSnippet("Browser.sandbox", [
                "module Main exposing (main)",
                "",
                "import Browser",
                "import Html exposing (..)",
                "",
                "",
                "main : Program () Model Msg",
                "main =",
                "    Browser.sandbox",
                "        { init = init",
                "        , view = view",
                "        , update = update",
                "        }",
                "",
                "",
                "type alias Model =",
                "    { ${1:property} : ${2:Int}",
                "    , ${3:property2} : ${4:String}",
                "    }",
                "",
                "",
                "init : Model",
                "init =",
                '    Model ${5:0} ${6:"modelInitialValue2"}',
                "",
                "",
                "type Msg",
                "    = ${7:Msg1}",
                "    | ${8:Msg2}",
                "",
                "",
                "update : Msg -> Model -> Model",
                "update msg model =",
                "    case msg of",
                "        ${9:Msg1} ->",
                "            model",
                "",
                "        ${10:Msg2} ->",
                "            model",
                "",
                "",
                "view : Model -> Html Msg",
                "view model =",
                "    div []",
                '        [ text "New Sandbox" ]',
                "${0}",
            ], "Browser Sandbox"),
            this.createSnippet("Browser.element", [
                "module Main exposing (main)",
                "",
                "import Browser",
                "import Html exposing (..)",
                "",
                "",
                "main : Program flags Model Msg",
                "main =",
                "    Browser.element",
                "        { init = init",
                "        , view = view",
                "        , update = update",
                "        , subscriptions = subscriptions",
                "        }",
                "",
                "",
                "type alias Model =",
                "    { ${1:property} : ${2:Int}",
                "    , ${3:property2} : ${4:String}",
                "    }",
                "",
                "",
                "init : flags -> ( Model, Cmd Msg )",
                "init flags =",
                '    ( Model ${5:0} ${6:"modelInitialValue2"}, Cmd.none )',
                "",
                "",
                "type Msg",
                "    = ${7:Msg1}",
                "    | ${8:Msg2}",
                "",
                "",
                "update : Msg -> Model -> ( Model, Cmd Msg )",
                "update msg model =",
                "    case msg of",
                "        ${9:Msg1} ->",
                "            ( model, Cmd.none )",
                "",
                "        ${10:Msg2} ->",
                "            ( model, Cmd.none )",
                "",
                "",
                "subscriptions : Model -> Sub Msg",
                "subscriptions model =",
                "    Sub.none",
                "",
                "",
                "view : Model -> Html Msg",
                "view model =",
                "    div []",
                '        [ text "New Element" ]',
                "${0}",
            ], "Browser Element"),
            this.createSnippet("Browser.document", [
                "module Main exposing (main)",
                "",
                "import Browser",
                "import Html exposing (..)",
                "",
                "",
                "main : Program flags Model Msg",
                "main =",
                "    Browser.document",
                "        { init = init",
                "        , view = view",
                "        , update = update",
                "        , subscriptions = subscriptions",
                "        }",
                "",
                "",
                "type alias Model =",
                "    { ${1:property} : ${2:Int}",
                "    , ${3:property2} : ${4:String}",
                "    }",
                "",
                "",
                "init : flags -> ( Model, Cmd Msg )",
                "init flags =",
                '    ( Model ${5:0} ${6:"modelInitialValue"}, Cmd.none )',
                "",
                "",
                "type Msg",
                "    = ${7:Msg1}",
                "    | ${8:Msg2}",
                "",
                "",
                "update : Msg -> Model -> ( Model, Cmd Msg )",
                "update msg model =",
                "    case msg of",
                "        ${9:Msg1} ->",
                "            ( model, Cmd.none )",
                "",
                "        ${10:Msg2} ->",
                "            ( model, Cmd.none )",
                "",
                "",
                "subscriptions : Model -> Sub Msg",
                "subscriptions model =",
                "    Sub.none",
                "",
                "",
                "view : Model -> Browser.Document Msg",
                "view model =",
                '    { title = "Document Title"',
                "    , body =",
                "        [ div []",
                '            [ text "New Document" ]',
                "      ]",
                "    }",
                "${0}",
            ], "Browser Document"),
            this.createSnippet("Browser.application", [
                "module Main exposing (main)",
                "",
                "import Browser",
                "import Browser.Navigation as Nav",
                "import Html exposing (..)",
                "import Url",
                "",
                "",
                "main : Program flags Model Msg",
                "main =",
                "    Browser.application",
                "        { init = init",
                "        , view = view",
                "        , update = update",
                "        , subscriptions = subscriptions",
                "        , onUrlRequest = UrlRequested",
                "        , onUrlChange = UrlChanged",
                "        }",
                "",
                "",
                "type alias Model =",
                "    { key : Nav.Key",
                "    , url : Url.Url",
                "    , ${1:property} : ${2:String}",
                "    }",
                "",
                "",
                "init : flags -> Url.Url -> Nav.Key -> ( Model, Cmd Msg )",
                "init flags url key =",
                '    ( Model key url ${3:"modelInitialValue"}, Cmd.none )',
                "",
                "",
                "type Msg",
                "    = ${4:Msg1}",
                "    | ${5:Msg2}",
                "    | UrlRequested Browser.UrlRequest",
                "    | UrlChanged Url.Url",
                "",
                "",
                "update : Msg -> Model -> ( Model, Cmd Msg )",
                "update msg model =",
                "    case msg of",
                "        ${6:Msg1} ->",
                "            ( model, Cmd.none )",
                "",
                "        ${7:Msg2} ->",
                "            ( model, Cmd.none )",
                "",
                "        UrlRequested urlRequest ->",
                "            case urlRequest of",
                "                Browser.Internal url ->",
                "                    ( model, Nav.pushUrl model.key (Url.toString url) )",
                "",
                "                Browser.External href ->",
                "                    ( model, Nav.load href )",
                "",
                "        UrlChanged url ->",
                "            ( { model | url = url }",
                "            , Cmd.none",
                "            )",
                "",
                "",
                "subscriptions : Model -> Sub Msg",
                "subscriptions model =",
                "    Sub.none",
                "",
                "",
                "view : Model -> Browser.Document Msg",
                "view model =",
                '    { title = "Application Title"',
                "    , body =",
                "        [ div []",
                '            [ text "New Application" ]',
                "        ]",
                "    }",
                "${0}",
            ], "Browser Application"),
            this.createSnippet("describe", ['describe "${1:name}"', "    [ ${0}", "    ]"], "Describe block in Elm-test"),
            this.createSnippet("test", ['test "${1:name}" <|', "    \\_ ->", "        ${0}"], "Test block in Elm-test"),
            this.createSnippet("todo", "-- TODO: ${0}", "TODO comment"),
        ];
    }
    createKeywordCompletion(label) {
        return {
            label,
            kind: vscode_languageserver_1.CompletionItemKind.Keyword,
            sortText: `a_${label}`,
        };
    }
    getKeywordsInline() {
        return [
            this.createKeywordCompletion("if"),
            this.createKeywordCompletion("then"),
            this.createKeywordCompletion("else"),
            this.createKeywordCompletion("let"),
            this.createKeywordCompletion("in"),
            this.createKeywordCompletion("case"),
            this.createKeywordCompletion("alias"),
            this.createKeywordCompletion("exposing"),
        ];
    }
    getKeywordsStartOfLine() {
        return [
            this.createKeywordCompletion("type"),
            this.createKeywordCompletion("import"),
            this.createKeywordCompletion("module"),
            this.createKeywordCompletion("port"),
        ];
    }
}
exports.CompletionProvider = CompletionProvider;
//# sourceMappingURL=completionProvider.js.map