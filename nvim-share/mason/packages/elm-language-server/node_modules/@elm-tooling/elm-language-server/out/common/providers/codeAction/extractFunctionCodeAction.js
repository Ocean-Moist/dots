"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_1 = require("vscode-languageserver");
const refactorEditUtils_1 = require("../../util/refactorEditUtils");
const treeUtils_1 = require("../../util/treeUtils");
const typeInference_1 = require("../../../compiler/typeInference");
const codeActionProvider_1 = require("../codeActionProvider");
const refactorName = "extract_function";
codeActionProvider_1.CodeActionProvider.registerRefactorAction(refactorName, {
    getAvailableActions: (params) => {
        const result = [];
        const node = treeUtils_1.TreeUtils.getNamedDescendantForRange(params.sourceFile, params.range);
        if (node.type.includes("expr") &&
            node.type !== "type_expression" &&
            node.startPosition.column === params.range.start.character &&
            node.startPosition.row === params.range.start.line &&
            node.endPosition.column === params.range.end.character &&
            node.endPosition.row === params.range.end.line) {
            if (treeUtils_1.TreeUtils.findParentOfType("let_in_expr", node)) {
                result.push({
                    title: "Extract function to enclosing let",
                    kind: vscode_languageserver_1.CodeActionKind.RefactorExtract,
                    data: {
                        actionName: "extract_let",
                        refactorName,
                        uri: params.sourceFile.uri,
                        range: params.range,
                    },
                });
            }
            result.push({
                title: "Extract function to top level",
                kind: vscode_languageserver_1.CodeActionKind.RefactorExtract,
                data: {
                    actionName: "extract_top_level",
                    refactorName,
                    uri: params.sourceFile.uri,
                    range: params.range,
                },
            });
        }
        return result;
    },
    getEditsForAction: (params, actionName) => {
        var _a, _b, _c;
        const edits = [];
        let node = treeUtils_1.TreeUtils.getNamedDescendantForRange(params.sourceFile, params.range);
        let hadParenthesis = false;
        if (node.type === "parenthesized_expr") {
            node = (_a = node.childForFieldName("expression")) !== null && _a !== void 0 ? _a : node;
            hadParenthesis = true;
        }
        // List, record, and tuple expr should all be treated like parenthesis groups
        if (node.type === "list_expr" ||
            node.type === "record_expr" ||
            node.type === "tuple_expr") {
            hadParenthesis = true;
        }
        const checker = params.program.getTypeChecker();
        const rootNode = params.sourceFile.tree.rootNode;
        let insertPosition = {
            line: rootNode.endPosition.row,
            character: 0,
        };
        let targetScope;
        let addTypeAnnotation = true;
        switch (actionName) {
            case "extract_let":
                {
                    const letInExpr = treeUtils_1.TreeUtils.findParentOfType("let_in_expr", node);
                    if (letInExpr) {
                        const valueDeclarations = (_b = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("value_declaration", letInExpr)) !== null && _b !== void 0 ? _b : [];
                        insertPosition = {
                            line: valueDeclarations[valueDeclarations.length - 1].endPosition
                                .row + 1,
                            character: letInExpr.startPosition.column + 4,
                        };
                        targetScope = letInExpr;
                        addTypeAnnotation = false;
                    }
                }
                break;
            case "extract_top_level":
                {
                    insertPosition = {
                        line: (_c = refactorEditUtils_1.RefactorEditUtils.findLineNumberAfterCurrentFunction(node)) !== null && _c !== void 0 ? _c : rootNode.endPosition.row,
                        character: 0,
                    };
                    targetScope = rootNode;
                }
                break;
        }
        const args = [];
        const nodeParent = node.parent;
        const imports = checker.getAllImports(params.sourceFile);
        // Get the list of references that won't be visible
        node
            .descendantsOfType(["value_expr", "record_base_identifier"])
            .forEach((val) => {
            var _a, _b, _c, _d, _e;
            if (args.find((arg) => arg.text === val.text)) {
                return;
            }
            // Qualified reference will be visible
            if (val.text.includes(".")) {
                return;
            }
            // Types are always visible
            if (((_a = val.firstNamedChild) === null || _a === void 0 ? void 0 : _a.type) === "upper_case_qid") {
                return;
            }
            // If we find it in the scope we are extracting, it should not be a arg
            let scope = val;
            while (scope && scope.id !== (nodeParent === null || nodeParent === void 0 ? void 0 : nodeParent.id)) {
                if ((_c = (_b = params.sourceFile.symbolLinks) === null || _b === void 0 ? void 0 : _b.get(scope)) === null || _c === void 0 ? void 0 : _c.get(val.text)) {
                    return;
                }
                scope = scope.parent;
            }
            // If we find it in the target scope, it should not be an arg
            scope = targetScope;
            while (scope) {
                if ((_e = (_d = params.sourceFile.symbolLinks) === null || _d === void 0 ? void 0 : _d.get(scope)) === null || _e === void 0 ? void 0 : _e.get(val.text)) {
                    return;
                }
                scope = scope.parent;
            }
            // If we find it in imports, it should not be an arg
            if (imports.getVar(val.text).length > 0) {
                return;
            }
            args.push(val);
        });
        let typeAnnotation;
        if (addTypeAnnotation) {
            let type = checker.findType(node);
            if (args.length > 0) {
                type = (0, typeInference_1.TFunction)(args.map(checker.findType), type);
            }
            typeAnnotation = checker.typeToString(type, params.sourceFile);
        }
        edits.push(refactorEditUtils_1.RefactorEditUtils.createFunction(insertPosition.line, "newFunction", typeAnnotation, args.map((arg) => arg.text), node.text, node.startPosition.column, insertPosition.character));
        let textToInsert = args.length > 0
            ? `newFunction ${args.map((arg) => arg.text).join(" ")}`
            : `newFunction`;
        const needsParenthesis = hadParenthesis && args.length > 0;
        if (needsParenthesis) {
            textToInsert = `(${textToInsert})`;
        }
        edits.push(vscode_languageserver_1.TextEdit.replace(params.range, textToInsert));
        // Check if we are adding the function before the current range and adjust the rename position
        const linesAdded = edits[0].range.start.line < params.range.start.line
            ? edits[0].newText.split("\n").length - 1
            : 0;
        return {
            edits,
            renamePosition: {
                line: params.range.start.line + linesAdded,
                character: needsParenthesis
                    ? params.range.start.character + 1
                    : params.range.start.character,
            },
        };
    },
});
//# sourceMappingURL=extractFunctionCodeAction.js.map