"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Imports = exports.resetImportsTime = exports.importsTime = void 0;
const treeUtils_1 = require("../common/util/treeUtils");
const tsyringe_1 = require("tsyringe");
const multiMap_1 = require("../common/util/multiMap");
const perf_hooks_1 = require("perf_hooks");
const elmUtils_1 = require("./utils/elmUtils");
const diagnostics_1 = require("./diagnostics");
exports.importsTime = 0;
function resetImportsTime() {
    exports.importsTime = 0;
}
exports.resetImportsTime = resetImportsTime;
function importModuleEqual(a, b) {
    return (a.fromModule.name === b.fromModule.name &&
        a.fromModule.maintainerAndPackageName ===
            b.fromModule.maintainerAndPackageName);
}
/**
 * Imports class that extends a map to handle multiple named imports
 */
class Imports {
    constructor() {
        this.vars = new multiMap_1.MultiMap();
        this.types = new multiMap_1.MultiMap();
        this.constructors = new multiMap_1.MultiMap();
        this.modules = new Map();
        this.diagnostics = [];
    }
    getFromMap(map, name, module) {
        var _a;
        const all = (_a = map.getAll(name)) !== null && _a !== void 0 ? _a : [];
        return module ? all.filter((imp) => imp.fromModule.name === module) : all;
    }
    getVar(name, module) {
        return this.getFromMap(this.vars, name, module);
    }
    getType(name, module) {
        return this.getFromMap(this.types, name, module);
    }
    getConstructor(name, module) {
        return this.getFromMap(this.constructors, name, module);
    }
    getModule(name) {
        return this.modules.get(name);
    }
    getModules() {
        return [...this.modules.values()];
    }
    forEach(callbackfn) {
        this.vars.forEach(callbackfn);
        this.types.forEach(callbackfn);
        this.constructors.forEach((ctor) => {
            // These are already in 'types'
            if (ctor.type !== "TypeAlias") {
                callbackfn(ctor);
            }
        });
    }
    getDiagnostics() {
        return this.diagnostics;
    }
    static getImports(sourceFile, program) {
        var _a;
        const start = perf_hooks_1.performance.now();
        const result = new Imports();
        const importNodes = [
            ...((0, elmUtils_1.isCoreProject)(sourceFile.project) ? [] : Imports.getVirtualImports()),
            ...((_a = treeUtils_1.TreeUtils.findAllImportClauseNodes(sourceFile.tree)) !== null && _a !== void 0 ? _a : []),
        ];
        importNodes.forEach((importNode) => {
            var _a, _b;
            const moduleName = (_a = importNode.childForFieldName("moduleName")) === null || _a === void 0 ? void 0 : _a.text;
            if (moduleName) {
                const uri = (_b = sourceFile.resolvedModules) === null || _b === void 0 ? void 0 : _b.get(moduleName);
                if (!uri) {
                    return;
                }
                const foundModule = program.getSourceFile(uri);
                if (foundModule) {
                    const fromModule = {
                        name: moduleName,
                        uri,
                        maintainerAndPackageName: foundModule.maintainerAndPackageName,
                    };
                    const foundModuleNode = treeUtils_1.TreeUtils.findModuleDeclaration(foundModule.tree);
                    if (foundModuleNode) {
                        result.modules.set(moduleName, {
                            name: moduleName,
                            node: foundModuleNode,
                            type: "Module",
                            fromModule,
                            importNode,
                        });
                        const exposedFromRemoteModule = foundModule.exposing;
                        if (exposedFromRemoteModule) {
                            const importedAs = Imports.findImportAsClause(importNode);
                            const importPrefix = importedAs ? importedAs : fromModule.name;
                            // Add qualified imports
                            // The compiler keeps these separate from normal ones,
                            // but I'm not sure that is needed
                            exposedFromRemoteModule.forEach((symbol, name) => {
                                var _a;
                                const qualifiedName = `${importPrefix}.${name}`;
                                switch (symbol.type) {
                                    case "Function":
                                    case "Port":
                                        result.vars.set(qualifiedName, Object.assign(Object.assign({}, symbol), { name: qualifiedName, fromModule }), importModuleEqual);
                                        break;
                                    case "Type":
                                    case "TypeAlias":
                                        result.types.set(qualifiedName, Object.assign(Object.assign({}, symbol), { name: qualifiedName, fromModule }), importModuleEqual);
                                        (_a = symbol.constructors) === null || _a === void 0 ? void 0 : _a.forEach((ctor) => {
                                            const qualifiedName = `${importPrefix}.${ctor.name}`;
                                            result.constructors.set(qualifiedName, Object.assign(Object.assign({}, ctor), { name: qualifiedName, fromModule }), importModuleEqual);
                                        });
                                }
                            });
                            const exposingList = importNode.childForFieldName("exposing");
                            if (exposingList) {
                                const doubleDot = exposingList.childForFieldName("doubleDot");
                                if (doubleDot) {
                                    exposedFromRemoteModule.forEach((exposed) => {
                                        var _a;
                                        switch (exposed.type) {
                                            case "Type":
                                            case "TypeAlias":
                                                result.types.set(exposed.name, Object.assign(Object.assign({}, exposed), { fromModule }), importModuleEqual);
                                                (_a = exposed.constructors) === null || _a === void 0 ? void 0 : _a.forEach((ctor) => {
                                                    result.constructors.set(ctor.name, Object.assign(Object.assign({}, ctor), { fromModule }), importModuleEqual);
                                                });
                                                break;
                                            case "Function":
                                            case "Port":
                                            case "Operator":
                                                result.vars.set(exposed.name, Object.assign(Object.assign({}, exposed), { fromModule }), importModuleEqual);
                                        }
                                    });
                                }
                                else {
                                    const exposedOperators = treeUtils_1.TreeUtils.descendantsOfType(exposingList, "operator_identifier");
                                    exposedOperators.forEach((exposedOperator) => {
                                        const symbol = exposedFromRemoteModule.get(exposedOperator.text);
                                        if (symbol) {
                                            result.vars.set(symbol.name, Object.assign(Object.assign({}, symbol), { fromModule }), importModuleEqual);
                                        }
                                        else {
                                            result.diagnostics.push((0, diagnostics_1.error)(exposedOperator, diagnostics_1.Diagnostics.ImportExposingNotFound, fromModule.name, exposedOperator.text));
                                        }
                                    });
                                    const exposedValues = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("exposed_value", exposingList);
                                    exposedValues === null || exposedValues === void 0 ? void 0 : exposedValues.forEach((exposedValue) => {
                                        const symbol = exposedFromRemoteModule.get(exposedValue.text);
                                        if (symbol) {
                                            result.vars.set(symbol.name, Object.assign(Object.assign({}, symbol), { fromModule }), importModuleEqual);
                                        }
                                        else {
                                            result.diagnostics.push((0, diagnostics_1.error)(exposedValue, diagnostics_1.Diagnostics.ImportExposingNotFound, fromModule.name, exposedValue.text));
                                        }
                                    });
                                    const exposedTypes = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("exposed_type", exposingList);
                                    exposedTypes === null || exposedTypes === void 0 ? void 0 : exposedTypes.forEach((exposedType) => {
                                        var _a, _b, _c;
                                        const typeName = (_a = treeUtils_1.TreeUtils.findFirstNamedChildOfType("upper_case_identifier", exposedType)) === null || _a === void 0 ? void 0 : _a.text;
                                        const exposedUnionConstructors = !!treeUtils_1.TreeUtils.findFirstNamedChildOfType("exposed_union_constructors", exposedType);
                                        if (typeName) {
                                            const symbol = exposedFromRemoteModule.get(typeName);
                                            if (exposedUnionConstructors) {
                                                if (symbol) {
                                                    if (symbol.type === "Type") {
                                                        result.types.replace(symbol.name, Object.assign(Object.assign({}, symbol), { fromModule }));
                                                        (_b = symbol.constructors) === null || _b === void 0 ? void 0 : _b.forEach((ctor) => {
                                                            result.constructors.set(ctor.name, Object.assign(Object.assign({}, ctor), { fromModule }), importModuleEqual);
                                                        });
                                                    }
                                                    else if (symbol.type === "TypeAlias") {
                                                        result.diagnostics.push((0, diagnostics_1.error)(exposedType, diagnostics_1.Diagnostics.ImportOpenAlias, typeName));
                                                    }
                                                }
                                                else {
                                                    result.diagnostics.push((0, diagnostics_1.error)(exposedType, diagnostics_1.Diagnostics.ImportExposingNotFound, fromModule.name, typeName));
                                                }
                                            }
                                            else {
                                                if (symbol) {
                                                    if (symbol.type === "Type" ||
                                                        symbol.type === "TypeAlias") {
                                                        result.types.replace(symbol.name, Object.assign(Object.assign({}, symbol), { fromModule }));
                                                    }
                                                    if (symbol.type === "TypeAlias") {
                                                        (_c = symbol.constructors) === null || _c === void 0 ? void 0 : _c.forEach((ctor) => {
                                                            result.constructors.set(ctor.name, Object.assign(Object.assign({}, ctor), { fromModule }), importModuleEqual);
                                                        });
                                                    }
                                                }
                                                else {
                                                    // The compiler does special checking for an ImportCtorByName error here
                                                    result.diagnostics.push((0, diagnostics_1.error)(exposedType, diagnostics_1.Diagnostics.ImportExposingNotFound, fromModule.name, typeName));
                                                }
                                            }
                                        }
                                    });
                                }
                            }
                        }
                    }
                }
            }
        });
        exports.importsTime += perf_hooks_1.performance.now() - start;
        return result;
    }
    static getVirtualImports() {
        if (this.cachedVirtualImports) {
            return this.cachedVirtualImports;
        }
        const virtualImports = `
  import Basics exposing (..)
  import List exposing (List, (::))
  import Maybe exposing (Maybe(..))
  import Result exposing (Result(..))
  import String exposing (String)
  import Char exposing (Char)
  import Tuple

  import Debug

  import Platform exposing ( Program )
  import Platform.Cmd as Cmd exposing ( Cmd )
  import Platform.Sub as Sub exposing ( Sub )
      `;
        const parser = tsyringe_1.container.resolve("Parser");
        const importTree = parser.parse(virtualImports);
        return (this.cachedVirtualImports = importTree.rootNode.children);
    }
    static findImportAsClause(importNode) {
        const asClause = treeUtils_1.TreeUtils.findFirstNamedChildOfType("as_clause", importNode);
        if (asClause) {
            const newName = treeUtils_1.TreeUtils.findFirstNamedChildOfType("upper_case_identifier", asClause);
            if (newName) {
                return newName.text;
            }
        }
    }
}
exports.Imports = Imports;
//# sourceMappingURL=imports.js.map