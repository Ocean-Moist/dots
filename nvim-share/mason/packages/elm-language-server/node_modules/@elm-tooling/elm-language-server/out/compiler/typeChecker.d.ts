import { SyntaxNode } from "web-tree-sitter";
import { IProgram } from "./program";
import { Type } from "./typeInference";
import { ISourceFile } from "./forest";
import { Imports } from "./imports";
import { ISymbol } from "./binder";
import type { ICancellationToken } from "../common/cancellation";
import { Diagnostic } from "./diagnostics";
export declare let bindTime: number;
export declare function resetBindTime(): void;
export interface DefinitionResult {
    symbol?: ISymbol;
    diagnostics: Diagnostic[];
}
export interface TypeChecker {
    findType: (node: SyntaxNode) => Type;
    findDefinition: (node: SyntaxNode, sourceFile: ISourceFile) => DefinitionResult;
    findDefinitionShallow: (node: SyntaxNode, sourceFile: ISourceFile) => DefinitionResult;
    getAllImports: (sourceFile: ISourceFile) => Imports;
    getImportingModules: (sourceFile: ISourceFile, directImportOnly?: boolean) => ISourceFile[];
    getQualifierForName: (sourceFile: ISourceFile, module: string, name: string) => string;
    typeToString: (t: Type, sourceFile?: ISourceFile) => string;
    getDiagnostics: (sourceFile: ISourceFile, cancellationToken?: ICancellationToken) => Diagnostic[];
    getDiagnosticsAsync: (sourceFile: ISourceFile, token?: ICancellationToken, cancelCallback?: () => boolean) => Promise<Diagnostic[]>;
    getSuggestionDiagnostics: (sourceFile: ISourceFile, cancellationToken?: ICancellationToken) => Diagnostic[];
    findImportModuleNameNodes: (moduleNameOrAlias: string, sourceFile: ISourceFile) => SyntaxNode[];
    getSymbolsInScope(node: SyntaxNode, sourceFile: ISourceFile): ISymbol[];
}
export declare function createTypeChecker(program: IProgram): TypeChecker;
