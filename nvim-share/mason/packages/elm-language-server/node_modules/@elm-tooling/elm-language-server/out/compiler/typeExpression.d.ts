import { InferenceResult } from "./typeInference";
import { Expression, ETypeDeclaration, ETypeAnnotation, EUnionVariant, ETypeAliasDeclaration, EPortAnnotation } from "./utils/expressionTree";
import { IProgram } from "./program";
export declare class PerformanceTimer {
    total: number;
    track<T>(func: () => T, track?: boolean): T;
    reset(): void;
}
export declare class TypeExpression {
    private root;
    private program;
    private rigidVars;
    private activeAliases;
    private varsByExpression;
    private expressionTypes;
    private diagnostics;
    constructor(root: Expression, program: IProgram, rigidVars: boolean, activeAliases?: Set<ETypeAliasDeclaration>);
    static typeDeclarationInference(e: ETypeDeclaration, program: IProgram): InferenceResult;
    static typeAliasDeclarationInference(e: ETypeAliasDeclaration, program: IProgram, activeAliases?: Set<ETypeAliasDeclaration>): InferenceResult;
    static typeAnnotationInference(e: ETypeAnnotation, program: IProgram, rigid?: boolean): InferenceResult | undefined;
    static unionVariantInference(e: EUnionVariant, program: IProgram): InferenceResult;
    static portAnnotationInference(e: EPortAnnotation, program: IProgram): InferenceResult;
    private inferTypeDeclaration;
    private inferTypeExpression;
    private inferUnionConstructor;
    private inferPortAnnotation;
    private inferTypeAliasDeclaration;
    private typeExpressionType;
    private toResult;
    private typeSignatureSegmentType;
    private typeVariableType;
    private recordTypeDeclarationType;
    private typeRefType;
    private typeDeclarationType;
    private getTypeVar;
}
