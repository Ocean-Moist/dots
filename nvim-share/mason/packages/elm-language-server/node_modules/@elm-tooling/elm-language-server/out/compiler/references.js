"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.References = void 0;
const treeUtils_1 = require("../common/util/treeUtils");
const utils_1 = require("../common/util/utils");
class References {
    static find(definitionNode, program) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
        const references = [];
        const checker = program.getTypeChecker();
        if (definitionNode) {
            const definitionSourceFile = program.getSourceFile(definitionNode.node.tree.uri);
            if (definitionSourceFile) {
                const imports = {};
                program.getSourceFiles().forEach((sourceFile) => {
                    if (sourceFile.writeable) {
                        imports[sourceFile.uri] = checker.getAllImports(sourceFile);
                    }
                });
                const moduleNameNode = treeUtils_1.TreeUtils.getModuleNameNode(definitionSourceFile.tree);
                switch (definitionNode.type) {
                    case "Function":
                        {
                            if (definitionNode.node.parent) {
                                const annotationNameNode = (_a = treeUtils_1.TreeUtils.getTypeAnnotation(definitionNode.node.parent)) === null || _a === void 0 ? void 0 : _a.childForFieldName("name");
                                if (annotationNameNode && definitionSourceFile.writeable) {
                                    references.push({
                                        node: annotationNameNode,
                                        uri: definitionNode.node.tree.uri,
                                    });
                                }
                            }
                            const functionNameNode = (_b = treeUtils_1.TreeUtils.getFunctionNameNodeFromDefinition(definitionNode.node)) !== null && _b !== void 0 ? _b : (definitionNode.node.type === "lower_pattern"
                                ? definitionNode.node
                                : undefined);
                            if (functionNameNode) {
                                const functionName = functionNameNode.text;
                                if (definitionSourceFile.writeable) {
                                    references.push({
                                        node: functionNameNode,
                                        uri: definitionNode.node.tree.uri,
                                    });
                                }
                                const letParent = treeUtils_1.TreeUtils.findParentOfType("let_in_expr", definitionNode.node);
                                const localFunctions = letParent
                                    ? this.findFunctionCalls(letParent, functionName)
                                    : this.findFunctionCalls(definitionSourceFile.tree.rootNode, functionName);
                                if (localFunctions && definitionSourceFile.writeable) {
                                    references.push(...localFunctions.map((node) => {
                                        return { node, uri: definitionNode.node.tree.uri };
                                    }));
                                }
                                const isExposedFunction = treeUtils_1.TreeUtils.isExposedFunctionOrPort(definitionSourceFile.tree, functionName);
                                if (isExposedFunction && !letParent) {
                                    const moduleDeclarationNode = treeUtils_1.TreeUtils.findModuleDeclaration(definitionSourceFile.tree);
                                    if (moduleDeclarationNode) {
                                        const exposedNode = treeUtils_1.TreeUtils.findExposedFunctionNode(moduleDeclarationNode, functionName);
                                        if (exposedNode && definitionSourceFile.writeable) {
                                            references.push({
                                                node: exposedNode,
                                                uri: definitionNode.node.tree.uri,
                                            });
                                        }
                                    }
                                    if (isExposedFunction && moduleNameNode) {
                                        const moduleName = moduleNameNode.text;
                                        for (const uri in imports) {
                                            if (uri === definitionNode.node.tree.uri) {
                                                continue;
                                            }
                                            const otherSourceFile = program.getSourceFile(uri);
                                            if (!otherSourceFile) {
                                                continue;
                                            }
                                            const importedModuleAlias = (_c = treeUtils_1.TreeUtils.findImportAliasOfModule(moduleName, otherSourceFile.tree)) !== null && _c !== void 0 ? _c : moduleName;
                                            const allImports = imports[uri];
                                            // Find the function in the other module's imports
                                            const found = [
                                                ...allImports.getVar(functionName, moduleName),
                                                ...allImports.getVar(`${importedModuleAlias}.${functionName}`, moduleName),
                                            ];
                                            if (found.length > 0 && otherSourceFile.writeable) {
                                                const importClause = (_e = (_d = otherSourceFile.symbolLinks) === null || _d === void 0 ? void 0 : _d.get(otherSourceFile.tree.rootNode)) === null || _e === void 0 ? void 0 : _e.get(importedModuleAlias);
                                                // Add node from exposing list
                                                if ((importClause === null || importClause === void 0 ? void 0 : importClause.type) === "Import") {
                                                    const exposedNode = treeUtils_1.TreeUtils.findExposedFunctionNode(importClause.node, functionName);
                                                    if (exposedNode) {
                                                        references.push({
                                                            node: exposedNode,
                                                            uri,
                                                        });
                                                    }
                                                }
                                                // Find all function calls in the other tree
                                                const functions = found.flatMap((imp) => {
                                                    var _a;
                                                    return (_a = this.findFunctionCalls(otherSourceFile.tree.rootNode, imp.name)) !== null && _a !== void 0 ? _a : [];
                                                });
                                                if (functions.length > 0) {
                                                    references.push(...functions.map((node) => {
                                                        return { node, uri };
                                                    }));
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        break;
                    case "Port":
                        {
                            const portNameNode = treeUtils_1.TreeUtils.getTypeOrTypeAliasOrPortNameNodeFromDefinition(definitionNode.node);
                            if (portNameNode) {
                                const portName = portNameNode.text;
                                if (definitionSourceFile.writeable) {
                                    references.push({
                                        node: portNameNode,
                                        uri: definitionNode.node.tree.uri,
                                    });
                                }
                                const localCallsToPort = this.findFunctionCalls(definitionSourceFile.tree.rootNode, portName);
                                if (localCallsToPort && definitionSourceFile.writeable) {
                                    references.push(...localCallsToPort.map((node) => {
                                        return { node, uri: definitionNode.node.tree.uri };
                                    }));
                                }
                                const isExposedPort = treeUtils_1.TreeUtils.isExposedFunctionOrPort(definitionSourceFile.tree, portName);
                                if (isExposedPort) {
                                    const moduleDeclarationNode = treeUtils_1.TreeUtils.findModuleDeclaration(definitionSourceFile.tree);
                                    if (moduleDeclarationNode) {
                                        const exposedNode = treeUtils_1.TreeUtils.findExposedFunctionNode(moduleDeclarationNode, portName);
                                        if (exposedNode && definitionSourceFile.writeable) {
                                            references.push({
                                                node: exposedNode,
                                                uri: definitionNode.node.tree.uri,
                                            });
                                        }
                                    }
                                    if (isExposedPort && moduleNameNode) {
                                        const moduleName = moduleNameNode.text;
                                        for (const uri in imports) {
                                            if (uri === definitionNode.node.tree.uri) {
                                                continue;
                                            }
                                            const otherSourceFile = program.getSourceFile(uri);
                                            if (!otherSourceFile) {
                                                continue;
                                            }
                                            const importedModuleAlias = (_f = treeUtils_1.TreeUtils.findImportAliasOfModule(moduleName, otherSourceFile.tree)) !== null && _f !== void 0 ? _f : moduleName;
                                            const allImports = imports[uri];
                                            // Find the function in the other module's imports
                                            const found = [
                                                ...allImports.getVar(portName, moduleName),
                                                ...allImports.getVar(`${importedModuleAlias}.${portName}`, moduleName),
                                            ];
                                            if (found.length > 0 && otherSourceFile.writeable) {
                                                const importClause = (_h = (_g = otherSourceFile.symbolLinks) === null || _g === void 0 ? void 0 : _g.get(otherSourceFile.tree.rootNode)) === null || _h === void 0 ? void 0 : _h.get(importedModuleAlias);
                                                // Add node from exposing list
                                                if ((importClause === null || importClause === void 0 ? void 0 : importClause.type) === "Import") {
                                                    const exposedNode = treeUtils_1.TreeUtils.findExposedFunctionNode(importClause.node, portName);
                                                    if (exposedNode) {
                                                        references.push({
                                                            node: exposedNode,
                                                            uri,
                                                        });
                                                    }
                                                }
                                                // Find all function calls in the other tree
                                                const functions = found.flatMap((imp) => {
                                                    var _a;
                                                    return (_a = this.findFunctionCalls(otherSourceFile.tree.rootNode, imp.name)) !== null && _a !== void 0 ? _a : [];
                                                });
                                                if (functions.length > 0) {
                                                    references.push(...functions.map((node) => {
                                                        return { node, uri };
                                                    }));
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        break;
                    case "Type":
                    case "TypeAlias":
                        {
                            const typeOrTypeAliasNameNode = treeUtils_1.TreeUtils.getTypeOrTypeAliasOrPortNameNodeFromDefinition(definitionNode.node);
                            if (typeOrTypeAliasNameNode) {
                                const typeOrTypeAliasName = typeOrTypeAliasNameNode.text;
                                if (definitionSourceFile.writeable) {
                                    references.push({
                                        node: typeOrTypeAliasNameNode,
                                        uri: definitionNode.node.tree.uri,
                                    });
                                }
                                const localFunctions = treeUtils_1.TreeUtils.findTypeOrTypeAliasCalls(definitionSourceFile.tree, typeOrTypeAliasName, definitionNode.type);
                                if (definitionSourceFile.writeable) {
                                    references.push(...localFunctions.map((node) => {
                                        return { node, uri: definitionNode.node.tree.uri };
                                    }));
                                }
                                const isExposed = treeUtils_1.TreeUtils.isExposedTypeOrTypeAlias(definitionSourceFile.tree, typeOrTypeAliasName);
                                if (isExposed) {
                                    const moduleDeclarationNode = treeUtils_1.TreeUtils.findModuleDeclaration(definitionSourceFile.tree);
                                    if (moduleDeclarationNode) {
                                        const exposedNode = treeUtils_1.TreeUtils.findExposedTypeOrTypeAliasNode(moduleDeclarationNode, typeOrTypeAliasName);
                                        if (exposedNode && definitionSourceFile.writeable) {
                                            references.push({
                                                node: exposedNode,
                                                uri: definitionNode.node.tree.uri,
                                            });
                                        }
                                    }
                                    if (isExposed && moduleNameNode) {
                                        const moduleName = moduleNameNode.text;
                                        for (const uri in imports) {
                                            if (uri === definitionNode.node.tree.uri) {
                                                continue;
                                            }
                                            const otherSourceFile = program.getSourceFile(uri);
                                            if (!otherSourceFile) {
                                                continue;
                                            }
                                            const importedModuleAlias = (_j = treeUtils_1.TreeUtils.findImportAliasOfModule(moduleName, otherSourceFile.tree)) !== null && _j !== void 0 ? _j : moduleName;
                                            const allImports = imports[uri];
                                            // Find the type or type alias in the other module's imports
                                            const found = [
                                                ...allImports.getType(typeOrTypeAliasName, moduleName),
                                                ...allImports.getType(`${importedModuleAlias}.${typeOrTypeAliasName}`, moduleName),
                                            ];
                                            if (found.length > 0 && otherSourceFile.writeable) {
                                                const importClause = (_l = (_k = otherSourceFile.symbolLinks) === null || _k === void 0 ? void 0 : _k.get(otherSourceFile.tree.rootNode)) === null || _l === void 0 ? void 0 : _l.get(importedModuleAlias);
                                                if ((importClause === null || importClause === void 0 ? void 0 : importClause.type) === "Import") {
                                                    const exposedNode = treeUtils_1.TreeUtils.findExposedTypeOrTypeAliasNode(importClause.node, typeOrTypeAliasNameNode.text);
                                                    if (exposedNode) {
                                                        references.push({
                                                            node: exposedNode,
                                                            uri,
                                                        });
                                                    }
                                                }
                                                const typeOrTypeAliasCalls = found.flatMap((imp) => treeUtils_1.TreeUtils.findTypeOrTypeAliasCalls(otherSourceFile.tree, imp.name, definitionNode.type));
                                                references.push(...typeOrTypeAliasCalls.map((node) => {
                                                    return { node, uri };
                                                }));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        break;
                    case "Module":
                        if (moduleNameNode) {
                            if (definitionSourceFile.writeable) {
                                references.push({
                                    node: moduleNameNode,
                                    uri: definitionNode.node.tree.uri,
                                });
                            }
                            for (const uri in imports) {
                                if (uri === definitionNode.node.tree.uri) {
                                    continue;
                                }
                                const sourceFileToCheck = program.getSourceFile(uri);
                                if (!sourceFileToCheck || !sourceFileToCheck.writeable) {
                                    continue;
                                }
                                const imported = (_o = (_m = checker
                                    .getAllImports(sourceFileToCheck)
                                    .getModule(moduleNameNode.text)) === null || _m === void 0 ? void 0 : _m.importNode) === null || _o === void 0 ? void 0 : _o.childForFieldName("moduleName");
                                if (imported) {
                                    references.push({ node: imported, uri });
                                }
                                // Find all references in file
                                if (imported) {
                                    sourceFileToCheck.tree.rootNode
                                        .descendantsOfType("value_expr")
                                        .forEach((valueNode) => {
                                        if (RegExp(`${moduleNameNode.text}.[a-z].*`).exec(valueNode.text)) {
                                            references.push({ node: valueNode, uri });
                                        }
                                    });
                                }
                            }
                        }
                        break;
                    case "FunctionParameter":
                        if (definitionSourceFile.writeable) {
                            references.push({
                                node: definitionNode.node,
                                uri: definitionNode.node.tree.uri,
                            });
                            const valueDeclaration = treeUtils_1.TreeUtils.findParentOfType("function_declaration_left", definitionNode.node);
                            if (valueDeclaration &&
                                valueDeclaration.nextNamedSibling &&
                                valueDeclaration.nextNamedSibling.nextNamedSibling) {
                                const functionBody = valueDeclaration.nextNamedSibling.nextNamedSibling;
                                if (functionBody) {
                                    const parameters = this.findParameterUsage(functionBody, definitionNode.node.text);
                                    if (parameters) {
                                        references.push(...parameters.map((node) => {
                                            return { node, uri: definitionNode.node.tree.uri };
                                        }));
                                    }
                                }
                            }
                        }
                        break;
                    case "CasePattern":
                        if (definitionSourceFile.writeable) {
                            references.push({
                                node: definitionNode.node,
                                uri: definitionNode.node.tree.uri,
                            });
                            if (definitionNode.node.parent &&
                                definitionNode.node.parent.parent &&
                                definitionNode.node.parent.parent.parent &&
                                definitionNode.node.parent.parent.parent.lastNamedChild) {
                                const caseBody = definitionNode.node.parent.parent.parent.lastNamedChild;
                                if (caseBody) {
                                    const parameters = this.findParameterUsage(caseBody, definitionNode.node.text);
                                    if (parameters) {
                                        references.push(...parameters.map((node) => {
                                            return { node, uri: definitionNode.node.tree.uri };
                                        }));
                                    }
                                }
                            }
                        }
                        break;
                    case "AnonymousFunctionParameter":
                        if (definitionSourceFile.writeable) {
                            references.push({
                                node: definitionNode.node,
                                uri: definitionNode.node.tree.uri,
                            });
                            if (definitionNode.node.parent &&
                                definitionNode.node.parent.parent) {
                                const anonymousFunction = definitionNode.node.parent.parent; // TODO this is due to tree sitter matching wrong
                                if (anonymousFunction) {
                                    const parameters = this.findParameterUsage(anonymousFunction, definitionNode.node.text);
                                    if (parameters) {
                                        references.push(...parameters.map((node) => {
                                            return { node, uri: definitionNode.node.tree.uri };
                                        }));
                                    }
                                }
                            }
                        }
                        break;
                    case "UnionConstructor":
                        if (definitionNode.node.firstChild && moduleNameNode) {
                            const nameNode = definitionNode.node.firstChild;
                            if (definitionSourceFile.writeable) {
                                references.push({
                                    node: nameNode,
                                    uri: definitionNode.node.tree.uri,
                                });
                                const unionConstructorCalls = treeUtils_1.TreeUtils.findUnionConstructorCalls(definitionSourceFile.tree, nameNode.text);
                                if (unionConstructorCalls) {
                                    references.push(...unionConstructorCalls.map((a) => {
                                        return { node: a, uri: definitionNode.node.tree.uri };
                                    }));
                                }
                            }
                            for (const uri in imports) {
                                if (uri === definitionNode.node.tree.uri) {
                                    continue;
                                }
                                const otherSourceFile = program.getSourceFile(uri);
                                if (!otherSourceFile) {
                                    continue;
                                }
                                const moduleName = moduleNameNode.text;
                                const importedModuleAlias = (_p = treeUtils_1.TreeUtils.findImportAliasOfModule(moduleName, otherSourceFile.tree)) !== null && _p !== void 0 ? _p : moduleName;
                                const allImports = imports[uri];
                                const found = (_q = allImports.getConstructor(nameNode.text, moduleName)[0]) !== null && _q !== void 0 ? _q : allImports.getConstructor(`${importedModuleAlias}.${nameNode.text}`, moduleName)[0];
                                if (found && found.type === "UnionConstructor") {
                                    if (otherSourceFile.writeable) {
                                        const unionConstructorCallsFromOtherFiles = treeUtils_1.TreeUtils.findUnionConstructorCalls(otherSourceFile.tree, nameNode.text, importedModuleAlias);
                                        if (unionConstructorCallsFromOtherFiles) {
                                            references.push(...unionConstructorCallsFromOtherFiles.map((node) => {
                                                return { node, uri };
                                            }));
                                        }
                                    }
                                }
                            }
                        }
                        break;
                    case "FieldType":
                        {
                            const fieldName = definitionNode.node.childForFieldName("name");
                            if (fieldName) {
                                references.push({
                                    node: fieldName,
                                    uri: definitionNode.node.tree.uri,
                                });
                                references.push(...this.getFieldReferences(fieldName.text, definitionNode, definitionSourceFile, program));
                                checker
                                    .getImportingModules(definitionSourceFile)
                                    .forEach((sourceFileToCheck) => references.push(...this.getFieldReferences(fieldName.text, definitionNode, sourceFileToCheck, program)));
                            }
                        }
                        break;
                    case "TypeVariable":
                        {
                            const topLevelAnnotation = treeUtils_1.TreeUtils.findParentOfType("type_annotation", definitionNode.node, true);
                            const typeVariableNodes = [];
                            if (topLevelAnnotation) {
                                const topLevelValueDeclaration = treeUtils_1.TreeUtils.getValueDeclaration(topLevelAnnotation);
                                const typeAnnotations = [
                                    topLevelAnnotation,
                                    ...((_r = topLevelValueDeclaration === null || topLevelValueDeclaration === void 0 ? void 0 : topLevelValueDeclaration.descendantsOfType("type_annotation")) !== null && _r !== void 0 ? _r : []),
                                ];
                                typeVariableNodes.push(...typeAnnotations.flatMap((typeAnnotation) => {
                                    var _a, _b;
                                    return (_b = (_a = typeAnnotation
                                        .childForFieldName("typeExpression")) === null || _a === void 0 ? void 0 : _a.descendantsOfType("type_variable")) !== null && _b !== void 0 ? _b : [];
                                }));
                            }
                            const topLevelTypeOrTypeAlias = (_s = treeUtils_1.TreeUtils.findParentOfType("type_alias_declaration", definitionNode.node)) !== null && _s !== void 0 ? _s : treeUtils_1.TreeUtils.findParentOfType("type_declaration", definitionNode.node);
                            if (topLevelTypeOrTypeAlias) {
                                typeVariableNodes.push(...topLevelTypeOrTypeAlias.descendantsOfType([
                                    "type_variable",
                                    "lower_type_name",
                                ]));
                            }
                            typeVariableNodes
                                .filter((typeVariable) => typeVariable.text === definitionNode.name)
                                .forEach((typeVariable) => references.push({
                                node: typeVariable,
                                uri: typeVariable.tree.uri,
                            }));
                        }
                        break;
                    default:
                        break;
                }
            }
        }
        return references;
    }
    static findOperator(node, program) {
        var _a, _b, _c;
        const functionNameNode = treeUtils_1.TreeUtils.getFunctionNameNodeFromDefinition(node);
        if (functionNameNode) {
            const infixRef = (_c = (_b = (_a = program
                .getSourceFile(node.tree.uri)) === null || _a === void 0 ? void 0 : _a.symbolLinks) === null || _b === void 0 ? void 0 : _b.get(node.tree.rootNode)) === null || _c === void 0 ? void 0 : _c.get(functionNameNode.text, (s) => s.node.type === "infix_declaration");
            return infixRef === null || infixRef === void 0 ? void 0 : infixRef.node;
        }
    }
    static findFunctionCalls(node, functionName) {
        const functions = [
            ...this.findAllFunctionCallsAndParameters(node).concat(),
            ...node.descendantsOfType("record_base_identifier"),
        ];
        const result = functions
            .filter((a) => a.text === functionName)
            .map((a) => a.lastChild);
        return result.length === 0 ? undefined : result;
    }
    static findAllFunctionCallsAndParameters(node) {
        let functions = treeUtils_1.TreeUtils.descendantsOfType(node, "value_expr");
        if (functions.length > 0) {
            functions = functions
                .filter((a) => a.firstChild && a.firstChild.type === "value_qid")
                .map((a) => a.firstChild);
        }
        return functions;
    }
    static findParameterUsage(node, functionName) {
        const parameters = [
            ...this.findAllFunctionCallsAndParameters(node),
            ...this.findAllRecordBaseIdentifiers(node),
        ];
        const result = parameters.filter((a) => a.text === functionName);
        return result.length === 0 ? undefined : result;
    }
    static findAllRecordBaseIdentifiers(node) {
        return treeUtils_1.TreeUtils.descendantsOfType(node, "record_base_identifier");
    }
    static findFieldUsages(tree, fieldName) {
        return tree.rootNode
            .descendantsOfType([
            "field",
            "field_accessor_function_expr",
            "field_access_expr",
            "record_pattern",
        ])
            .flatMap((field) => {
            var _a;
            if (field.type === "record_pattern") {
                const lowerPattern = field.namedChildren.find((pattern) => pattern.type === "lower_pattern" && pattern.text === fieldName);
                if (lowerPattern) {
                    const declaration = treeUtils_1.TreeUtils.findParentOfType("value_declaration", lowerPattern);
                    const patternRefs = (_a = declaration === null || declaration === void 0 ? void 0 : declaration.descendantsOfType("value_qid").filter((ref) => ref.text === fieldName)) !== null && _a !== void 0 ? _a : [];
                    return [lowerPattern, ...patternRefs];
                }
            }
            return [field];
        })
            .map((field) => treeUtils_1.TreeUtils.findFirstNamedChildOfType("lower_case_identifier", field))
            .filter(utils_1.Utils.notUndefinedOrNull)
            .filter((field) => field.text === fieldName);
    }
    static getFieldReferences(fieldName, definition, sourceFile, program) {
        const references = [];
        const fieldUsages = References.findFieldUsages(sourceFile.tree, fieldName);
        fieldUsages.forEach((field) => {
            const fieldDef = program
                .getTypeChecker()
                .findDefinition(field, sourceFile).symbol;
            if ((fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.node.id) === definition.node.id) {
                references.push({
                    node: field,
                    uri: sourceFile.uri,
                });
            }
        });
        return references;
    }
}
exports.References = References;
//# sourceMappingURL=references.js.map