"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTypeChecker = exports.resetBindTime = exports.bindTime = void 0;
const treeUtils_1 = require("../common/util/treeUtils");
const expressionTree_1 = require("./utils/expressionTree");
const tsyringe_1 = require("tsyringe");
const typeInference_1 = require("./typeInference");
const imports_1 = require("./imports");
const typeRenderer_1 = require("./typeRenderer");
const perf_hooks_1 = require("perf_hooks");
const binder_1 = require("./binder");
const sequence_1 = require("../common/util/sequence");
const utils_1 = require("../common/util/utils");
const typeExpression_1 = require("./typeExpression");
const diagnostics_1 = require("./diagnostics");
exports.bindTime = 0;
function resetBindTime() {
    exports.bindTime = 0;
}
exports.resetBindTime = resetBindTime;
class DiagnosticsCollection extends Map {
    add(diagnostic) {
        let diagnostics = super.get(diagnostic.uri);
        if (!diagnostics) {
            diagnostics = [];
            super.set(diagnostic.uri, diagnostics);
        }
        diagnostics.push(diagnostic);
    }
    get(uri) {
        var _a;
        return (_a = super.get(uri)) !== null && _a !== void 0 ? _a : [];
    }
}
function createTypeChecker(program) {
    const imports = new Map();
    let importModuleGraph;
    const diagnostics = new DiagnosticsCollection();
    const suggestionDiagnostics = new DiagnosticsCollection();
    let cancellationToken;
    const checkedNodes = new Set();
    const start = perf_hooks_1.performance.now();
    program.getSourceFiles().forEach((sourceFile) => {
        (0, binder_1.bindTreeContainer)(sourceFile);
    });
    exports.bindTime = perf_hooks_1.performance.now() - start;
    const typeChecker = {
        findType,
        findDefinition,
        findDefinitionShallow,
        getAllImports,
        getImportingModules,
        getQualifierForName,
        typeToString,
        getDiagnostics,
        getDiagnosticsAsync,
        getSuggestionDiagnostics,
        findImportModuleNameNodes,
        getSymbolsInScope,
    };
    return typeChecker;
    function findType(node) {
        var _a, _b, _c, _d, _e;
        try {
            const declaration = (0, expressionTree_1.mapSyntaxNodeToExpression)(treeUtils_1.TreeUtils.findParentOfType("value_declaration", node, true));
            const uri = node.tree.uri;
            const findTypeOrParentType = (expr, inferenceResult) => {
                var _a, _b, _c;
                const found = expr
                    ? inferenceResult.expressionTypes.get(expr)
                    : undefined;
                if (found) {
                    return found;
                }
                // Check if the parent is the same text and position
                if (expr &&
                    expr.text === ((_a = expr.parent) === null || _a === void 0 ? void 0 : _a.text) &&
                    expr.startIndex === ((_b = expr.parent) === null || _b === void 0 ? void 0 : _b.startIndex) &&
                    expr.endIndex === ((_c = expr.parent) === null || _c === void 0 ? void 0 : _c.endIndex)) {
                    return findTypeOrParentType(expr.parent, inferenceResult);
                }
            };
            if (declaration && declaration.nodeType === "ValueDeclaration") {
                const inferenceResult = typeInference_1.InferenceScope.valueDeclarationInference(declaration, uri, program, new Set());
                if ((node === null || node === void 0 ? void 0 : node.type) === "function_declaration_left") {
                    const declaration = treeUtils_1.TreeUtils.findParentOfType("value_declaration", node);
                    if (declaration) {
                        return ((_a = inferenceResult.expressionTypes.get(declaration)) !== null && _a !== void 0 ? _a : inferenceResult.type);
                    }
                    else {
                        return typeInference_1.TUnknown;
                    }
                }
                else if (node.type === "value_declaration") {
                    return ((_b = inferenceResult.expressionTypes.get(node)) !== null && _b !== void 0 ? _b : inferenceResult.type);
                }
                return (_c = findTypeOrParentType(node, inferenceResult)) !== null && _c !== void 0 ? _c : typeInference_1.TUnknown;
            }
            const typeAliasDeclaration = (0, expressionTree_1.mapSyntaxNodeToExpression)(treeUtils_1.TreeUtils.findParentOfType("type_alias_declaration", node));
            if (typeAliasDeclaration &&
                typeAliasDeclaration.nodeType === "TypeAliasDeclaration") {
                const inferenceResult = typeExpression_1.TypeExpression.typeAliasDeclarationInference(typeAliasDeclaration, program);
                if (node.type === "type_alias_declaration") {
                    return inferenceResult.type;
                }
                return (_d = findTypeOrParentType(node, inferenceResult)) !== null && _d !== void 0 ? _d : typeInference_1.TUnknown;
            }
            const unionVariant = node.type === "union_variant"
                ? (0, expressionTree_1.mapSyntaxNodeToExpression)(node)
                : undefined;
            if (unionVariant && unionVariant.nodeType === "UnionVariant") {
                return typeExpression_1.TypeExpression.unionVariantInference(unionVariant, program).type;
            }
            const typeDeclaration = (0, expressionTree_1.mapSyntaxNodeToExpression)(treeUtils_1.TreeUtils.findParentOfType("type_declaration", node));
            if (typeDeclaration && typeDeclaration.nodeType === "TypeDeclaration") {
                const inferenceResult = typeExpression_1.TypeExpression.typeDeclarationInference(typeDeclaration, program);
                return (_e = findTypeOrParentType(node, inferenceResult)) !== null && _e !== void 0 ? _e : typeInference_1.TUnknown;
            }
            const portAnnotation = (0, expressionTree_1.mapSyntaxNodeToExpression)(node);
            if (portAnnotation && portAnnotation.nodeType === "PortAnnotation") {
                return typeExpression_1.TypeExpression.portAnnotationInference(portAnnotation, program)
                    .type;
            }
            return typeInference_1.TUnknown;
        }
        catch (error) {
            const connection = tsyringe_1.container.resolve("Connection");
            connection.console.warn(`Error while trying to infer a type. ${error}`);
            return typeInference_1.TUnknown;
        }
    }
    function getDiagnostics(sourceFile, token) {
        try {
            cancellationToken = token;
            checkNode(sourceFile.tree.rootNode);
            return diagnostics.get(sourceFile.uri);
        }
        finally {
            cancellationToken = undefined;
        }
    }
    function getDiagnosticsAsync(sourceFile, token, cancelCallback) {
        cancellationToken = token;
        return new Promise((resolve, reject) => {
            const children = sourceFile.tree.rootNode.children;
            let index = 0;
            const goNext = () => {
                index++;
                if (children.length > index) {
                    setImmediate(checkOne);
                }
                else {
                    cancellationToken = undefined;
                    resolve(diagnostics.get(sourceFile.uri));
                }
            };
            const checkOne = () => {
                if (cancelCallback && cancelCallback()) {
                    reject();
                    return;
                }
                try {
                    checkNode(children[index]);
                }
                catch (_a) {
                    cancellationToken = undefined;
                    reject();
                    return;
                }
                goNext();
            };
            checkOne();
        });
    }
    function getSuggestionDiagnostics(sourceFile, token) {
        try {
            cancellationToken = token;
            checkNode(sourceFile.tree.rootNode);
            return suggestionDiagnostics.get(sourceFile.uri);
        }
        finally {
            cancellationToken = undefined;
        }
    }
    function getAllImports(sourceFile) {
        const cached = imports.get(sourceFile.uri);
        if (cached) {
            return cached;
        }
        const allImports = imports_1.Imports.getImports(sourceFile, program);
        allImports.getDiagnostics().forEach((diagnostic) => {
            diagnostics.add(diagnostic);
        });
        imports.set(sourceFile.uri, allImports);
        return allImports;
    }
    function getImportingModules(sourceFile, directImportOnly) {
        var _a;
        if (!importModuleGraph) {
            importModuleGraph = new Map();
            program.getSourceFiles().forEach((sourceFile) => {
                if (sourceFile.writeable) {
                    getAllImports(sourceFile)
                        .getModules()
                        .forEach((module) => {
                        const existingGraph = importModuleGraph.get(module.fromModule.uri);
                        if (existingGraph) {
                            existingGraph.push(sourceFile);
                        }
                        else {
                            importModuleGraph.set(module.fromModule.uri, [sourceFile]);
                        }
                    });
                }
            });
        }
        if (directImportOnly) {
            return (_a = importModuleGraph.get(sourceFile.uri)) !== null && _a !== void 0 ? _a : [];
        }
        const getAllDescendantImports = (source) => {
            var _a;
            const imports = (_a = importModuleGraph.get(source.uri)) !== null && _a !== void 0 ? _a : [];
            imports.slice(0).forEach((directImport) => {
                imports.push(...getAllDescendantImports(directImport));
            });
            return imports;
        };
        return getAllDescendantImports(sourceFile);
    }
    function findImport(sourceFile, name, type) {
        const allImports = getAllImports(sourceFile);
        if (type === "Type") {
            return allImports.getType(name);
        }
        else if (type === "Constructor") {
            return allImports.getConstructor(name);
        }
        else if (type === "Module") {
            const module = allImports.getModule(name);
            if (module) {
                return [module];
            }
            else {
                return [];
            }
        }
        else if (type === "Var") {
            return allImports.getVar(name);
        }
        let result = allImports.getVar(name);
        if (result.length > 0) {
            return result;
        }
        result = allImports.getType(name);
        if (result.length > 0) {
            return result;
        }
        return allImports.getConstructor(name);
    }
    function findDefinition(nodeAtPosition, sourceFile) {
        var _a, _b;
        const definition = findDefinitionShallow(nodeAtPosition, sourceFile);
        if (((_b = (_a = definition.symbol) === null || _a === void 0 ? void 0 : _a.node) === null || _b === void 0 ? void 0 : _b.type) === "lower_pattern" &&
            definition.symbol.node.firstNamedChild) {
            const innerDefinition = findDefinitionShallow(definition.symbol.node.firstNamedChild, sourceFile);
            if (innerDefinition.symbol) {
                return innerDefinition;
            }
        }
        return definition;
    }
    function findDefinitionShallow(nodeAtPosition, sourceFile) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10;
        const nodeText = nodeAtPosition.text;
        const nodeParent = nodeAtPosition.parent;
        if (!nodeParent) {
            return { diagnostics: [] };
        }
        const nodeParentType = nodeParent.type;
        const rootSymbols = (_a = sourceFile.symbolLinks) === null || _a === void 0 ? void 0 : _a.get(sourceFile.tree.rootNode);
        if (nodeParentType === "upper_case_qid" &&
            ((_b = nodeParent.previousNamedSibling) === null || _b === void 0 ? void 0 : _b.type) === "module") {
            const moduleNode = nodeParent.parent;
            if (moduleNode) {
                return {
                    symbol: { name: moduleNode.text, node: moduleNode, type: "Module" },
                    diagnostics: [],
                };
            }
        }
        else if (nodeParentType === "upper_case_qid" &&
            ((_c = nodeParent.previousNamedSibling) === null || _c === void 0 ? void 0 : _c.type) === "import") {
            const upperCaseQid = nodeParent;
            const upperCaseQidText = upperCaseQid.text;
            return {
                symbol: findImport(sourceFile, upperCaseQidText, "Module")[0],
                diagnostics: [],
            };
        }
        else if ((nodeParentType === "exposed_value" &&
            ((_e = (_d = nodeParent.parent) === null || _d === void 0 ? void 0 : _d.parent) === null || _e === void 0 ? void 0 : _e.type) === "module_declaration") ||
            nodeParentType === "type_annotation" ||
            nodeParentType === "port_annotation") {
            const symbol = rootSymbols === null || rootSymbols === void 0 ? void 0 : rootSymbols.get(nodeText);
            if (symbol && (symbol.type === "Function" || symbol.type === "Port")) {
                return {
                    symbol,
                    diagnostics: [],
                };
            }
            // This is for values, with type annotation, but *inside* a let.
            if (((_f = nodeParent.nextNamedSibling) === null || _f === void 0 ? void 0 : _f.type) === "value_declaration") {
                // A value_declaration with a type annotation got it's type_annotation node
                // added. So, we confirm the value_declaration does indeed follow, and return
                // type node text with value declaration node.
                return {
                    symbol: {
                        name: nodeText,
                        node: nodeParent.nextNamedSibling.children[0], // the function_declaration_left
                        type: "Function",
                    },
                    diagnostics: [],
                };
            }
        }
        else if ((nodeParentType === "exposed_type" &&
            ((_h = (_g = nodeParent.parent) === null || _g === void 0 ? void 0 : _g.parent) === null || _h === void 0 ? void 0 : _h.type) === "module_declaration") ||
            ((_j = nodeAtPosition.previousNamedSibling) === null || _j === void 0 ? void 0 : _j.type) === "type" ||
            ((_k = nodeAtPosition.previousNamedSibling) === null || _k === void 0 ? void 0 : _k.type) === "alias") {
            return {
                symbol: rootSymbols === null || rootSymbols === void 0 ? void 0 : rootSymbols.get(nodeText, (symbol) => symbol.type === "Type" || symbol.type === "TypeAlias"),
                diagnostics: [],
            };
        }
        else if ((nodeParentType === "exposed_value" ||
            nodeParentType === "exposed_type") &&
            ((_m = (_l = nodeParent.parent) === null || _l === void 0 ? void 0 : _l.parent) === null || _m === void 0 ? void 0 : _m.type) === "import_clause") {
            const moduleName = (_q = (_p = (_o = nodeParent.parent) === null || _o === void 0 ? void 0 : _o.parent.childForFieldName("moduleName")) === null || _p === void 0 ? void 0 : _p.text) !== null && _q !== void 0 ? _q : "";
            const imports = findImport(sourceFile, nodeText, nodeParentType === "exposed_value" ? "Var" : "Type").filter((imp) => imp.fromModule.name === moduleName);
            return {
                symbol: imports[0],
                diagnostics: [],
            };
        }
        else if (nodeParentType === "union_variant") {
            const definitionNode = nodeParent;
            return {
                symbol: {
                    name: definitionNode.text,
                    node: definitionNode,
                    type: "UnionConstructor",
                },
                diagnostics: [],
            };
        }
        else if (nodeParent && nodeParent.type === "upper_case_qid") {
            const upperCaseQid = nodeParent;
            const upperCaseQidText = upperCaseQid.text;
            // Usage is either a type or a constructor
            // A type can only be used as a type
            // A union variant can only be used as a constructor or as a pattern
            // A type alias can be used as both a type and a constructor
            const isTypeUsage = treeUtils_1.TreeUtils.isTypeUsage(upperCaseQid);
            const isConstructorUsage = treeUtils_1.TreeUtils.isConstructorUsage(upperCaseQid);
            const localSymbols = (_s = (_r = rootSymbols === null || rootSymbols === void 0 ? void 0 : rootSymbols.getAll(upperCaseQidText)) === null || _r === void 0 ? void 0 : _r.filter((symbol) => {
                var _a;
                return isTypeUsage
                    ? symbol.type === "Type" || symbol.type === "TypeAlias"
                    : isConstructorUsage
                        ? symbol.type === "UnionConstructor" ||
                            (symbol.type === "TypeAlias" && ((_a = symbol.constructors) === null || _a === void 0 ? void 0 : _a.length))
                        : symbol.type === "UnionConstructor";
            })) !== null && _s !== void 0 ? _s : [];
            if (localSymbols.length > 0) {
                return {
                    symbol: localSymbols[0],
                    diagnostics: [],
                };
            }
            const imports = findImport(sourceFile, upperCaseQidText, isTypeUsage ? "Type" : "Constructor");
            if (imports.length > 0) {
                return {
                    symbol: imports.length === 1 ? imports[0] : undefined,
                    diagnostics: imports.length > 1
                        ? [
                            (0, diagnostics_1.error)(upperCaseQid, isTypeUsage
                                ? diagnostics_1.Diagnostics.AmbiguousType
                                : diagnostics_1.Diagnostics.AmbiguousVariant, upperCaseQidText),
                        ]
                        : [],
                };
            }
            // Make sure the next node is a dot, or else it isn't a Module
            if (((_t = treeUtils_1.TreeUtils.nextNode(nodeAtPosition)) === null || _t === void 0 ? void 0 : _t.type) === "dot") {
                const endPos = upperCaseQidText.indexOf(nodeText) + nodeText.length;
                // There may be multiple imports with the same name/alias, but we just go to the first one
                const moduleNameOrAlias = nodeParent.text.substring(0, endPos);
                const moduleName = (_v = (_u = findImportModuleNameNodes(moduleNameOrAlias, sourceFile)[0]) === null || _u === void 0 ? void 0 : _u.text) !== null && _v !== void 0 ? _v : moduleNameOrAlias;
                const moduleImport = findImport(sourceFile, moduleName, "Module")[0];
                if (moduleImport) {
                    return {
                        symbol: moduleImport,
                        diagnostics: [],
                    };
                }
            }
            // There may be multiple imports with the same name/alias, but we just go to the first one
            const moduleImport = findImport(sourceFile, (_x = (_w = findImportModuleNameNodes(upperCaseQidText, sourceFile)[0]) === null || _w === void 0 ? void 0 : _w.text) !== null && _x !== void 0 ? _x : upperCaseQidText, "Module")[0];
            if (moduleImport) {
                return {
                    symbol: moduleImport,
                    diagnostics: [],
                };
            }
        }
        else if (nodeParentType === "lower_pattern" &&
            ((_y = nodeParent.parent) === null || _y === void 0 ? void 0 : _y.type) === "record_pattern") {
            const type = findType(nodeParent.parent);
            return {
                symbol: treeUtils_1.TreeUtils.findFieldReference(type, nodeText),
                diagnostics: [],
            };
        }
        else if (nodeAtPosition.type === "lower_case_identifier" &&
            nodeParentType === "function_declaration_left" &&
            ((_z = nodeParent.parent) === null || _z === void 0 ? void 0 : _z.type) === "value_declaration") {
            // The function name should resolve to itself
            if (((_0 = nodeParent.firstNamedChild) === null || _0 === void 0 ? void 0 : _0.text) === nodeText) {
                return {
                    symbol: { name: nodeParent.text, node: nodeParent, type: "Function" },
                    diagnostics: [],
                };
            }
        }
        else if (nodeParentType === "value_qid" ||
            nodeParentType === "lower_pattern" ||
            nodeParentType === "record_base_identifier") {
            let nodeAtPositionText = nodeText;
            if (nodeParentType === "value_qid") {
                nodeAtPositionText = nodeParent.text;
            }
            // Traverse the parents and find a binding
            // For operator functions, there are two bindings:
            // The infix declaration and the function
            // Never resolve to the infix declaration
            const localBinding = new sequence_1.Sequence(nodeAtPosition, (node) => { var _a; return (_a = node.parent) !== null && _a !== void 0 ? _a : undefined; })
                .map((node) => {
                var _a, _b;
                return (_b = (_a = sourceFile.symbolLinks) === null || _a === void 0 ? void 0 : _a.get(node)) === null || _b === void 0 ? void 0 : _b.get(nodeAtPositionText, (s) => s.node.type !== "infix_declaration");
            })
                .find(utils_1.Utils.notUndefined);
            if (localBinding) {
                return {
                    symbol: localBinding,
                    diagnostics: [],
                };
            }
            else {
                const nodeParentText = nodeParent.text;
                // Get the full module name and handle an import alias if there is one
                if (nodeAtPosition.type === "upper_case_identifier") {
                    const moduleNameOrAlias = (_2 = (_1 = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("upper_case_identifier", nodeParent)) === null || _1 === void 0 ? void 0 : _1.map((node) => node.text).join(".")) !== null && _2 !== void 0 ? _2 : "";
                    const moduleName = (_4 = (_3 = findImportModuleNameNodes(moduleNameOrAlias, sourceFile)[0]) === null || _3 === void 0 ? void 0 : _3.text) !== null && _4 !== void 0 ? _4 : moduleNameOrAlias;
                    const moduleImport = findImport(sourceFile, moduleName, "Module")[0];
                    if (moduleImport) {
                        return {
                            symbol: moduleImport,
                            diagnostics: [],
                        };
                    }
                }
                const imports = findImport(sourceFile, nodeParentText, "Var");
                return {
                    symbol: imports.length === 1 ? imports[0] : undefined,
                    diagnostics: imports.length > 1
                        ? [(0, diagnostics_1.error)(nodeParent, diagnostics_1.Diagnostics.AmbiguousVar, nodeParentText)]
                        : [],
                };
            }
        }
        else if (nodeAtPosition.type === "operator_identifier") {
            const definitionNode = treeUtils_1.TreeUtils.findOperator(sourceFile, nodeText);
            if (definitionNode) {
                const result = {
                    symbol: {
                        name: definitionNode.text,
                        node: definitionNode,
                        type: "Operator",
                    },
                    diagnostics: [],
                };
                return result;
            }
            else {
                const operatorImport = findImport(sourceFile, nodeText, "Var")[0];
                if (operatorImport) {
                    const result = {
                        symbol: operatorImport,
                        diagnostics: [],
                    };
                    return result;
                }
            }
        }
        else if (nodeParentType === "field_access_expr") {
            let target = nodeParent === null || nodeParent === void 0 ? void 0 : nodeParent.childForFieldName("target");
            // Adjust for parenthesis expr. Will need to change when we handle it better in inference
            if ((target === null || target === void 0 ? void 0 : target.type) === "parenthesized_expr") {
                target = target.firstNamedChild;
            }
            if (target) {
                const type = findType(target);
                return {
                    symbol: treeUtils_1.TreeUtils.findFieldReference(type, nodeText),
                    diagnostics: [],
                };
            }
        }
        else if (nodeAtPosition.type === "lower_case_identifier" &&
            nodeParentType === "field" &&
            ((_5 = nodeParent.parent) === null || _5 === void 0 ? void 0 : _5.type) === "record_expr") {
            const type = findType(nodeParent.parent);
            return {
                symbol: treeUtils_1.TreeUtils.findFieldReference(type, nodeText),
                diagnostics: [],
            };
        }
        else if (nodeAtPosition.type === "lower_case_identifier" &&
            nodeParentType === "field_accessor_function_expr") {
            const type = findType(nodeParent);
            if (type.nodeType === "Function") {
                const paramType = type.params[0];
                return {
                    symbol: treeUtils_1.TreeUtils.findFieldReference(paramType, nodeText),
                    diagnostics: [],
                };
            }
        }
        else if (nodeAtPosition.type === "lower_case_identifier" &&
            nodeParentType === "field_type") {
            return {
                symbol: { name: nodeParent.text, node: nodeParent, type: "FieldType" },
                diagnostics: [],
            };
        }
        else if (nodeAtPosition.type === "upper_case_identifier" &&
            nodeParentType === "ERROR") {
            let fullModuleName = nodeText;
            // Get fully qualified module name
            // Ex: nodeText is Attributes, we need to get Html.Attributes manually
            let currentNode = nodeAtPosition.previousNamedSibling;
            while ((currentNode === null || currentNode === void 0 ? void 0 : currentNode.type) === "dot" &&
                ((_6 = currentNode.previousNamedSibling) === null || _6 === void 0 ? void 0 : _6.type) === "upper_case_identifier") {
                fullModuleName = `${currentNode.previousNamedSibling.text}.${fullModuleName}`;
                currentNode = currentNode.previousNamedSibling.previousNamedSibling;
            }
            const moduleImport = findImport(sourceFile, (_8 = (_7 = findImportModuleNameNodes(fullModuleName, sourceFile)[0]) === null || _7 === void 0 ? void 0 : _7.text) !== null && _8 !== void 0 ? _8 : fullModuleName, "Module")[0];
            if (moduleImport) {
                return {
                    symbol: moduleImport,
                    diagnostics: [],
                };
            }
        }
        const parentType = (_10 = (_9 = treeUtils_1.TreeUtils.findParentOfType("type_annotation", nodeAtPosition)) !== null && _9 !== void 0 ? _9 : treeUtils_1.TreeUtils.findParentOfType("type_declaration", nodeAtPosition)) !== null && _10 !== void 0 ? _10 : treeUtils_1.TreeUtils.findParentOfType("type_alias_declaration", nodeAtPosition);
        if ((parentType === null || parentType === void 0 ? void 0 : parentType.type) === "type_annotation") {
            const ancestorDeclarations = treeUtils_1.TreeUtils.getAllAncestorsOfType("value_declaration", parentType);
            const allAnnotations = [
                ...ancestorDeclarations
                    .map((n) => treeUtils_1.TreeUtils.getTypeAnnotation(n))
                    .filter((n) => !!n)
                    .reverse(),
                parentType,
            ];
            const callback = (annotation) => annotation
                ? treeUtils_1.TreeUtils.descendantsOfType(annotation, "type_variable")
                : [];
            const allTypeVariables = allAnnotations.flatMap(callback);
            const firstMatching = allTypeVariables.find((t) => t.text === nodeText);
            if (firstMatching) {
                return {
                    symbol: {
                        name: firstMatching.text,
                        node: firstMatching,
                        type: "TypeVariable",
                    },
                    diagnostics: [],
                };
            }
        }
        else if (parentType) {
            const allTypeNames = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("lower_type_name", parentType);
            const firstMatching = allTypeNames === null || allTypeNames === void 0 ? void 0 : allTypeNames.find((t) => t.text === nodeText);
            if (firstMatching) {
                return {
                    symbol: {
                        name: firstMatching.text,
                        node: firstMatching,
                        type: "TypeVariable",
                    },
                    diagnostics: [],
                };
            }
        }
        return { diagnostics: [] };
    }
    function getQualifierForName(sourceFile, module, name) {
        var _a, _b, _c;
        if (findImport(sourceFile, name).length > 0) {
            return "";
        }
        if (module === "List" && name === "List") {
            return "";
        }
        const moduleImport = (_a = findImport(sourceFile, module, "Module")[0]) === null || _a === void 0 ? void 0 : _a.importNode;
        if (!moduleImport) {
            return "";
        }
        const asClause = treeUtils_1.TreeUtils.findFirstNamedChildOfType("as_clause", moduleImport);
        if (asClause) {
            return `${(_c = (_b = asClause === null || asClause === void 0 ? void 0 : asClause.lastNamedChild) === null || _b === void 0 ? void 0 : _b.text) !== null && _c !== void 0 ? _c : module}.`;
        }
        return `${module}.`;
    }
    function typeToString(t, sourceFile) {
        return new typeRenderer_1.TypeRenderer(typeChecker, sourceFile).render(t);
    }
    /**
     * Get the module name node if the name is an alias
     */
    function findImportModuleNameNodes(moduleNameOrAlias, sourceFile) {
        var _a, _b, _c, _d, _e, _f;
        // This will find an import based on module name only, not alias
        const moduleImport = (_b = (_a = getAllImports(sourceFile)
            .getModule(moduleNameOrAlias)) === null || _a === void 0 ? void 0 : _a.importNode) === null || _b === void 0 ? void 0 : _b.childForFieldName("moduleName");
        // This will not find a module by name if it is aliased
        const moduleOrAliasImports = (_f = (_e = (_d = (_c = sourceFile.symbolLinks) === null || _c === void 0 ? void 0 : _c.get(sourceFile.tree.rootNode)) === null || _d === void 0 ? void 0 : _d.getAll(moduleNameOrAlias)) === null || _e === void 0 ? void 0 : _e.filter((s) => s.type === "Import").map((s) => s.node.childForFieldName("moduleName")).filter(utils_1.Utils.notUndefinedOrNull)) !== null && _f !== void 0 ? _f : [];
        if (moduleImport &&
            moduleOrAliasImports.every((n) => n.id !== moduleImport.id)) {
            return [moduleImport, ...moduleOrAliasImports];
        }
        return moduleOrAliasImports;
    }
    function getSymbolsInScope(node, sourceFile) {
        var _a, _b;
        const symbols = [];
        let targetScope = node;
        while (targetScope != null) {
            (_b = (_a = sourceFile.symbolLinks) === null || _a === void 0 ? void 0 : _a.get(targetScope)) === null || _b === void 0 ? void 0 : _b.forEach((symbol) => symbols.push(symbol));
            targetScope = targetScope.parent;
        }
        return symbols;
    }
    function checkNode(node) {
        if (checkedNodes.has(node.id)) {
            return;
        }
        cancellationToken === null || cancellationToken === void 0 ? void 0 : cancellationToken.throwIfCancellationRequested();
        switch (node.type) {
            case "file":
                node.children.forEach(checkNode);
                break;
            case "value_declaration":
                checkValueDeclaration(node);
                break;
            case "import_clause":
                checkImportClause(node);
                break;
            case "type_alias_declaration":
                checkTypeAliasDeclaration(node);
                break;
            case "type_declaration":
                checkTypeDeclaration(node);
                break;
            case "union_variant":
                checkUnionVariant(node);
                break;
            case "port_annotation":
                checkPortAnnotation(node);
                break;
        }
        checkedNodes.add(node.id);
    }
    function checkValueDeclaration(valueDeclaration) {
        var _a;
        const declaration = (0, expressionTree_1.mapSyntaxNodeToExpression)(valueDeclaration);
        const result = typeInference_1.InferenceScope.valueDeclarationInference(declaration, valueDeclaration.tree.uri, program, new Set(), 
        /* recursionAllowed */ false, cancellationToken);
        result.diagnostics.forEach((diagnostic) => diagnostics.add(diagnostic));
        if (!declaration.typeAnnotation) {
            const typeString = typeToString(result.type, getSourceFileOfNode(declaration));
            if (typeString &&
                typeString !== "unknown" &&
                ((_a = declaration.firstNamedChild) === null || _a === void 0 ? void 0 : _a.firstNamedChild)) {
                suggestionDiagnostics.add((0, diagnostics_1.error)(declaration.firstNamedChild.firstNamedChild, diagnostics_1.Diagnostics.MissingTypeAnnotation, typeString));
            }
        }
    }
    function checkImportClause(importClause) {
        const moduleNameNode = importClause.childForFieldName("moduleName");
        if (moduleNameNode) {
            const moduleName = moduleNameNode.text;
            const sourceFile = getSourceFileOfNode(importClause);
            if (!program.getSourceFileOfImportableModule(sourceFile, moduleName) &&
                !program.getKernelSourceFileOfImportableModule(sourceFile, moduleName)) {
                diagnostics.add((0, diagnostics_1.error)(moduleNameNode, diagnostics_1.Diagnostics.ImportMissing, moduleName));
            }
        }
    }
    function checkTypeAliasDeclaration(typeAliasDeclaration) {
        typeExpression_1.TypeExpression.typeAliasDeclarationInference((0, expressionTree_1.mapSyntaxNodeToExpression)(typeAliasDeclaration), program).diagnostics.forEach((diagnostic) => diagnostics.add(diagnostic));
    }
    function checkTypeDeclaration(typeDeclaration) {
        typeExpression_1.TypeExpression.typeDeclarationInference((0, expressionTree_1.mapSyntaxNodeToExpression)(typeDeclaration), program).diagnostics.forEach((diagnostic) => diagnostics.add(diagnostic));
        // Need to check union variants
        typeDeclaration.children.forEach(checkNode);
    }
    function checkUnionVariant(unionVariant) {
        typeExpression_1.TypeExpression.unionVariantInference((0, expressionTree_1.mapSyntaxNodeToExpression)(unionVariant), program).diagnostics.forEach((diagnostic) => diagnostics.add(diagnostic));
    }
    function checkPortAnnotation(portAnnotation) {
        typeExpression_1.TypeExpression.portAnnotationInference((0, expressionTree_1.mapSyntaxNodeToExpression)(portAnnotation), program).diagnostics.forEach((diagnostic) => diagnostics.add(diagnostic));
    }
    function getSourceFileOfNode(node) {
        const sourceFile = program.getSourceFile(node.tree.uri);
        if (!sourceFile) {
            throw new Error(`Can't find sourceFile by uri "${node.tree.uri}"`);
        }
        else {
            return sourceFile;
        }
    }
}
exports.createTypeChecker = createTypeChecker;
//# sourceMappingURL=typeChecker.js.map