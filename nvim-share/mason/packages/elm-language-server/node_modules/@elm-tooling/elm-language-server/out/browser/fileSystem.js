"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWebFileSystemHost = void 0;
const browser_1 = require("vscode-languageserver/browser");
const protocol_1 = require("../common/protocol");
const common_1 = require("../common");
const vscode_uri_1 = require("vscode-uri");
const request_light_1 = require("request-light");
const indexedDB_1 = require("./indexedDB");
function createWebFileSystemHost(connection) {
    let indexedDbFileSystemProvider;
    const getFileSystemProvider = () => __awaiter(this, void 0, void 0, function* () {
        if (!indexedDbFileSystemProvider) {
            indexedDbFileSystemProvider = yield getIndexedDbFileSystemProvider();
        }
        return indexedDbFileSystemProvider;
    });
    return {
        readFile: (uri) => (0, common_1.readFileWithCachedVirtualPackageFile)(uri, (uri) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            // TODO: I thought that VSCode provided a https file system provider in the web
            if (uri.scheme === "http" || uri.scheme === "https") {
                return (_a = (yield loadFileFromHttp(uri))) !== null && _a !== void 0 ? _a : "";
            }
            const bytes = yield connection.sendRequest(protocol_1.ReadFileRequest, uri.toString());
            return new TextDecoder().decode(new Uint8Array(bytes));
        }), {
            getVirtualPackageRoot: () => common_1.virtualPackagesRoot,
            get: (uri) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const provider = yield getFileSystemProvider();
                    const result = yield provider.readFile(uri);
                    return new TextDecoder().decode(result);
                }
                catch (_b) {
                    return undefined;
                }
            }),
            set: (uri, value) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const provider = yield getFileSystemProvider();
                    yield provider.writeFile(uri, new TextEncoder().encode(value));
                }
                catch (_c) {
                    //
                }
            }),
        }),
        readFileSync: () => "",
        readDirectory: (uri) => __awaiter(this, void 0, void 0, function* () {
            const result = yield connection.sendRequest(protocol_1.ReadDirectoryRequest, (0, common_1.convertToFileSystemUri)(uri).toString());
            return result.map((path) => vscode_uri_1.URI.parse(path));
        }),
        fileExists: () => false,
        watchFile: () => {
            return browser_1.Disposable.create(() => {
                //
            });
        },
        getElmPackagesRoot: () => common_1.virtualPackagesRoot,
    };
}
exports.createWebFileSystemHost = createWebFileSystemHost;
function loadFileFromHttp(uri) {
    const headers = { "Accept-Encoding": "gzip, deflate" };
    return (0, request_light_1.xhr)({ url: uri.toString(), followRedirects: 5, headers }).then((response) => {
        if (response.status !== 200) {
            return;
        }
        return response.responseText;
    }, (error) => {
        return Promise.reject(error.responseText ||
            (0, request_light_1.getErrorStatusDescription)(error.status) ||
            error.toString());
    });
}
function getIndexedDbFileSystemProvider() {
    return __awaiter(this, void 0, void 0, function* () {
        const store = "elm-package-files";
        const indexedDB = yield indexedDB_1.IndexedDB.create("elm-language-server", 1, [store]);
        const mtimes = new Map();
        let cachedFiletree;
        const getFiletree = () => {
            if (!cachedFiletree) {
                cachedFiletree = (() => __awaiter(this, void 0, void 0, function* () {
                    const rootNode = new IndexedDBFileSystemNode({
                        children: new Map(),
                        path: "",
                        type: FileType.Directory,
                    });
                    const result = yield indexedDB.runInTransaction(store, "readonly", (objectStore) => objectStore.getAllKeys());
                    const keys = result.map((key) => key.toString());
                    keys.forEach((key) => rootNode.add(key, { type: "file" }));
                    return rootNode;
                }))();
            }
            return cachedFiletree;
        };
        const bulkWrite = (files) => __awaiter(this, void 0, void 0, function* () {
            files.forEach(([resource, content]) => fileWriteBatch.push({ content, resource }));
            yield writeMany();
            const fileTree = yield getFiletree();
            for (const [resource, content] of files) {
                fileTree.add(resource.path, { type: "file", size: content.byteLength });
                mtimes.set(resource.toString(), Date.now());
            }
        });
        const fileWriteBatch = [];
        const writeMany = () => __awaiter(this, void 0, void 0, function* () {
            if (fileWriteBatch.length) {
                const fileBatch = fileWriteBatch.splice(0, fileWriteBatch.length);
                yield indexedDB.runInTransaction(store, "readwrite", (objectStore) => fileBatch.map((entry) => {
                    return objectStore.put(entry.content, entry.resource.path);
                }));
            }
        });
        return {
            readFile(resource) {
                return __awaiter(this, void 0, void 0, function* () {
                    const result = yield indexedDB.runInTransaction(store, "readonly", (objectStore) => objectStore.get(resource.path));
                    if (result === undefined) {
                        throw new Error("File not found");
                    }
                    const buffer = result instanceof Uint8Array
                        ? result
                        : typeof result === "string"
                            ? new TextEncoder().encode(result)
                            : undefined;
                    if (buffer === undefined) {
                        throw Error(`IndexedDB entry at "${resource.path}" in unexpected format`);
                    }
                    // update cache
                    const fileTree = yield getFiletree();
                    fileTree.add(resource.path, { type: "file", size: buffer.byteLength });
                    return buffer;
                });
            },
            writeFile(resource, content) {
                return __awaiter(this, void 0, void 0, function* () {
                    yield bulkWrite([[resource, content]]);
                });
            },
        };
    });
}
var FileType;
(function (FileType) {
    FileType[FileType["Unknown"] = 0] = "Unknown";
    FileType[FileType["File"] = 1] = "File";
    FileType[FileType["Directory"] = 2] = "Directory";
    FileType[FileType["SymbolicLink"] = 64] = "SymbolicLink";
})(FileType || (FileType = {}));
class IndexedDBFileSystemNode {
    constructor(entry) {
        this.entry = entry;
        this.type = entry.type;
    }
    read(path) {
        return this.doRead(path.split("/").filter((p) => p.length));
    }
    doRead(pathParts) {
        if (pathParts.length === 0) {
            return this.entry;
        }
        if (this.entry.type !== FileType.Directory) {
            throw Error("Internal error reading from IndexedDBFSNode -- expected directory at " +
                this.entry.path);
        }
        const next = this.entry.children.get(pathParts[0]);
        if (!next) {
            return undefined;
        }
        return next.doRead(pathParts.slice(1));
    }
    delete(path) {
        const toDelete = path.split("/").filter((p) => p.length);
        if (toDelete.length === 0) {
            if (this.entry.type !== FileType.Directory) {
                throw Error(`Internal error deleting from IndexedDBFSNode. Expected root entry to be directory`);
            }
            this.entry.children.clear();
        }
        else {
            return this.doDelete(toDelete, path);
        }
    }
    doDelete(pathParts, originalPath) {
        if (pathParts.length === 0) {
            throw Error(`Internal error deleting from IndexedDBFSNode -- got no deletion path parts (encountered while deleting ${originalPath})`);
        }
        else if (this.entry.type !== FileType.Directory) {
            throw Error("Internal error deleting from IndexedDBFSNode -- expected directory at " +
                this.entry.path);
        }
        else if (pathParts.length === 1) {
            this.entry.children.delete(pathParts[0]);
        }
        else {
            const next = this.entry.children.get(pathParts[0]);
            if (!next) {
                throw Error("Internal error deleting from IndexedDBFSNode -- expected entry at " +
                    this.entry.path +
                    "/");
            }
            next.doDelete(pathParts.slice(1), originalPath);
        }
    }
    add(path, entry) {
        this.doAdd(path.split("/").filter((p) => p.length), entry, path);
    }
    doAdd(pathParts, entry, originalPath) {
        if (pathParts.length === 0) {
            throw Error(`Internal error creating IndexedDBFSNode -- adding empty path (encountered while adding ${originalPath})`);
        }
        else if (this.entry.type !== FileType.Directory) {
            throw Error(`Internal error creating IndexedDBFSNode -- parent is not a directory (encountered while adding ${originalPath})`);
        }
        else if (pathParts.length === 1) {
            const next = pathParts[0];
            const existing = this.entry.children.get(next);
            if (entry.type === "dir") {
                if ((existing === null || existing === void 0 ? void 0 : existing.entry.type) === FileType.File) {
                    throw Error(`Internal error creating IndexedDBFSNode -- overwriting file with directory: ${this.entry.path}/${next} (encountered while adding ${originalPath})`);
                }
                this.entry.children.set(next, existing !== null && existing !== void 0 ? existing : new IndexedDBFileSystemNode({
                    type: FileType.Directory,
                    path: this.entry.path + "/" + next,
                    children: new Map(),
                }));
            }
            else {
                if ((existing === null || existing === void 0 ? void 0 : existing.entry.type) === FileType.Directory) {
                    throw Error(`Internal error creating IndexedDBFSNode -- overwriting directory with file: ${this.entry.path}/${next} (encountered while adding ${originalPath})`);
                }
                this.entry.children.set(next, new IndexedDBFileSystemNode({
                    type: FileType.File,
                    path: this.entry.path + "/" + next,
                    size: entry.size,
                }));
            }
        }
        else if (pathParts.length > 1) {
            const next = pathParts[0];
            let childNode = this.entry.children.get(next);
            if (!childNode) {
                childNode = new IndexedDBFileSystemNode({
                    children: new Map(),
                    path: this.entry.path + "/" + next,
                    type: FileType.Directory,
                });
                this.entry.children.set(next, childNode);
            }
            else if (childNode.type === FileType.File) {
                throw Error(`Internal error creating IndexedDBFSNode -- overwriting file entry with directory: ${this.entry.path}/${next} (encountered while adding ${originalPath})`);
            }
            childNode.doAdd(pathParts.slice(1), entry, originalPath);
        }
    }
    print(indentation = "") {
        console.log(indentation + this.entry.path);
        if (this.entry.type === FileType.Directory) {
            this.entry.children.forEach((child) => child.print(indentation + " "));
        }
    }
}
//# sourceMappingURL=fileSystem.js.map