"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkspaceSymbolProvider = void 0;
const tsyringe_1 = require("tsyringe");
const symbolTranslator_1 = require("../util/symbolTranslator");
class WorkspaceSymbolProvider {
    constructor() {
        this.workspaceSymbolRequest = (param) => {
            this.connection.console.info(`Workspace Symbols were requested`);
            const symbolInformationMap = new Map();
            this.programs.forEach((program) => {
                program.getSourceFiles().forEach((sourceFile) => {
                    if (!sourceFile.writeable) {
                        return;
                    }
                    const traverse = (node) => {
                        if (this.isPatternInSymbol(param.query, node.text)) {
                            const symbolInformation = symbolTranslator_1.SymbolInformationTranslator.translateNodeToSymbolInformation(sourceFile.uri, node);
                            if (symbolInformation) {
                                const current = symbolInformationMap.get(sourceFile.uri) || [];
                                symbolInformationMap.set(sourceFile.uri, [
                                    ...current,
                                    symbolInformation,
                                ]);
                            }
                        }
                        for (const childNode of node.children) {
                            traverse(childNode);
                        }
                    };
                    // skip URIs already traversed in a previous Elm workspace
                    if (sourceFile && !symbolInformationMap.get(sourceFile.uri)) {
                        traverse(sourceFile.tree.rootNode);
                    }
                });
            });
            return Array.from(symbolInformationMap.values()).flat();
        };
        this.programs = tsyringe_1.container.resolve("ElmWorkspaces");
        this.connection = tsyringe_1.container.resolve("Connection");
        this.connection.onWorkspaceSymbol(this.workspaceSymbolRequest);
    }
    // Determines if typed string matches a symbol
    // name. Characters must appear in order.
    // Return true if all typed characters are in symbol
    isPatternInSymbol(typedValue, symbolName) {
        const typedLower = typedValue.toLocaleLowerCase();
        const symbolLower = symbolName.toLocaleLowerCase();
        const typedLength = typedLower.length;
        const symbolLength = symbolLower.length;
        let typedPos = 0;
        let symbolPos = 0;
        while (typedPos < typedLength && symbolPos < symbolLength) {
            if (typedLower[typedPos] === symbolLower[symbolPos]) {
                typedPos += 1;
            }
            symbolPos += 1;
        }
        return typedPos === typedLength;
    }
}
exports.WorkspaceSymbolProvider = WorkspaceSymbolProvider;
//# sourceMappingURL=workspaceSymbolProvider.js.map