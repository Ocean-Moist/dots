"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InferenceScope = exports.nthVarName = exports.getVarNames = exports.getTypeclassName = exports.uncurryFunction = exports.curryFunction = exports.TInProgressBinding = exports.TUnit = exports.TList = exports.TUnknown = exports.TMutableRecord = exports.TRecord = exports.TTuple = exports.TFunction = exports.TVar = exports.TUnion = exports.resetInferTime = exports.inferTime = void 0;
const treeUtils_1 = require("../common/util/treeUtils");
const references_1 = require("./references");
const operatorPrecedence_1 = require("./operatorPrecedence");
const disjointSet_1 = require("./utils/disjointSet");
const typeReplacement_1 = require("./typeReplacement");
const expressionTree_1 = require("./utils/expressionTree");
const syntaxNodeMap_1 = require("./utils/syntaxNodeMap");
const typeExpression_1 = require("./typeExpression");
const sequence_1 = require("../common/util/sequence");
const utils_1 = require("../common/util/utils");
const recordFieldReferenceTable_1 = require("./utils/recordFieldReferenceTable");
const perf_hooks_1 = require("perf_hooks");
const diagnostics_1 = require("./diagnostics");
const elmUtils_1 = require("./utils/elmUtils");
const patternMatches_1 = require("./patternMatches");
exports.inferTime = 0;
function resetInferTime() {
    exports.inferTime = 0;
}
exports.resetInferTime = resetInferTime;
const TUnion = (module, name, params, alias) => {
    return { nodeType: "Union", module, name, params, alias };
};
exports.TUnion = TUnion;
const TVar = (name, rigid = false) => {
    return { nodeType: "Var", name, rigid };
};
exports.TVar = TVar;
const TFunction = (params, ret, alias) => {
    return { nodeType: "Function", params, return: ret, alias };
};
exports.TFunction = TFunction;
const TTuple = (types, alias) => {
    if (types.length === 0) {
        throw new Error("Cannot create a TTuple with no types, use TUnit");
    }
    return { nodeType: "Tuple", types, alias };
};
exports.TTuple = TTuple;
const TRecord = (fields, baseType, alias, fieldReferences = new recordFieldReferenceTable_1.RecordFieldReferenceTable()) => {
    return {
        nodeType: "Record",
        fields,
        baseType,
        alias,
        fieldReferences,
    };
};
exports.TRecord = TRecord;
const TMutableRecord = (fields, baseType, fieldReferences = new recordFieldReferenceTable_1.RecordFieldReferenceTable()) => {
    return {
        nodeType: "MutableRecord",
        fields,
        baseType,
        fieldReferences,
    };
};
exports.TMutableRecord = TMutableRecord;
function mutableRecordAsRecord(mutableRecord) {
    return {
        nodeType: "Record",
        fields: mutableRecord.fields,
        baseType: mutableRecord.baseType,
        fieldReferences: mutableRecord.fieldReferences,
    };
}
exports.TUnknown = {
    nodeType: "Unknown",
};
const TInt = () => (0, exports.TUnion)("Basics", "Int", []);
const TFloat = () => (0, exports.TUnion)("Basics", "Float", []);
const TBool = () => (0, exports.TUnion)("Basics", "Bool", []);
const TString = () => (0, exports.TUnion)("String", "String", []);
const TChar = () => (0, exports.TUnion)("Char", "Char", []);
const TShader = () => (0, exports.TUnion)("WebGL", "Shader", [exports.TUnknown, exports.TUnknown, exports.TUnknown]);
const TList = (elementType) => (0, exports.TUnion)("List", "List", [elementType]);
exports.TList = TList;
const TNumber = () => (0, exports.TVar)("number");
exports.TUnit = {
    nodeType: "Unit",
};
exports.TInProgressBinding = {
    nodeType: "InProgressBinding",
};
const typeIsList = (t) => t.module === "List" && t.name === "List";
const typeIsInt = (t) => t.module === TInt().module && t.name === TInt().name;
const typeIsFloat = (t) => t.module === TFloat().module && t.name === TFloat().name;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const typeIsBool = (t) => t.module === TBool().module && t.name === TBool().name;
const typeIsString = (t) => t.module === TString().module && t.name === TString().name;
const typeIsChar = (t) => t.module === TChar().module && t.name === TChar().name;
function allTypeVars(type) {
    switch (type.nodeType) {
        case "Var":
            return [type];
        case "Union":
            return type.params.flatMap(allTypeVars);
        case "Function":
            return allTypeVars(type.return).concat(type.params.flatMap(allTypeVars));
        case "Tuple":
            return type.types.flatMap(allTypeVars);
        case "Record":
        case "MutableRecord": {
            return [
                ...Object.values(type.fields).flatMap(allTypeVars),
                ...(type.baseType ? allTypeVars(type.baseType) : []),
            ];
        }
        case "Unknown":
        case "Unit":
        case "InProgressBinding":
            return [];
    }
}
function anyTypeVar(type, predicate) {
    var _a;
    let result = false;
    switch (type.nodeType) {
        case "Var":
            result = predicate(type);
            break;
        case "Tuple":
            result = type.types.some((param) => anyTypeVar(param, predicate));
            break;
        case "Union":
            result = type.params.some((param) => anyTypeVar(param, predicate));
            break;
        case "Function":
            result =
                anyTypeVar(type.return, predicate) ||
                    type.params.some((param) => anyTypeVar(param, predicate));
            break;
        case "Record":
        case "MutableRecord":
            result =
                Object.values(type.fields).some((field) => anyTypeVar(field, predicate)) || (type.baseType ? anyTypeVar(type.baseType, predicate) : false);
            break;
        case "Unit":
        case "Unknown":
        case "InProgressBinding":
            result = false;
            break;
    }
    return (result ||
        ((_a = type.alias) === null || _a === void 0 ? void 0 : _a.parameters.some((param) => anyTypeVar(param, predicate))) ===
            true);
}
/**
 * Curry function helper
 * @param func The function type to curry
 * @param count The number params to partially apply
 */
function curryFunction(func, count) {
    if (count < func.params.length) {
        return (0, exports.TFunction)(func.params.slice(count), func.return);
    }
    else {
        return func.return;
    }
}
exports.curryFunction = curryFunction;
/**
 * Uncurry function helper
 * @param func The function type to uncurry
 */
function uncurryFunction(func) {
    if (func.return.nodeType === "Function") {
        return (0, exports.TFunction)([...func.params, ...func.return.params], func.return.return);
    }
    else {
        return func;
    }
}
exports.uncurryFunction = uncurryFunction;
function getParentPatternDeclaration(ref) {
    const parentPattern = (0, expressionTree_1.mapSyntaxNodeToExpression)(treeUtils_1.TreeUtils.findParentOfType("value_declaration", ref));
    if ((parentPattern === null || parentPattern === void 0 ? void 0 : parentPattern.nodeType) !== "ValueDeclaration") {
        throw new Error(`Failed to get parent pattern declaration`);
    }
    return parentPattern.pattern ? parentPattern : undefined;
}
function getTypeclassName(type) {
    // Alias typeclasses aren't respected: https://github.com/elm/compiler/issues/2225
    if (type.name.length < 6 || type.alias) {
        return;
    }
    else if (type.name.startsWith("number")) {
        return "number";
    }
    else if (type.name.startsWith("appendable")) {
        return "appendable";
    }
    else if (type.name.startsWith("comparable")) {
        return "comparable";
    }
    else if (type.name.startsWith("compappend")) {
        return "compappend";
    }
}
exports.getTypeclassName = getTypeclassName;
const VAR_LETTERS = "abcdefghijklmnopqrstuvwxyz";
function getVarNames(count) {
    const names = [];
    const length = VAR_LETTERS.length;
    for (let i = 0; i < count; i++) {
        const letter = VAR_LETTERS[i % length];
        if (i < length) {
            names.push(letter);
        }
        else {
            names.push(`${letter}${Math.floor(i / length)}`);
        }
    }
    return names;
}
exports.getVarNames = getVarNames;
function nthVarName(n) {
    return getVarNames(n)[n - 1];
}
exports.nthVarName = nthVarName;
function typeMismatchError(checker, node, found, expected, endNode, patternBinding = false, recordDiff) {
    const foundText = checker.typeToString(found);
    const expectedText = checker.typeToString(expected);
    const diagnostic = patternBinding
        ? (0, diagnostics_1.error)(node, diagnostics_1.Diagnostics.InvalidPattern, expectedText, foundText)
        : (0, diagnostics_1.error)(node, diagnostics_1.Diagnostics.TypeMismatch, expectedText, foundText);
    const recordDiffText = (diff) => {
        let s = "";
        if (diff.extra.size > 0) {
            s += `\nExtra fields: \`${checker.typeToString((0, exports.TRecord)(Object.fromEntries(diff.extra.entries())))}\``;
        }
        if (diff.missing.size > 0) {
            s += `\nMissing fields: \`${checker.typeToString((0, exports.TRecord)(Object.fromEntries(diff.missing.entries())))}\``;
        }
        if (diff.mismatched.size > 0) {
            s += `\nMismatched fields: `;
            diff.mismatched.forEach(([found, expected], field) => {
                s += `\n Field \`${field}\` expected \`${checker.typeToString(expected)}\`, found \`${checker.typeToString(found)}\``;
            });
        }
        return s;
    };
    if (recordDiff) {
        diagnostic.message += recordDiffText(recordDiff);
    }
    return diagnostic;
}
function parameterCountError(node, endNode, actual, expected, isType = false) {
    var _a, _b;
    const name = (_b = (_a = node.firstNamedChild) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : "";
    return (0, diagnostics_1.errorWithEndNode)(node, diagnostics_1.Diagnostics.ParameterCountError, endNode, isType ? "type" : "function", name, expected, actual);
}
function argumentCountError(node, endNode, actual, expected, isType = false) {
    var _a;
    if (expected === 0 && !isType) {
        const name = (_a = node.firstNamedChild) === null || _a === void 0 ? void 0 : _a.text;
        return (0, diagnostics_1.errorWithEndNode)(node, diagnostics_1.Diagnostics.ArgumentCount, endNode, name !== null && name !== void 0 ? name : "This value", actual);
    }
    else {
        return parameterCountError(node, endNode, actual, expected, isType);
    }
}
const RecordDiff = (extra, missing, mismatched) => {
    return {
        extra,
        missing,
        mismatched,
        isEmpty: extra.size === 0 && missing.size === 0 && mismatched.size === 0,
    };
};
class InferenceScope {
    constructor(uri, program, nonShadowableNames, activeScopes, recursionAllowed, cancellationToken, parent) {
        var _a, _b;
        this.uri = uri;
        this.program = program;
        this.nonShadowableNames = nonShadowableNames;
        this.activeScopes = activeScopes;
        this.recursionAllowed = recursionAllowed;
        this.cancellationToken = cancellationToken;
        this.parent = parent;
        this.expressionTypes = new syntaxNodeMap_1.SyntaxNodeMap();
        this.diagnostics = [];
        this.bindings = new syntaxNodeMap_1.SyntaxNodeMap();
        this.annotationVars = [];
        this.childDeclarations = new Set();
        this.recordDiffs = new syntaxNodeMap_1.SyntaxNodeMap();
        this.replacements = (_a = parent === null || parent === void 0 ? void 0 : parent.replacements) !== null && _a !== void 0 ? _a : new disjointSet_1.DisjointSet();
        this.resolvedDeclarations =
            (_b = parent === null || parent === void 0 ? void 0 : parent.resolvedDeclarations) !== null && _b !== void 0 ? _b : new syntaxNodeMap_1.SyntaxNodeMap();
        this.ancestors = new sequence_1.Sequence(this, (scope) => scope.parent);
        this.typeChecker = program.getTypeChecker();
    }
    getBinding(e) {
        return this.ancestors
            .map((a) => a.bindings.get(e))
            .find(utils_1.Utils.notUndefined);
    }
    static valueDeclarationInference(declaration, uri, program, activeScopes, recursionAllowed = false, cancellationToken) {
        var _a, _b, _c;
        const nonShadowableNames = (_b = new Set((_a = program.getSourceFile(uri)) === null || _a === void 0 ? void 0 : _a.nonShadowableNames)) !== null && _b !== void 0 ? _b : new Set();
        const setter = () => new InferenceScope(uri, program, nonShadowableNames, new Set(activeScopes.values()), recursionAllowed, cancellationToken).inferDeclaration(declaration, true);
        const start = perf_hooks_1.performance.now();
        try {
            if (!((_c = program.getSourceFile(uri)) === null || _c === void 0 ? void 0 : _c.writeable)) {
                return program
                    .getTypeCache()
                    .getOrSet("PACKAGE_VALUE_DECLARATION", declaration, setter);
            }
            else {
                return program
                    .getTypeCache()
                    .getOrSet("PROJECT_VALUE_DECLARATION", declaration, setter);
            }
        }
        finally {
            exports.inferTime += perf_hooks_1.performance.now() - start;
        }
    }
    inferDeclaration(declaration, replaceExpressionTypes) {
        this.activeScopes.add(declaration);
        // Bind the parameters so the body can reference them
        const binding = this.bindParameters(declaration);
        // If there is a pattern, it gets inferred in the parameter binding
        if (declaration.pattern) {
            return this.toTopLevelResult(exports.TUnknown);
        }
        let bodyType = exports.TUnknown;
        if (declaration.body) {
            const mappedBody = (0, expressionTree_1.mapSyntaxNodeToExpression)(declaration.body);
            bodyType = this.infer(mappedBody);
            // Make sure the returned type is what is annotated
            if (binding.bindingType === "Annotated") {
                const bindingType = binding.type;
                const expected = bindingType.nodeType === "Function"
                    ? curryFunction(bindingType, binding.count)
                    : bindingType;
                this.isAssignable(mappedBody, bodyType, expected);
            }
            else {
                this.checkTopLevelCaseBranches(mappedBody, bodyType);
            }
        }
        const type = binding.bindingType === "Annotated"
            ? binding.type
            : binding.bindingType === "Unannotated"
                ? binding.count === 0
                    ? bodyType
                    : uncurryFunction((0, exports.TFunction)(binding.params, bodyType))
                : bodyType;
        return this.toTopLevelResult(type, replaceExpressionTypes);
    }
    checkTopLevelCaseBranches(expr, exprType) {
        if (expr.nodeType === "CaseOfExpr") {
            this.isBranchesAssignable(expr, exprType, exports.TUnknown);
        }
    }
    checkRecursion(declaration) {
        var _a, _b;
        let scopes = Array.from(this.activeScopes.values());
        const index = scopes.findIndex((decl) => decl.id === declaration.id);
        const isRecursive = index >= 0;
        if (isRecursive) {
            // We only want scopes in the recursion loop
            scopes = scopes.slice(index);
        }
        // Handle top level declaration recursion
        if (isRecursive &&
            !this.recursionAllowed &&
            ((_a = declaration.parent) === null || _a === void 0 ? void 0 : _a.type) === "file") {
            const callChain = scopes.filter((decl) => { var _a, _b; return ((_a = decl.parent) === null || _a === void 0 ? void 0 : _a.id) === ((_b = declaration.parent) === null || _b === void 0 ? void 0 : _b.id); });
            if (callChain.every((decl) => decl.params.length === 0)) {
                const mapped = callChain.map((decl) => { var _a, _b, _c; return (_c = (_b = (_a = decl.firstNamedChild) === null || _a === void 0 ? void 0 : _a.firstNamedChild) === null || _b === void 0 ? void 0 : _b.text) !== null && _c !== void 0 ? _c : ""; });
                this.diagnostics.push((0, diagnostics_1.error)(declaration.firstNamedChild, diagnostics_1.Diagnostics.RecursiveDeclaration(mapped.length), ...mapped));
            }
        }
        // Handle let recursion
        if (isRecursive && ((_b = declaration.parent) === null || _b === void 0 ? void 0 : _b.type) === "let_in_expr") {
            const callChain = scopes
                .filter((decl) => { var _a, _b; return ((_a = decl.parent) === null || _a === void 0 ? void 0 : _a.id) === ((_b = declaration.parent) === null || _b === void 0 ? void 0 : _b.id); })
                .reverse();
            const recursiveLet = callChain.find((decl) => decl.params.length === 0);
            if (recursiveLet === null || recursiveLet === void 0 ? void 0 : recursiveLet.firstNamedChild) {
                const reversed = callChain
                    .reverse()
                    .map((decl) => { var _a, _b, _c; return (_c = (_b = (_a = decl.firstNamedChild) === null || _a === void 0 ? void 0 : _a.firstNamedChild) === null || _b === void 0 ? void 0 : _b.text) !== null && _c !== void 0 ? _c : ""; });
                const rotated = utils_1.Utils.rotateArray(reversed, reversed.indexOf(recursiveLet.firstNamedChild.text));
                this.diagnostics.push((0, diagnostics_1.error)(recursiveLet.firstNamedChild, diagnostics_1.Diagnostics.RecursiveLet(callChain.length), ...rotated));
            }
        }
        return isRecursive;
    }
    toTopLevelResult(type, replaceExpressionTypes = true) {
        if (replaceExpressionTypes) {
            this.expressionTypes.mapValues((val) => {
                const result = typeReplacement_1.TypeReplacement.replace(val, this.replacements.toMap());
                typeReplacement_1.TypeReplacement.freeze(result);
                return result;
            });
        }
        const outerVars = this.ancestors
            .toArray()
            .slice(1)
            .flatMap((a) => a.annotationVars);
        const ret = typeReplacement_1.TypeReplacement.replace(type, this.replacements.toMap(), false, outerVars);
        if (replaceExpressionTypes) {
            typeReplacement_1.TypeReplacement.freeze(ret);
        }
        return {
            expressionTypes: this.expressionTypes,
            diagnostics: this.diagnostics,
            type: ret,
            recordDiffs: this.recordDiffs,
        };
    }
    infer(e) {
        var _a;
        let type = exports.TUnknown;
        (_a = this.cancellationToken) === null || _a === void 0 ? void 0 : _a.throwIfCancellationRequested();
        switch (e.nodeType) {
            case "AnonymousFunctionExpr":
                type = this.inferLambda(e);
                break;
            case "BinOpExpr":
                type = this.inferBinOpExpr(e);
                break;
            case "CaseOfExpr":
                type = this.inferCase(e);
                break;
            case "CharConstantExpr":
                type = TChar();
                break;
            case "FieldAccessExpr":
                type = this.inferFieldAccess(e);
                break;
            case "FieldAccessorFunctionExpr":
                type = this.inferFieldAccessorFunctionExpr(e);
                break;
            case "FunctionCallExpr":
                type = this.inferFunctionCallExpr(e);
                break;
            case "GlslCodeExpr":
                type = TShader();
                break;
            case "IfElseExpr":
                type = this.inferIfElse(e);
                break;
            case "LetInExpr":
                type = this.inferChild((inference) => inference.letInInference(e)).type;
                break;
            case "ListExpr":
                type = this.inferList(e);
                break;
            case "NegateExpr":
                type = this.inferNegateExpr(e);
                break;
            case "NumberConstant":
                type = e.isFloat ? TFloat() : TNumber();
                break;
            case "OperatorAsFunctionExpr":
                type = this.inferOperatorAsFunctionExpr(e);
                break;
            case "RecordExpr":
                type = this.inferRecord(e);
                break;
            case "StringConstant":
                type = TString();
                break;
            case "TupleExpr":
                type = (0, exports.TTuple)(e.exprList.map((expr) => this.infer(expr)));
                break;
            case "UnitExpr":
                type = exports.TUnit;
                break;
            case "ValueExpr":
                type = this.inferReferenceElement(e);
                break;
            default:
                throw new Error("Unexpected Expression type");
        }
        this.expressionTypes.set(e, type);
        return type;
    }
    lambdaInference(lamba) {
        const paramVars = this.uniqueVars(lamba.params.length);
        lamba.params.forEach((p, i) => this.bindPattern(p, paramVars[i], true));
        const bodyType = this.infer(lamba.expr);
        this.checkTopLevelCaseBranches(lamba.expr, bodyType);
        return {
            expressionTypes: this.expressionTypes,
            diagnostics: this.diagnostics,
            type: uncurryFunction((0, exports.TFunction)(paramVars, bodyType)),
            recordDiffs: this.recordDiffs,
        };
    }
    letInInference(letInExpr) {
        const valueDeclarations = letInExpr.valueDeclarations;
        valueDeclarations.forEach((v) => this.childDeclarations.add(v));
        valueDeclarations.forEach((declaration) => {
            if (!this.resolvedDeclarations.has(declaration)) {
                this.inferChildDeclaration(declaration);
            }
        });
        const bodyType = this.infer(letInExpr.body);
        this.checkTopLevelCaseBranches(letInExpr.body, bodyType);
        return {
            expressionTypes: this.expressionTypes,
            diagnostics: this.diagnostics,
            type: bodyType,
            recordDiffs: this.recordDiffs,
        };
    }
    caseBranchInference(pattern, caseType, branchExpr) {
        this.bindPattern(pattern, caseType, false);
        const type = this.infer(branchExpr);
        return {
            expressionTypes: this.expressionTypes,
            diagnostics: this.diagnostics,
            type,
            recordDiffs: this.recordDiffs,
        };
    }
    inferChild(callback, activeScopes = new Set(this.activeScopes.values()), recursionAllowed = this.recursionAllowed) {
        const result = callback(new InferenceScope(this.uri, this.program, new Set(this.nonShadowableNames.values()), activeScopes, recursionAllowed, this.cancellationToken, this));
        this.diagnostics.push(...result.diagnostics);
        result.recordDiffs.forEach((val, key) => this.recordDiffs.set(key, val));
        result.expressionTypes.forEach((val, key) => this.expressionTypes.set(key, val));
        return result;
    }
    inferChildDeclaration(declaration, activeScopes = this.activeScopes) {
        var _a, _b;
        const result = this.inferChild((inference) => inference.inferDeclaration(declaration, false), new Set(activeScopes.values()), 
        /* recursionAllowed */ declaration.params.length > 0);
        this.resolvedDeclarations.set(declaration, result.type);
        this.expressionTypes.set(declaration, result.type);
        const funcName = (_a = treeUtils_1.TreeUtils.getFunctionNameNodeFromDefinition(declaration)) === null || _a === void 0 ? void 0 : _a.text;
        if (funcName) {
            this.nonShadowableNames.add(funcName);
        }
        else {
            const pattern = declaration.pattern;
            if (pattern) {
                const patterns = (_b = pattern
                    .descendantsOfType("lower_pattern")) === null || _b === void 0 ? void 0 : _b.map(expressionTree_1.mapSyntaxNodeToExpression).filter(utils_1.Utils.notUndefined);
                patterns === null || patterns === void 0 ? void 0 : patterns.forEach((pat) => {
                    const patType = result.expressionTypes.get(pat);
                    if (patType) {
                        this.setBinding(pat, patType);
                    }
                    this.nonShadowableNames.add(pat.text);
                });
            }
        }
        return result;
    }
    inferList(expr) {
        const exprTypes = expr.exprList.map((e) => this.infer(e));
        const elementType = (0, exports.TVar)("a");
        for (let i = 0; i < expr.exprList.length; i++) {
            if (this.isAssignable(expr.exprList[i], exprTypes[i], elementType)) {
                this.expressionTypes.set(expr.exprList[i], elementType);
            }
            else {
                break;
            }
        }
        return (0, exports.TList)(elementType);
    }
    inferIfElse(ifElseExpr) {
        const exprList = ifElseExpr.exprList;
        // Check for incomplete program
        if (exprList.length < 3 || exprList.length % 2 == 0) {
            return exports.TUnknown;
        }
        const exprTypes = exprList.map((e) => this.infer(e));
        // Check all conditions are type Bool
        for (let i = 0; i < exprList.length - 1; i += 2) {
            this.isAssignable(exprList[i], exprTypes[i], TBool());
        }
        // Check that all branches match the first one
        for (let i = 0; i < exprList.length; i++) {
            if (i != exprList.length - 1 && (i < 3 || i % 2 == 0)) {
                continue;
            }
            if (!this.isAssignable(exprList[i], exprTypes[i], exprTypes[1])) {
                break;
            }
        }
        return exprTypes[1];
    }
    inferReferenceElement(e) {
        var _a, _b;
        let definition = (0, expressionTree_1.findDefinition)((_a = e.firstNamedChild) === null || _a === void 0 ? void 0 : _a.lastNamedChild, this.program);
        if (!definition.expr && definition.diagnostics.length === 0) {
            definition = (0, expressionTree_1.findDefinition)(e.firstNamedChild, this.program);
        }
        this.diagnostics.push(...definition.diagnostics);
        if (!definition.expr) {
            const sourceFile = this.program.getSourceFile(e.tree.uri);
            if ((0, elmUtils_1.nameIsKernel)(e.text) &&
                sourceFile &&
                (0, elmUtils_1.isKernelProject)(sourceFile.project)) {
                return exports.TUnknown;
            }
            if (definition.diagnostics.length === 0) {
                this.diagnostics.push((0, diagnostics_1.error)(e, diagnostics_1.Diagnostics.MissingValue, e.text));
            }
            return (0, exports.TVar)("a");
        }
        const binding = this.getBinding(definition.expr);
        if (binding) {
            if (binding.nodeType === "InProgressBinding") {
                this.diagnostics.push((0, diagnostics_1.error)(e, diagnostics_1.Diagnostics.CyclicDefinition));
                return exports.TUnknown;
            }
            else {
                return binding;
            }
        }
        switch (definition.expr.nodeType) {
            case "FunctionDeclarationLeft": {
                const valueDeclaration = (0, expressionTree_1.mapSyntaxNodeToExpression)(treeUtils_1.TreeUtils.findParentOfType("value_declaration", definition.expr));
                if ((valueDeclaration === null || valueDeclaration === void 0 ? void 0 : valueDeclaration.nodeType) !== "ValueDeclaration") {
                    throw new Error("Could not find parent value declaration");
                }
                return this.inferReferencedValueDeclaration(valueDeclaration);
            }
            case "LowerPattern": {
                const parentPattern = getParentPatternDeclaration(definition.expr);
                if (parentPattern) {
                    this.inferReferencedValueDeclaration(parentPattern);
                    const binding = this.getBinding(definition.expr);
                    if (binding) {
                        return binding;
                    }
                    else {
                        throw new Error("Failed to destructure pattern");
                    }
                }
                throw new Error("Failed to bind pattern");
            }
            case "UnionVariant": {
                return typeExpression_1.TypeExpression.unionVariantInference(definition.expr, this.program).type;
            }
            case "TypeAliasDeclaration": {
                const ty = typeExpression_1.TypeExpression.typeAliasDeclarationInference(definition.expr, this.program).type;
                if (ty.nodeType === "Record" && Object.keys(ty.fields).length > 0) {
                    return (0, exports.TFunction)(Object.values(ty.fields), ty);
                }
                else {
                    return ty;
                }
            }
            case "FieldType": {
                const typeAlias = (0, expressionTree_1.mapSyntaxNodeToExpression)(treeUtils_1.TreeUtils.findParentOfType("type_alias_declaration", definition.expr));
                if (typeAlias && typeAlias.nodeType === "TypeAliasDeclaration") {
                    const fields = (_b = typeExpression_1.TypeExpression.typeAliasDeclarationInference(typeAlias, this.program).type) === null || _b === void 0 ? void 0 : _b.fields;
                    if (fields) {
                        return fields[definition.expr.text];
                    }
                }
                return exports.TUnknown;
            }
            case "PortAnnotation": {
                return typeExpression_1.TypeExpression.portAnnotationInference(definition.expr, this.program).type;
            }
            default:
                throw new Error("Unexpected reference type");
        }
    }
    inferReferencedValueDeclaration(declaration) {
        var _a;
        if (!declaration) {
            return exports.TUnknown;
        }
        const recursive = this.checkRecursion(declaration);
        const existing = this.resolvedDeclarations.get(declaration);
        if (existing) {
            return typeReplacement_1.TypeReplacement.freshenVars(existing);
        }
        let type;
        // Get the type annotation if there is one
        if (declaration.typeAnnotation) {
            type = (_a = typeExpression_1.TypeExpression.typeAnnotationInference((0, expressionTree_1.mapSyntaxNodeToExpression)(declaration.typeAnnotation), this.program, false)) === null || _a === void 0 ? void 0 : _a.type;
        }
        if (!type) {
            // Don't try to infer unannotated recursive functions
            if (recursive) {
                return exports.TUnknown;
            }
            const parentScope = this.ancestors.find((scope) => !!Array.from(scope.childDeclarations.values()).find((child) => child.id === declaration.id));
            type = !parentScope
                ? InferenceScope.valueDeclarationInference(declaration, declaration.tree.uri, this.program, this.activeScopes, this.recursionAllowed, this.cancellationToken).type
                : parentScope.inferChildDeclaration(declaration, this.activeScopes)
                    .type;
        }
        this.resolvedDeclarations.set(declaration, type);
        return type;
    }
    inferFunctionCallExpr(e) {
        const targetType = this.infer(e.target);
        const argTypes = e.args.map((arg) => this.infer(arg));
        const argCountError = (expr, endExpr, actual, expected) => {
            this.diagnostics.push(argumentCountError(expr, endExpr, actual, expected));
            return exports.TUnknown;
        };
        if (targetType.nodeType === "Var") {
            const type = (0, exports.TFunction)(argTypes, (0, exports.TVar)("a"));
            if (this.isAssignable(e.target, targetType, type)) {
                return type.return;
            }
            else {
                return exports.TUnknown;
            }
        }
        if (targetType.nodeType === "Unknown") {
            const type = (0, exports.TFunction)(argTypes, (0, exports.TVar)("a"));
            if (this.isAssignable(e.target, targetType, type)) {
                this.expressionTypes.set(e.target, type);
                return type.return;
            }
            else {
                return exports.TUnknown;
            }
        }
        if (targetType.nodeType !== "Function") {
            return argCountError(e, e, e.args.length, 0);
        }
        let allAssignable = true;
        // Make sure each arg is assignable to the inferred type
        for (let i = 0; i < Math.min(e.args.length, targetType.params.length); i++) {
            allAssignable =
                this.isAssignable(e.args[i], argTypes[i], targetType.params[i]) &&
                    allAssignable;
        }
        if (allAssignable && e.args.length > targetType.params.length) {
            let appliedType = typeReplacement_1.TypeReplacement.replace(targetType.return, this.replacements.toMap());
            if (appliedType.nodeType !== "Function") {
                return argCountError(e, e, e.args.length, targetType.params.length);
            }
            for (let i = targetType.params.length; i < e.args.length; i++) {
                if (appliedType.nodeType !== "Function") {
                    return argCountError(e.target, e.args[i], 1, 0);
                }
                if (!this.isAssignable(e.args[i], argTypes[i], appliedType.params[0])) {
                    return exports.TUnknown;
                }
                appliedType = typeReplacement_1.TypeReplacement.replace(curryFunction(appliedType, 1), this.replacements.toMap());
            }
            this.expressionTypes.set(e, appliedType);
            return appliedType;
        }
        const resultType = allAssignable
            ? typeReplacement_1.TypeReplacement.replace(curryFunction(targetType, e.args.length), this.replacements.toMap(), true)
            : exports.TUnknown;
        this.expressionTypes.set(e, resultType);
        return resultType;
    }
    inferBinOpExpr(e) {
        const operatorPrecedences = new syntaxNodeMap_1.SyntaxNodeMap();
        const operatorTypes = new syntaxNodeMap_1.SyntaxNodeMap();
        let lastPrecedence;
        for (const part of e.parts) {
            if (part.nodeType === "Operator") {
                const [type, precedence] = this.inferOperatorAndPrecedence(part);
                if (type.nodeType !== "Function" || type.params.length < 2) {
                    throw new Error("Could not find operator function");
                }
                if (precedence.associativity === "NON" &&
                    (lastPrecedence === null || lastPrecedence === void 0 ? void 0 : lastPrecedence.associativity) === "NON") {
                    this.diagnostics.push((0, diagnostics_1.error)(e, diagnostics_1.Diagnostics.NonAssociativeOperator));
                    return exports.TUnknown;
                }
                operatorPrecedences.set(part, precedence);
                operatorTypes.set(part, type);
                lastPrecedence = precedence;
            }
        }
        const validateTree = (tree) => {
            switch (tree.type) {
                case "Operand": {
                    const operandTree = tree;
                    const type = this.inferOperand(operandTree.operand);
                    return { start: operandTree.operand, end: operandTree.operand, type };
                }
                case "Binary": {
                    const binaryTree = tree;
                    const left = validateTree(binaryTree.left);
                    const right = validateTree(binaryTree.right);
                    const func = operatorTypes.get(binaryTree.operator);
                    if (!func) {
                        throw new Error("Missing function type for operator");
                    }
                    const leftAssignable = this.isAssignable(left.start, left.type, func.params[0], left.end);
                    const rightAssignable = this.isAssignable(right.start, right.type, func.params[1], right.end);
                    const type = leftAssignable && rightAssignable
                        ? typeReplacement_1.TypeReplacement.replace(curryFunction(func, 2), this.replacements.toMap(), true)
                        : exports.TUnknown;
                    return { start: left.start, end: right.end, type };
                }
            }
        };
        const result = validateTree(operatorPrecedence_1.BinaryExprTree.parse(e.parts, operatorPrecedences));
        this.expressionTypes.set(e, result.type);
        return result.type;
    }
    inferOperand(e) {
        if (e.nodeType === "FunctionCallExpr") {
            return this.inferFunctionCallExpr(e);
        }
        return this.infer(e);
    }
    inferOperatorAndPrecedence(e) {
        var _a;
        // Find operator reference
        const definition = (0, expressionTree_1.findDefinition)(e, this.program);
        const opDeclaration = (0, expressionTree_1.mapSyntaxNodeToExpression)((_a = definition.expr) === null || _a === void 0 ? void 0 : _a.parent);
        const infixDeclarationExpr = (0, expressionTree_1.mapSyntaxNodeToExpression)(opDeclaration
            ? references_1.References.findOperator(opDeclaration, this.program)
            : undefined);
        if ((opDeclaration === null || opDeclaration === void 0 ? void 0 : opDeclaration.nodeType) !== "ValueDeclaration" ||
            (infixDeclarationExpr === null || infixDeclarationExpr === void 0 ? void 0 : infixDeclarationExpr.nodeType) !== "InfixDeclaration" ||
            !definition) {
            return [exports.TUnknown, { precedence: 0, associativity: "NON" }];
        }
        const type = this.inferReferencedValueDeclaration(opDeclaration);
        this.expressionTypes.set(e, type);
        return [
            type,
            {
                precedence: infixDeclarationExpr.precedence,
                associativity: infixDeclarationExpr.associativity,
            },
        ];
    }
    inferFieldAccessorFunctionExpr(accessor) {
        var _a, _b;
        const field = (_b = (_a = treeUtils_1.TreeUtils.findFirstNamedChildOfType("lower_case_identifier", accessor)) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : "";
        const typeVar = (0, exports.TVar)("b");
        return (0, exports.TFunction)([(0, exports.TMutableRecord)({ [field]: typeVar }, (0, exports.TVar)("a"))], typeVar);
    }
    inferNegateExpr(negateExpr) {
        const exprType = this.infer(negateExpr.expression);
        if (this.isAssignable(negateExpr.expression, exprType, TNumber())) {
            return exprType;
        }
        else {
            return exports.TUnknown;
        }
    }
    inferOperatorAsFunctionExpr(operatorFunction) {
        var _a;
        // Find operator reference
        const definition = (0, expressionTree_1.findDefinition)(operatorFunction.operator, this.program);
        const opDeclaration = (0, expressionTree_1.mapSyntaxNodeToExpression)((_a = definition.expr) === null || _a === void 0 ? void 0 : _a.parent);
        if ((opDeclaration === null || opDeclaration === void 0 ? void 0 : opDeclaration.nodeType) === "ValueDeclaration" && (definition === null || definition === void 0 ? void 0 : definition.expr)) {
            return this.inferReferencedValueDeclaration(opDeclaration);
        }
        else {
            return exports.TUnknown;
        }
    }
    inferFieldAccess(expr) {
        var _a;
        const targetType = this.inferFieldAccessTarget(expr.target);
        const targetTy = this.replacements.get(targetType);
        const fieldIdentifier = treeUtils_1.TreeUtils.findFirstNamedChildOfType("lower_case_identifier", expr);
        if (!fieldIdentifier) {
            return exports.TUnknown;
        }
        const fieldIdentifierText = fieldIdentifier.text;
        if (fieldIdentifierText === "") {
            return exports.TUnknown;
        }
        if ((targetTy === null || targetTy === void 0 ? void 0 : targetTy.nodeType) === "Var") {
            if (targetTy.rigid) {
                const typeString = this.program.getTypeChecker().typeToString(targetTy);
                this.diagnostics.push((0, diagnostics_1.error)(expr.target, diagnostics_1.Diagnostics.RecordBaseId, typeString));
                return exports.TUnknown;
            }
            const type = (0, exports.TVar)("b");
            this.trackReplacement(targetType, (0, exports.TMutableRecord)({ [fieldIdentifierText]: type }, (0, exports.TVar)("a")));
            this.expressionTypes.set(expr, type);
            return type;
        }
        if ((targetTy === null || targetTy === void 0 ? void 0 : targetTy.nodeType) === "MutableRecord") {
            let type = targetTy.fields[fieldIdentifierText];
            if (!type) {
                targetTy.fields[fieldIdentifierText] = (0, exports.TVar)(nthVarName(Object.keys(targetTy.fields).length));
                type = targetTy.fields[fieldIdentifierText];
            }
            this.expressionTypes.set(expr, type);
            return type;
        }
        if ((targetTy === null || targetTy === void 0 ? void 0 : targetTy.nodeType) !== "Record") {
            if ((targetTy === null || targetTy === void 0 ? void 0 : targetTy.nodeType) !== "Unknown" && targetTy) {
                this.diagnostics.push((0, diagnostics_1.error)(expr.target, diagnostics_1.Diagnostics.FieldAccessOnNonRecord, this.typeChecker.typeToString(targetTy)));
            }
            return exports.TUnknown;
        }
        if (!Object.keys(targetTy.fields).includes(fieldIdentifierText)) {
            if (!targetTy.baseType) {
                this.diagnostics.push((0, diagnostics_1.error)(fieldIdentifier, diagnostics_1.Diagnostics.RecordField, fieldIdentifierText));
            }
        }
        const type = (_a = targetTy.fields[fieldIdentifierText]) !== null && _a !== void 0 ? _a : (0, exports.TVar)("a");
        this.expressionTypes.set(expr, type);
        return type;
    }
    inferFieldAccessTarget(target) {
        var _a;
        let type = exports.TUnknown;
        switch (target.nodeType) {
            case "ValueExpr":
                type = this.inferReferenceElement(target);
                break;
            case "RecordExpr":
                type = this.inferRecord(target);
                break;
            case "FieldAccessExpr":
                type = this.inferFieldAccess(target);
                break;
            default:
                if (((_a = target.parent) === null || _a === void 0 ? void 0 : _a.type) === "parenthesized_expr") {
                    type = this.infer(target);
                }
                else {
                    throw new Error("Unexpected field access target expression");
                }
        }
        this.expressionTypes.set(target, type);
        return type;
    }
    inferLambda(lambaExpr) {
        return this.inferChild((inference) => inference.lambdaInference(lambaExpr), 
        /* activeScopes */ undefined, 
        /* recursionAllowed */ true).type;
    }
    inferCase(caseOfExpr) {
        const caseOfExprType = this.infer(caseOfExpr.expr);
        let type;
        caseOfExpr.branches.forEach((branch) => {
            const result = this.inferChild((inference) => inference.caseBranchInference(branch.pattern, caseOfExprType, branch.expr));
            if (!type) {
                type = result.type;
            }
        });
        this.diagnostics.push(...patternMatches_1.PatternMatches.check(caseOfExpr, caseOfExpr.branches.map((branch) => branch.pattern), this.program));
        return type !== null && type !== void 0 ? type : exports.TUnknown;
    }
    inferRecord(record) {
        const fields = new Map(record.fields.map((field) => [field.name, this.infer(field.expression)]));
        const mappedFields = {};
        fields.forEach((type, field) => (mappedFields[field.text] = type));
        const recordIdentifier = record.baseRecord;
        if (!recordIdentifier) {
            return (0, exports.TRecord)(mappedFields);
        }
        const baseType = this.inferReferenceElement(recordIdentifier);
        if (baseType.nodeType === "Unknown") {
            return exports.TUnknown;
        }
        if (baseType.nodeType === "Var") {
            const extRecord = (0, exports.TRecord)(mappedFields, (0, exports.TVar)(baseType.name));
            if (this.isAssignable(recordIdentifier, baseType, extRecord)) {
                return extRecord;
            }
            else {
                return exports.TUnknown;
            }
        }
        let baseFields = {};
        if (baseType.nodeType === "Record" ||
            baseType.nodeType === "MutableRecord") {
            baseFields = baseType.fields;
        }
        else {
            this.diagnostics.push((0, diagnostics_1.error)(recordIdentifier, diagnostics_1.Diagnostics.RecordBaseId, this.typeChecker.typeToString(baseType)));
            return exports.TUnknown;
        }
        fields.forEach((type, field) => {
            const fieldText = field.text;
            const expected = baseFields[fieldText];
            if (!expected) {
                if (baseType.nodeType === "Record") {
                    if (!baseType.baseType) {
                        this.diagnostics.push((0, diagnostics_1.error)(field, diagnostics_1.Diagnostics.RecordField, fieldText));
                        this.recordDiffs.set(record, this.calculateRecordDiff((0, exports.TRecord)(mappedFields), baseType));
                        this.expressionTypes.set(field, type);
                    }
                }
                else if (baseType.nodeType === "MutableRecord") {
                    baseType.fields[fieldText] = type;
                }
            }
            else {
                this.isAssignable(field, type, expected);
            }
        });
        return baseType;
    }
    setBinding(expr, type) {
        const exprName = expr.text;
        if (this.nonShadowableNames.has(exprName)) {
            this.diagnostics.push((0, diagnostics_1.error)(expr, diagnostics_1.Diagnostics.Redefinition, expr.text));
        }
        this.nonShadowableNames.add(exprName);
        this.bindings.set(expr, type);
        this.expressionTypes.set(expr, type);
    }
    bindParameters(valueDeclaration) {
        const functionDeclarationLeft = (0, expressionTree_1.mapSyntaxNodeToExpression)(valueDeclaration.childForFieldName("functionDeclarationLeft"));
        if (functionDeclarationLeft) {
            return this.bindFunctionDeclarationParameters(valueDeclaration, functionDeclarationLeft);
        }
        if (valueDeclaration.pattern) {
            this.bindPatternDeclarationParameters(valueDeclaration, (0, expressionTree_1.mapSyntaxNodeToExpression)(valueDeclaration.pattern));
            return { bindingType: "Other", count: 0 };
        }
        return { bindingType: "Other", count: 0 };
    }
    bindFunctionDeclarationParameters(valueDeclaration, functionDeclaration) {
        const typeRefResult = valueDeclaration.typeAnnotation
            ? typeExpression_1.TypeExpression.typeAnnotationInference((0, expressionTree_1.mapSyntaxNodeToExpression)(valueDeclaration.typeAnnotation), this.program, true)
            : undefined;
        const patterns = functionDeclaration.params;
        if (!typeRefResult) {
            const params = this.uniqueVars(patterns.length);
            patterns.forEach((pat, i) => this.bindPattern(pat, params[i], true));
            return {
                bindingType: "Unannotated",
                params,
                count: params.length,
            };
        }
        this.diagnostics.push(...typeRefResult.diagnostics);
        const typeRefType = typeRefResult.type;
        const maxParams = typeRefType.nodeType === "Function" ? typeRefType.params.length : 0;
        if (patterns.length > maxParams) {
            this.diagnostics.push(parameterCountError(patterns[0], patterns[patterns.length - 1], patterns.length, maxParams));
            patterns.forEach((pat) => this.bindPattern(pat, exports.TUnknown, true));
            return { count: maxParams };
        }
        if (typeRefType.nodeType === "Function") {
            patterns.forEach((pat, i) => this.bindPattern(pat, typeRefType.params[i], true));
        }
        this.annotationVars = allTypeVars(typeRefType);
        return {
            bindingType: "Annotated",
            type: typeRefType,
            count: patterns.length,
        };
    }
    bindPatternDeclarationParameters(valueDeclaration, pattern) {
        // Bind all patters to a InProgressBinding type
        // so we can use them before we know the type
        const declaredNames = pattern
            .descendantsOfType("lower_pattern")
            .filter((pattern) => pattern.text !== "");
        declaredNames.forEach((name) => this.bindings.set(name, exports.TInProgressBinding));
        const bodyType = valueDeclaration.body
            ? this.infer((0, expressionTree_1.mapSyntaxNodeToExpression)(valueDeclaration.body))
            : exports.TUnknown;
        this.bindPattern(pattern, bodyType, false);
        // Make sure there are none still in progress, or else there was a mistake
        declaredNames.forEach((name) => {
            var _a;
            if (((_a = this.getBinding(name)) === null || _a === void 0 ? void 0 : _a.nodeType) === "InProgressBinding") {
                throw new Error(`Failed to bind parameter ${name.text}`);
            }
        });
    }
    bindPattern(pattern, type, isParameter) {
        var _a;
        const ty = (_a = this.replacements.get(type)) !== null && _a !== void 0 ? _a : type;
        switch (pattern.nodeType) {
            case "AnythingPattern":
                break;
            case "ConsPattern":
                if (isParameter) {
                    this.diagnostics.push((0, diagnostics_1.error)(pattern, diagnostics_1.Diagnostics.PartialPattern));
                    this.bindConsPattern(pattern, exports.TUnknown);
                }
                else {
                    this.bindConsPattern(pattern, ty);
                }
                break;
            case "LowerPattern":
                this.setBinding(pattern, ty);
                break;
            case "ListPattern":
                if (isParameter) {
                    this.bindListPattern(pattern, exports.TUnknown);
                }
                else {
                    this.bindListPattern(pattern, ty);
                }
                break;
            case "Pattern":
                {
                    const child = (0, expressionTree_1.mapSyntaxNodeToExpression)(pattern.childForFieldName("child"));
                    if (!child) {
                        throw new Error("Missing pattern child");
                    }
                    this.bindPattern(child, ty, isParameter);
                    if (pattern.patternAs) {
                        this.bindPattern(pattern.patternAs, ty, isParameter);
                    }
                }
                break;
            case "RecordPattern":
                this.bindRecordPattern(pattern, ty, isParameter);
                break;
            case "TuplePattern":
                this.bindTuplePattern(pattern, ty, isParameter);
                break;
            case "UnionPattern":
                this.bindUnionPattern(pattern, ty, isParameter);
                break;
            case "UnitExpr":
                this.isAssignable(pattern, ty, exports.TUnit, undefined, true);
                break;
            case "StringConstant":
                if (isParameter) {
                    this.diagnostics.push((0, diagnostics_1.error)(pattern, diagnostics_1.Diagnostics.PartialPattern));
                }
                this.isAssignable(pattern, ty, TString(), undefined, true);
                break;
            case "NumberConstant":
                if (isParameter) {
                    this.diagnostics.push((0, diagnostics_1.error)(pattern, diagnostics_1.Diagnostics.PartialPattern));
                }
                this.isAssignable(pattern, ty, TInt(), undefined, true);
                break;
            case "CharConstantExpr":
                if (isParameter) {
                    this.diagnostics.push((0, diagnostics_1.error)(pattern, diagnostics_1.Diagnostics.PartialPattern));
                }
                this.isAssignable(pattern, ty, TChar(), undefined, true);
                break;
            default:
                throw new Error("Unexpected pattern type: " + pattern.nodeType);
        }
    }
    bindTuplePattern(tuplePattern, type, isParameter) {
        const patterns = tuplePattern.patterns;
        const ty = this.bindIfVar(tuplePattern, type, (0, exports.TTuple)(this.uniqueVars(patterns.length)));
        if (ty.nodeType !== "Tuple" || ty.types.length !== patterns.length) {
            patterns.forEach((pat) => this.bindPattern(pat, exports.TUnknown, isParameter));
            if (ty.nodeType !== "Unknown") {
                const actualType = (0, exports.TTuple)(this.uniqueVars(patterns.length));
                this.diagnostics.push(typeMismatchError(this.program.getTypeChecker(), tuplePattern, actualType, ty, tuplePattern, true));
            }
            return;
        }
        patterns.forEach((pat, i) => {
            this.bindPattern(pat, ty.types[i], isParameter);
        });
    }
    bindUnionPattern(unionPattern, type, isParameter) {
        var _a, _b, _c, _d;
        const variant = (0, expressionTree_1.findDefinition)(unionPattern.constructor.lastNamedChild, this.program);
        if (((_a = variant.expr) === null || _a === void 0 ? void 0 : _a.nodeType) !== "UnionVariant") {
            unionPattern.namedParams.forEach((p) => this.setBinding(p, exports.TUnknown));
            this.diagnostics.push((0, diagnostics_1.error)((_b = unionPattern.constructor.lastNamedChild) !== null && _b !== void 0 ? _b : unionPattern.constructor, diagnostics_1.Diagnostics.MissingValue, (_d = (_c = unionPattern.constructor.lastNamedChild) === null || _c === void 0 ? void 0 : _c.text) !== null && _d !== void 0 ? _d : "union variant"));
            return;
        }
        const variantType = typeExpression_1.TypeExpression.unionVariantInference(variant.expr, this.program).type;
        if (!variantType || variantType.nodeType === "Unknown") {
            unionPattern.namedParams.forEach((p) => this.setBinding(p, exports.TUnknown));
            return;
        }
        const issueError = (actual, expected) => {
            this.diagnostics.push(argumentCountError(unionPattern, unionPattern, actual, expected, true));
            unionPattern.namedParams.forEach((p) => this.setBinding(p, exports.TUnknown));
        };
        if (variantType.nodeType === "Function") {
            const ty = this.bindIfVar(unionPattern, type, variantType.return);
            if (this.isAssignable(unionPattern, ty, variantType.return)) {
                if (unionPattern.argPatterns.length !== variantType.params.length) {
                    issueError(unionPattern.argPatterns.length, variantType.params.length);
                }
                else {
                    unionPattern.argPatterns.forEach((p, i) => {
                        // The other type is a nullary constructor argument pattern, which doesn't bind anything
                        if (p.type.includes("pattern") &&
                            p.nodeType !== "NullaryConstructorArgumentPattern") {
                            this.bindPattern(p, variantType.params[i], isParameter);
                        }
                    });
                }
            }
            else {
                unionPattern.namedParams.forEach((p) => this.setBinding(p, exports.TUnknown));
            }
        }
        else {
            const ty = this.bindIfVar(unionPattern, type, variantType);
            if (this.isAssignable(unionPattern, ty, variantType) &&
                unionPattern.argPatterns.length > 0) {
                issueError(unionPattern.argPatterns.length, 0);
            }
            else {
                unionPattern.namedParams.forEach((p) => this.setBinding(p, exports.TUnknown));
            }
        }
    }
    bindConsPattern(consPattern, type) {
        this.bindListPatternParts(consPattern, consPattern.parts, type, true);
    }
    bindListPattern(listPattern, type) {
        this.bindListPatternParts(listPattern, listPattern.parts, type, false);
    }
    bindListPatternParts(listPattern, parts, type, isCons) {
        const ty = this.bindIfVar(listPattern, type, (0, exports.TList)((0, exports.TVar)("a")));
        if (ty.nodeType === "Unknown" ||
            ty.nodeType !== "Union" ||
            !typeIsList(ty)) {
            if (ty.nodeType !== "Unknown") {
                this.diagnostics.push(typeMismatchError(this.program.getTypeChecker(), listPattern, (0, exports.TList)((0, exports.TVar)("a")), ty, listPattern, true));
            }
            parts.forEach((p) => this.bindPattern(p, exports.TUnknown, false));
            return;
        }
        const innerType = ty.params[0];
        parts.slice(0, parts.length - 1).forEach((part) => {
            this.bindPattern(part, innerType, false);
        });
        if (parts.length > 0) {
            this.bindPattern(parts[parts.length - 1], isCons ? ty : innerType, false);
        }
    }
    bindRecordPattern(pattern, type, isParameter) {
        var _a;
        const fields = pattern.patternList;
        const ty = this.bindIfVar(pattern, type, (0, exports.TMutableRecord)({}, (0, exports.TVar)("a")));
        const vars = this.uniqueVars(fields.length);
        if (ty.nodeType === "MutableRecord") {
            fields.forEach((field, i) => {
                const existing = ty.fields[field.text];
                if (!existing) {
                    ty.fields[field.text] = vars[i];
                }
            });
        }
        else if (ty.nodeType !== "Record" ||
            fields.some((field) => !Object.keys(ty.fields).includes(field.text))) {
            if (ty.nodeType !== "Unknown") {
                const actualTyParams = Object.fromEntries(fields.map((field, i) => [field.text, vars[i]]));
                const actualTy = (0, exports.TRecord)(actualTyParams);
                const recordDiff = ty.nodeType === "Record"
                    ? Object.assign(Object.assign({}, this.calculateRecordDiff(actualTy, ty)), { missing: new Map() }) : undefined;
                this.diagnostics.push(typeMismatchError(this.program.getTypeChecker(), pattern, actualTy, ty, undefined, true, recordDiff));
                if (recordDiff) {
                    this.recordDiffs.set(pattern, recordDiff);
                }
            }
            fields.forEach((field) => {
                this.bindPattern(field, exports.TUnknown, isParameter);
            });
            this.expressionTypes.set(pattern, type);
            return;
        }
        const tyFields = (_a = ty === null || ty === void 0 ? void 0 : ty.fields) !== null && _a !== void 0 ? _a : ty.fields;
        fields.forEach((field) => {
            this.bindPattern(field, tyFields[field.text], isParameter);
        });
        this.expressionTypes.set(pattern, type);
    }
    isAssignable(expr, type1, type2, endExpr, patternBinding = false) {
        if (!type1 || !type2) {
            throw new Error("Undefined type error");
        }
        let assignable;
        if (expr.nodeType === "CaseOfExpr" &&
            (!endExpr || endExpr.id === expr.id)) {
            return this.isBranchesAssignable(expr, type1, type2);
        }
        try {
            assignable = this.assignable(type1, type2);
        }
        catch (error) {
            if (error instanceof Error) {
                this.diagnostics.push((0, diagnostics_1.errorWithEndNode)(expr, diagnostics_1.Diagnostics.General, endExpr, error.message));
            }
            return false;
        }
        if (!assignable) {
            const t1 = typeReplacement_1.TypeReplacement.replace(type1, this.replacements.toMap());
            const t2 = typeReplacement_1.TypeReplacement.replace(type2, this.replacements.toMap());
            const diff = t1.nodeType === "Record" && t2.nodeType === "Record"
                ? this.calculateRecordDiff(t1, t2)
                : undefined;
            const errorExpr = expr.nodeType === "LetInExpr" ? expr.body : expr;
            this.diagnostics.push(typeMismatchError(this.program.getTypeChecker(), errorExpr, t1, t2, errorExpr, patternBinding, diff));
            if (diff && expr.nodeType === "RecordExpr") {
                this.recordDiffs.set(expr, diff);
            }
        }
        return assignable;
    }
    isBranchesAssignable(expr, type1, type2) {
        // If type2 is not a concrete type, then every branch should match the first type
        const t2 = type2.nodeType !== "Unknown" && type2.nodeType !== "Var" ? type2 : type1;
        return expr.branches.every((branch) => {
            const t1 = this.expressionTypes.get(branch.expr);
            return t1 ? this.isAssignable(branch.expr, t1, t2) : false;
        });
    }
    assignable(type1, type2) {
        const ty1 = this.replacements.get(type1);
        const ty2 = this.replacements.get(type2);
        let result = ty1 === ty2 || (ty1 === null || ty1 === void 0 ? void 0 : ty1.nodeType) === "Unknown" || (ty2 === null || ty2 === void 0 ? void 0 : ty2.nodeType) === "Unknown";
        if (!result) {
            if ((ty1 === null || ty1 === void 0 ? void 0 : ty1.nodeType) !== "Var" && (ty2 === null || ty2 === void 0 ? void 0 : ty2.nodeType) === "Var") {
                result = this.nonVarAssignableToVar(ty1, ty2);
            }
            else {
                switch (ty1 === null || ty1 === void 0 ? void 0 : ty1.nodeType) {
                    case "Var":
                        if ((ty2 === null || ty2 === void 0 ? void 0 : ty2.nodeType) === "Var") {
                            result = this.varsAssignable(ty1, ty2);
                        }
                        else {
                            result = this.nonVarAssignableToVar(ty2, ty1);
                        }
                        break;
                    case "Union":
                        {
                            result =
                                (ty2 === null || ty2 === void 0 ? void 0 : ty2.nodeType) === "Union" &&
                                    ty1.name === ty2.name &&
                                    ty1.module === ty2.module &&
                                    this.allAssignable(ty1.params, ty2.params);
                        }
                        break;
                    case "Function":
                        {
                            result =
                                (ty2 === null || ty2 === void 0 ? void 0 : ty2.nodeType) === "Function" &&
                                    this.functionAssignable(ty1, ty2);
                        }
                        break;
                    case "Tuple":
                        {
                            result =
                                (ty2 === null || ty2 === void 0 ? void 0 : ty2.nodeType) === "Tuple" &&
                                    ty1.types.length === ty2.types.length &&
                                    this.allAssignable(ty1.types, ty2.types);
                        }
                        break;
                    case "Record":
                        {
                            result =
                                ((ty2 === null || ty2 === void 0 ? void 0 : ty2.nodeType) === "Record" &&
                                    this.recordAssignable(ty1, ty2)) ||
                                    ((ty2 === null || ty2 === void 0 ? void 0 : ty2.nodeType) === "MutableRecord" &&
                                        this.mutableRecordAssignable(ty2, ty1));
                        }
                        break;
                    case "MutableRecord":
                        {
                            result =
                                ((ty2 === null || ty2 === void 0 ? void 0 : ty2.nodeType) === "Record" ||
                                    (ty2 === null || ty2 === void 0 ? void 0 : ty2.nodeType) === "MutableRecord") &&
                                    this.mutableRecordAssignable(ty1, ty2);
                        }
                        break;
                    case "Unit":
                        result = (ty2 === null || ty2 === void 0 ? void 0 : ty2.nodeType) === "Unit";
                        break;
                    case "Unknown":
                        result = true;
                        break;
                    case "InProgressBinding":
                        throw new Error(`Should never try to assign an in progress binding`);
                }
            }
        }
        if (ty1 && ty2 && result) {
            this.trackReplacement(ty1, ty2);
        }
        return result;
    }
    mutableRecordAssignable(type1, type2) {
        if (!this.recordAssignable(mutableRecordAsRecord(type1), type2.nodeType === "MutableRecord"
            ? mutableRecordAsRecord(type2)
            : type2)) {
            return false;
        }
        type1.fields = Object.assign(Object.assign({}, type1.fields), type2.fields);
        if (type2.nodeType === "MutableRecord") {
            type2.fields = Object.assign(Object.assign({}, type2.fields), type1.fields);
        }
        return true;
    }
    recordAssignable(type1, type2) {
        var _a, _b;
        const result = this.calculateRecordDiff(type1, type2).isEmpty;
        if (result) {
            const getReplacementRecordDiff = (record, recordWithBaseType) => {
                const baseTypeFields = Object.keys(recordWithBaseType.fields);
                return (0, exports.TRecord)(Object.fromEntries(Object.entries(record.fields).filter(([k]) => !baseTypeFields.includes(k))), record.baseType, record.alias, record.fieldReferences);
            };
            if (!type1.baseType && ((_a = type2.baseType) === null || _a === void 0 ? void 0 : _a.nodeType) === "Var") {
                this.trackReplacement(getReplacementRecordDiff(type1, type2), type2.baseType);
            }
            if (!type2.baseType && ((_b = type1.baseType) === null || _b === void 0 ? void 0 : _b.nodeType) === "Var") {
                this.trackReplacement(type1.baseType, getReplacementRecordDiff(type2, type1));
            }
            type1.fieldReferences.addAll(type2.fieldReferences);
            type2.fieldReferences.addAll(type1.fieldReferences);
        }
        return result;
    }
    calculateRecordDiff(actual, expected) {
        const actualEntries = Object.entries(actual.fields);
        const actualKeys = Object.keys(actual.fields);
        const expectedEntries = Object.entries(expected.fields);
        const expectedKeys = Object.keys(expected.fields);
        return RecordDiff(expected.baseType
            ? new Map()
            : new Map(actualEntries.filter(([field]) => !expectedKeys.includes(field))), actual.baseType
            ? new Map()
            : new Map(expectedEntries.filter(([field]) => !actualKeys.includes(field))), new Map(actualEntries
            .map(([k, v]) => {
            if (expected.fields[k] && !this.assignable(v, expected.fields[k])) {
                return [k, [v, expected.fields[k]]];
            }
            return undefined;
        })
            .filter(utils_1.Utils.notUndefined)));
    }
    allAssignable(type1, type2) {
        return (type1.length === type2.length &&
            type1.every((t, i) => this.assignable(t, type2[i])));
    }
    functionAssignable(type1, type2) {
        const allTypes1 = type1.params.concat(type1.return);
        const allTypes2 = type2.params.concat(type2.return);
        // If there is only one type, return it
        // If there are multiple, curry it into a new function
        function makeFunction(types) {
            if (types.length === 1) {
                return types[0];
            }
            else {
                return (0, exports.TFunction)(types.slice(0, types.length - 1), types[types.length - 1]);
            }
        }
        const paramsSize = Math.min(allTypes1.length, allTypes2.length) - 1;
        // Make sure the shared parameters are assignable
        const sharedAssignable = this.allAssignable(allTypes1.slice(0, paramsSize), allTypes2.slice(0, paramsSize));
        const tailAssignable = this.assignable(makeFunction(allTypes1.slice(paramsSize)), makeFunction(allTypes2.slice(paramsSize)));
        return sharedAssignable && tailAssignable;
    }
    /**
     * Check that two type vars can be unified
     */
    varsAssignable(type1, type2) {
        const typeClass1 = getTypeclassName(type1);
        const typeClass2 = getTypeclassName(type2);
        if (!type1.rigid && !typeClass1) {
            return true;
        }
        else if (!type1.rigid && typeClass1) {
            return (this.typeclassesCompatible(typeClass1, typeClass2, !type2.rigid) ||
                (!type2.rigid &&
                    this.typeclassesConstrainToCompappend(typeClass1, typeClass2)));
        }
        else if (type1.rigid && !typeClass1) {
            return !type2.rigid && !typeClass2;
        }
        else if (type1.rigid && typeClass1 && type2.rigid) {
            // If they are both rigid and we have a type class, they must be the same typeclass
            return typeClass1 === typeClass2;
        }
        else if (type1.rigid && typeClass1 && !type2.rigid) {
            return this.typeclassesCompatible(typeClass1, typeClass2, !type2.rigid);
        }
        else {
            throw new Error("Impossible");
        }
    }
    nonVarAssignableToVar(type, typeVar) {
        const allAssignableTo = (types, typeClass) => {
            return types.every((t) => this.assignable(t, (0, exports.TVar)(typeClass)));
        };
        const typeVarClass = getTypeclassName(typeVar);
        if (typeVarClass === "number") {
            return ((type === null || type === void 0 ? void 0 : type.nodeType) === "Union" && (typeIsFloat(type) || typeIsInt(type)));
        }
        else if (typeVarClass === "appendable") {
            return ((type === null || type === void 0 ? void 0 : type.nodeType) === "Union" && (typeIsString(type) || typeIsList(type)));
        }
        else if (typeVarClass === "comparable") {
            if ((type === null || type === void 0 ? void 0 : type.nodeType) === "Tuple") {
                return allAssignableTo(type.types, "comparable");
            }
            else if ((type === null || type === void 0 ? void 0 : type.nodeType) === "Union") {
                return (typeIsFloat(type) ||
                    typeIsInt(type) ||
                    typeIsChar(type) ||
                    typeIsString(type) ||
                    (typeIsList(type) &&
                        (allAssignableTo(type.params, "comparable") ||
                            allAssignableTo(type.params, "number"))));
            }
            else {
                return false;
            }
        }
        else if (typeVarClass === "compappend") {
            return ((type === null || type === void 0 ? void 0 : type.nodeType) === "Union" &&
                (typeIsString(type) ||
                    (typeIsList(type) &&
                        (allAssignableTo(type.params, "comparable") ||
                            allAssignableTo(type.params, "compappend")))));
        }
        return !typeVar.rigid;
    }
    typeclassesCompatible(name1, name2, unconstrainedAllowed = true) {
        if (!name2) {
            return unconstrainedAllowed;
        }
        if (name1 === name2) {
            return true;
        }
        if (name1 === "number" && name2 === "comparable") {
            return true;
        }
        if (name1 === "comparable" && name2 === "number") {
            return true;
        }
        if (name1 === "comparable" &&
            (name2 === "number" || name2 === "compappend")) {
            return true;
        }
        if (name1 === "compappend" &&
            (name2 === "comparable" || name2 === "appendable")) {
            return true;
        }
        return false;
    }
    typeclassesConstrainToCompappend(tc1, tc2) {
        if (tc1 === "comparable") {
            return tc2 === "appendable" || tc2 === "compappend";
        }
        if (tc1 === "appendable") {
            return tc2 === "comparable" || tc2 === "compappend";
        }
        return false;
    }
    trackReplacement(type1, type2) {
        var _a;
        if (type1 === type2) {
            return;
        }
        // Assign typeVar to be of type
        const assign = (typeVar, type) => {
            if (anyTypeVar(type, (tVar) => tVar === typeVar)) {
                throw Error("InfiniteTypeException");
            }
            this.replacements.set(typeVar, type);
        };
        // If we assign anything to a var, the type is constrained to that var
        if (type2.nodeType === "Var" &&
            (!this.replacements.contains(type2) ||
                (type1.nodeType !== "Var" &&
                    ((_a = this.replacements.get(type2)) === null || _a === void 0 ? void 0 : _a.nodeType) === "Var"))) {
            if (type1.nodeType === "Var") {
                const typeClass1 = getTypeclassName(type1);
                const typeClass2 = getTypeclassName(type2);
                if (!typeClass1 && typeClass2) {
                    // Assigning a => number, a should be constrained to number
                    assign(type1, type2);
                }
                else if (!type1.rigid &&
                    !type2.rigid &&
                    this.typeclassesConstrainToCompappend(typeClass1, typeClass2)) {
                    assign(type1, typeClass2 === "compappend" ? type2 : (0, exports.TVar)("compappend"));
                }
                else if (!type1.rigid &&
                    !type2.rigid &&
                    typeClass1 === "comparable" &&
                    typeClass2 === "number") {
                    // comparable is constrained to number
                    assign(type1, type2);
                }
                else if (!type1.rigid && type2.rigid) {
                    // Assigning a flex var to a rigid var makes it rigid
                    assign(type1, type2);
                }
                else {
                    assign(type2, type1);
                }
            }
            else {
                // Int => number contrains number to be an Int
                assign(type2, type1);
            }
        }
        // Assigning a var to a non var type constrains the type
        if (type1.nodeType === "Var" &&
            type2.nodeType !== "Var" &&
            !this.replacements.contains(type1)) {
            if (type2.nodeType === "Record" && type2.baseType) {
                assign(type1, (0, exports.TMutableRecord)(Object.assign({}, type2.fields), type2.baseType));
            }
            else {
                const typeClass1 = getTypeclassName(type1);
                if (type1.rigid || !typeClass1) {
                    assign(type1, type2);
                }
            }
        }
    }
    bindIfVar(e, type, defaultType) {
        if (type.nodeType === "Var") {
            this.isAssignable(e, type, defaultType, undefined, true);
            return defaultType;
        }
        else {
            return type;
        }
    }
    uniqueVars(count) {
        return getVarNames(count).map((val) => {
            return (0, exports.TVar)(val);
        });
    }
}
exports.InferenceScope = InferenceScope;
//# sourceMappingURL=typeInference.js.map