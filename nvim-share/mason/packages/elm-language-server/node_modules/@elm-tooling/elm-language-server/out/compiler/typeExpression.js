"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeExpression = exports.PerformanceTimer = void 0;
const typeInference_1 = require("./typeInference");
const expressionTree_1 = require("./utils/expressionTree");
const treeUtils_1 = require("../common/util/treeUtils");
const typeReplacement_1 = require("./typeReplacement");
const syntaxNodeMap_1 = require("./utils/syntaxNodeMap");
const utils_1 = require("../common/util/utils");
const recordFieldReferenceTable_1 = require("./utils/recordFieldReferenceTable");
const diagnostics_1 = require("./diagnostics");
class PerformanceTimer {
    constructor() {
        this.total = 0;
    }
    track(func, track = true) {
        if (!track) {
            return func();
        }
        const start = performance.now();
        try {
            return func();
        }
        finally {
            this.total += performance.now() - start;
        }
    }
    reset() {
        this.total = 0;
    }
}
exports.PerformanceTimer = PerformanceTimer;
class TypeExpression {
    constructor(root, program, rigidVars, activeAliases = new Set()) {
        this.root = root;
        this.program = program;
        this.rigidVars = rigidVars;
        this.activeAliases = activeAliases;
        // All the type variables we've seen
        this.varsByExpression = new syntaxNodeMap_1.SyntaxNodeMap();
        this.expressionTypes = new syntaxNodeMap_1.SyntaxNodeMap();
        this.diagnostics = [];
    }
    static typeDeclarationInference(e, program) {
        var _a;
        const setter = () => {
            (0, expressionTree_1.mapTypeDeclaration)(e); // Fill in values only when needed
            const inferenceResult = new TypeExpression(e, program, 
            /* rigidVars */ false).inferTypeDeclaration(e);
            typeReplacement_1.TypeReplacement.freeze(inferenceResult.type);
            return inferenceResult;
        };
        const result = !((_a = program.getSourceFile(e.tree.uri)) === null || _a === void 0 ? void 0 : _a.writeable)
            ? program
                .getTypeCache()
                .getOrSet("PACKAGE_TYPE_AND_TYPE_ALIAS", e, setter)
            : program
                .getTypeCache()
                .getOrSet("PROJECT_TYPE_AND_TYPE_ALIAS", e, setter);
        return Object.assign(Object.assign({}, result), { type: typeReplacement_1.TypeReplacement.freshenVars(result.type) });
    }
    static typeAliasDeclarationInference(e, program, activeAliases = new Set()) {
        var _a;
        const setter = () => {
            (0, expressionTree_1.mapTypeAliasDeclaration)(e);
            const inferenceResult = new TypeExpression(e, program, 
            /* rigidVars */ false, activeAliases).inferTypeAliasDeclaration(e);
            typeReplacement_1.TypeReplacement.freeze(inferenceResult.type);
            return inferenceResult;
        };
        const result = !((_a = program.getSourceFile(e.tree.uri)) === null || _a === void 0 ? void 0 : _a.writeable)
            ? program
                .getTypeCache()
                .getOrSet("PACKAGE_TYPE_AND_TYPE_ALIAS", e, setter)
            : program
                .getTypeCache()
                .getOrSet("PROJECT_TYPE_AND_TYPE_ALIAS", e, setter);
        return Object.assign(Object.assign({}, result), { type: typeReplacement_1.TypeReplacement.freshenVars(result.type) });
    }
    static typeAnnotationInference(e, program, rigid = true) {
        var _a;
        const setter = () => {
            (0, expressionTree_1.mapTypeAnnotation)(e);
            const inferenceResult = new TypeExpression(e, program, 
            /* rigidVars */ true).inferTypeExpression(e.typeExpression);
            const type = typeReplacement_1.TypeReplacement.replace(inferenceResult.type, new Map());
            typeReplacement_1.TypeReplacement.freeze(inferenceResult.type);
            program.getTypeCache().trackTypeAnnotation(e);
            return Object.assign(Object.assign({}, inferenceResult), { type });
        };
        const result = !((_a = program.getSourceFile(e.tree.uri)) === null || _a === void 0 ? void 0 : _a.writeable)
            ? program.getTypeCache().getOrSet("PACKAGE_TYPE_ANNOTATION", e, setter)
            : program.getTypeCache().getOrSet("PROJECT_TYPE_ANNOTATION", e, setter);
        if (!rigid) {
            result.type = typeReplacement_1.TypeReplacement.flexify(result.type);
        }
        return result;
    }
    static unionVariantInference(e, program) {
        var _a;
        const setter = () => {
            const inferenceResult = new TypeExpression(e, program, 
            /* rigidVars */ false).inferUnionConstructor(e);
            typeReplacement_1.TypeReplacement.freeze(inferenceResult.type);
            program.getTypeCache().trackUnionVariant(e);
            return inferenceResult;
        };
        const result = !((_a = program.getSourceFile(e.tree.uri)) === null || _a === void 0 ? void 0 : _a.writeable)
            ? program.getTypeCache().getOrSet("PACKAGE_UNION_VARIANT", e, setter)
            : program.getTypeCache().getOrSet("PROJECT_UNION_VARIANT", e, setter);
        return Object.assign(Object.assign({}, result), { type: typeReplacement_1.TypeReplacement.freshenVars(result.type) });
    }
    static portAnnotationInference(e, program) {
        const inferenceResult = new TypeExpression(e, program, 
        /* rigidVars */ false).inferPortAnnotation(e);
        typeReplacement_1.TypeReplacement.freeze(inferenceResult.type);
        return Object.assign(Object.assign({}, inferenceResult), { type: typeReplacement_1.TypeReplacement.freshenVars(inferenceResult.type) });
    }
    inferTypeDeclaration(typeDeclaration) {
        return this.toResult(this.typeDeclarationType(typeDeclaration));
    }
    inferTypeExpression(typeExpr) {
        return this.toResult(this.typeExpressionType(typeExpr));
    }
    inferUnionConstructor(unionVariant) {
        const declaration = (0, expressionTree_1.mapSyntaxNodeToExpression)(treeUtils_1.TreeUtils.findParentOfType("type_declaration", unionVariant));
        (0, expressionTree_1.mapTypeDeclaration)(declaration);
        const declarationType = declaration && declaration.nodeType === "TypeDeclaration"
            ? this.typeDeclarationType(declaration)
            : typeInference_1.TUnknown;
        const params = unionVariant.params.map((t) => this.typeSignatureSegmentType(t));
        const type = params.length > 0 ? (0, typeInference_1.TFunction)(params, declarationType) : declarationType;
        return this.toResult(type);
    }
    inferPortAnnotation(portAnnotation) {
        const type = this.typeExpressionType
            ? this.typeExpressionType(portAnnotation.typeExpression)
            : typeInference_1.TUnknown;
        return this.toResult(type);
    }
    inferTypeAliasDeclaration(declaration) {
        var _a, _b;
        this.activeAliases.add(declaration);
        const type = declaration.typeExpression
            ? this.typeExpressionType(declaration.typeExpression)
            : typeInference_1.TUnknown;
        const params = declaration.typeVariables.map(this.getTypeVar.bind(this));
        const moduleName = (_b = (_a = treeUtils_1.TreeUtils.getModuleNameNode(declaration.tree)) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : "";
        const alias = {
            module: moduleName,
            name: declaration.name.text,
            parameters: params,
        };
        return this.toResult(Object.assign(Object.assign({}, type), { alias: alias }));
    }
    typeExpressionType(typeExpr) {
        const segmentTypes = typeExpr.segments.map((s) => this.typeSignatureSegmentType(s));
        const type = segmentTypes.length === 1
            ? segmentTypes[0]
            : (0, typeInference_1.uncurryFunction)((0, typeInference_1.TFunction)(segmentTypes.slice(0, segmentTypes.length - 1), segmentTypes[segmentTypes.length - 1]));
        this.expressionTypes.set(typeExpr, type);
        return type;
    }
    toResult(type) {
        return {
            type,
            expressionTypes: this.expressionTypes,
            diagnostics: this.diagnostics,
            recordDiffs: new syntaxNodeMap_1.SyntaxNodeMap(),
        };
    }
    typeSignatureSegmentType(segment) {
        let type = typeInference_1.TUnknown;
        switch (segment.nodeType) {
            case "TypeRef":
                type = this.typeRefType(segment);
                break;
            case "TypeVariable":
                type = this.typeVariableType(segment);
                break;
            case "TypeExpression":
                type = this.typeExpressionType(segment);
                break;
            case "TupleType":
                type = segment.unitExpr
                    ? typeInference_1.TUnit
                    : (0, typeInference_1.TTuple)(segment.typeExpressions.map((t) => this.typeExpressionType(t)));
                break;
            case "RecordType":
                type = this.recordTypeDeclarationType(segment);
                break;
        }
        return type;
    }
    typeVariableType(typeVariable) {
        var _a, _b;
        const definition = (0, expressionTree_1.findDefinition)(typeVariable.firstNamedChild, this.program);
        // The type variable doesn't reference anything
        if (!definition.expr || definition.expr.id === typeVariable.id) {
            const type = this.getTypeVar(typeVariable);
            this.expressionTypes.set(typeVariable, type);
            return type;
        }
        const cached = this.varsByExpression.get(definition.expr);
        if (cached) {
            return cached;
        }
        const annotation = (0, expressionTree_1.mapSyntaxNodeToExpression)(treeUtils_1.TreeUtils.findParentOfType("type_annotation", definition.expr));
        if (annotation) {
            (0, expressionTree_1.mapTypeAnnotation)(annotation);
        }
        const expr = annotation
            ? annotation.childForFieldName("typeExpression")
            : undefined;
        // If the definition is not in a type annotation or it is to a
        // variable in the same annotation, use the type of the reference
        if (!annotation || !expr || annotation.id === this.root.id) {
            const type = this.getTypeVar(definition.expr);
            this.varsByExpression.set(typeVariable, type);
            this.expressionTypes.set(typeVariable, type);
            return type;
        }
        // If the definition is to a variable declared in a parent annotation,
        // use the type from that annotation's inference
        const type = (_b = (_a = TypeExpression.typeAnnotationInference(annotation, this.program, 
        /* rigid */ true)) === null || _a === void 0 ? void 0 : _a.expressionTypes.get(definition.expr)) !== null && _b !== void 0 ? _b : typeInference_1.TUnknown;
        if (type.nodeType === "Var") {
            this.varsByExpression.set(definition.expr, type);
        }
        this.expressionTypes.set(typeVariable, type);
        return type;
    }
    recordTypeDeclarationType(record) {
        var _a;
        const fieldExpressions = record.fieldTypes;
        if (!fieldExpressions || fieldExpressions.length === 0) {
            return (0, typeInference_1.TRecord)({});
        }
        const fieldTypes = {};
        fieldExpressions.forEach((field) => {
            fieldTypes[field.name] = this.typeExpressionType(field.typeExpression);
        });
        const fieldRefs = recordFieldReferenceTable_1.RecordFieldReferenceTable.fromExpressions(fieldExpressions);
        const baseTypeDefinition = (_a = (0, expressionTree_1.findDefinition)(record.baseType, this.program)) === null || _a === void 0 ? void 0 : _a.expr;
        const baseType = baseTypeDefinition
            ? this.getTypeVar(baseTypeDefinition)
            : record.baseType
                ? (0, typeInference_1.TVar)(record.baseType.text)
                : undefined;
        const type = (0, typeInference_1.TRecord)(fieldTypes, baseType, undefined, fieldRefs);
        this.expressionTypes.set(record, type);
        return type;
    }
    typeRefType(typeRef) {
        var _a, _b, _c, _d, _e;
        const args = (_b = (_a = treeUtils_1.TreeUtils.findAllNamedChildrenOfType([
            "type_variable",
            "type_ref",
            "tuple_type",
            "record_type",
            "type_expression",
        ], typeRef)) === null || _a === void 0 ? void 0 : _a.map(expressionTree_1.mapSyntaxNodeToExpression).filter(utils_1.Utils.notUndefined).map((arg) => this.typeSignatureSegmentType(arg))) !== null && _b !== void 0 ? _b : [];
        const definition = (0, expressionTree_1.findDefinition)((_c = typeRef.firstNamedChild) === null || _c === void 0 ? void 0 : _c.lastNamedChild, this.program);
        this.diagnostics.push(...definition.diagnostics);
        let declaredType = typeInference_1.TUnknown;
        if (definition.expr) {
            switch (definition.expr.nodeType) {
                case "TypeDeclaration":
                    declaredType = TypeExpression.typeDeclarationInference(definition.expr, this.program).type;
                    break;
                case "TypeAliasDeclaration":
                    {
                        // Check for recursion
                        const aliases = Array.from(this.activeAliases);
                        const recursiveAlias = aliases.find((decl) => { var _a; return decl.id === ((_a = definition.expr) === null || _a === void 0 ? void 0 : _a.id); });
                        if (recursiveAlias) {
                            const name = definition.expr.childForFieldName("name");
                            const index = aliases.findIndex((alias) => alias.id === recursiveAlias.id);
                            if (name) {
                                const slicedAliases = aliases.slice(index);
                                this.diagnostics.push((0, diagnostics_1.error)(name, diagnostics_1.Diagnostics.RecursiveAlias(slicedAliases.length), ...slicedAliases.map((alias) => { var _a, _b; return (_b = (_a = alias.childForFieldName("name")) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : ""; })));
                            }
                            declaredType = typeInference_1.TUnknown;
                        }
                        else {
                            declaredType = TypeExpression.typeAliasDeclarationInference(definition.expr, this.program, new Set(this.activeAliases.values())).type;
                        }
                    }
                    break;
                default:
                    throw new Error("Unexpected type reference");
            }
        }
        else {
            if (((_e = (_d = typeRef.firstNamedChild) === null || _d === void 0 ? void 0 : _d.firstNamedChild) === null || _e === void 0 ? void 0 : _e.text) === "List") {
                declaredType = (0, typeInference_1.TList)((0, typeInference_1.TVar)("a"));
            }
            else if (typeRef.firstNamedChild &&
                definition.diagnostics.length === 0) {
                this.diagnostics.push((0, diagnostics_1.error)(typeRef.firstNamedChild, diagnostics_1.Diagnostics.MissingValue, typeRef.firstNamedChild.text));
            }
        }
        const params = (declaredType === null || declaredType === void 0 ? void 0 : declaredType.alias)
            ? declaredType.alias.parameters
            : (declaredType === null || declaredType === void 0 ? void 0 : declaredType.nodeType) === "Union"
                ? declaredType.params
                : [];
        if (declaredType.nodeType !== "Unknown" && params.length !== args.length) {
            this.diagnostics.push((0, diagnostics_1.error)(typeRef, diagnostics_1.Diagnostics.TypeArgumentCount, params.length, args.length));
            return typeInference_1.TUnknown;
        }
        if (params.length === 0) {
            return declaredType;
        }
        // The param types are always TVars
        return typeReplacement_1.TypeReplacement.replace(declaredType, new Map(params
            .map((p, i) => [p, args[i]])
            .filter(([, type]) => !!type)));
    }
    typeDeclarationType(typeDeclaration) {
        var _a, _b;
        const params = typeDeclaration.typeNames.map((name) => this.getTypeVar(name));
        return (0, typeInference_1.TUnion)((_b = (_a = this.program.getSourceFile(typeDeclaration.tree.uri)) === null || _a === void 0 ? void 0 : _a.moduleName) !== null && _b !== void 0 ? _b : "", typeDeclaration.name, params);
    }
    getTypeVar(e) {
        return this.varsByExpression.getOrSet(e, () => (0, typeInference_1.TVar)(e.text, this.rigidVars));
    }
}
exports.TypeExpression = TypeExpression;
//# sourceMappingURL=typeExpression.js.map