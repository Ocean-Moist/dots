import { Expression, EValueDeclaration } from "./utils/expressionTree";
import { SyntaxNodeMap } from "./utils/syntaxNodeMap";
import { IProgram } from "./program";
import { Sequence } from "../common/util/sequence";
import { RecordFieldReferenceTable } from "./utils/recordFieldReferenceTable";
import type { ICancellationToken } from "../common/cancellation";
import { Diagnostic } from "./diagnostics";
export declare let inferTime: number;
export declare function resetInferTime(): void;
export interface Alias {
    module: string;
    name: string;
    parameters: Type[];
}
export type Type = TVar | TFunction | TTuple | TUnion | TUnit | TInProgressBinding | TUnknown | TRecord | TMutableRecord;
export interface TVar {
    nodeType: "Var";
    name: string;
    rigid?: boolean;
    alias?: Alias;
}
export interface TFunction {
    nodeType: "Function";
    params: Type[];
    return: Type;
    alias?: Alias;
}
export interface TTuple {
    nodeType: "Tuple";
    types: Type[];
    alias?: Alias;
}
export interface TUnion {
    nodeType: "Union";
    module: string;
    name: string;
    params: Type[];
    alias?: Alias;
}
export interface TRecord {
    nodeType: "Record";
    fields: {
        [key: string]: Type;
    };
    baseType?: Type;
    alias?: Alias;
    fieldReferences: RecordFieldReferenceTable;
}
export interface TMutableRecord {
    nodeType: "MutableRecord";
    fields: {
        [key: string]: Type;
    };
    baseType?: Type;
    alias?: Alias;
    fieldReferences: RecordFieldReferenceTable;
}
interface TUnit {
    nodeType: "Unit";
    alias?: Alias;
}
interface TInProgressBinding {
    nodeType: "InProgressBinding";
    alias?: Alias;
}
interface TUnknown {
    nodeType: "Unknown";
    alias?: Alias;
}
export declare const TUnion: (module: string, name: string, params: Type[], alias?: Alias) => TUnion;
export declare const TVar: (name: string, rigid?: boolean) => TVar;
export declare const TFunction: (params: Type[], ret: Type, alias?: Alias) => TFunction;
export declare const TTuple: (types: Type[], alias?: Alias) => TTuple;
export declare const TRecord: (fields: {
    [key: string]: Type;
}, baseType?: Type, alias?: Alias, fieldReferences?: RecordFieldReferenceTable) => TRecord;
export declare const TMutableRecord: (fields: {
    [key: string]: Type;
}, baseType?: Type, fieldReferences?: RecordFieldReferenceTable) => TMutableRecord;
export declare const TUnknown: TUnknown;
export declare const TList: (elementType: Type) => TUnion;
export declare const TUnit: TUnit;
export declare const TInProgressBinding: TInProgressBinding;
/**
 * Curry function helper
 * @param func The function type to curry
 * @param count The number params to partially apply
 */
export declare function curryFunction(func: TFunction, count: number): Type;
/**
 * Uncurry function helper
 * @param func The function type to uncurry
 */
export declare function uncurryFunction(func: TFunction): TFunction;
type TypeClass = "number" | "appendable" | "comparable" | "compappend";
export declare function getTypeclassName(type: TVar): TypeClass | undefined;
export declare function getVarNames(count: number): string[];
export declare function nthVarName(n: number): string;
interface RecordDiff {
    extra: Map<string, Type>;
    missing: Map<string, Type>;
    mismatched: Map<string, [Type, Type]>;
    isEmpty: boolean;
}
declare const RecordDiff: (extra: Map<string, Type>, missing: Map<string, Type>, mismatched: Map<string, [Type, Type]>) => RecordDiff;
export interface InferenceResult {
    expressionTypes: SyntaxNodeMap<Expression, Type>;
    diagnostics: Diagnostic[];
    type: Type;
    recordDiffs: SyntaxNodeMap<Expression, RecordDiff>;
}
export declare class InferenceScope {
    private uri;
    private program;
    private nonShadowableNames;
    private activeScopes;
    private recursionAllowed;
    private cancellationToken?;
    private parent?;
    private expressionTypes;
    private diagnostics;
    private bindings;
    private replacements;
    private annotationVars;
    ancestors: Sequence<InferenceScope>;
    private resolvedDeclarations;
    private childDeclarations;
    private recordDiffs;
    private typeChecker;
    constructor(uri: string, program: IProgram, nonShadowableNames: Set<string>, activeScopes: Set<EValueDeclaration>, recursionAllowed: boolean, cancellationToken?: ICancellationToken | undefined, parent?: InferenceScope | undefined);
    private getBinding;
    static valueDeclarationInference(declaration: EValueDeclaration, uri: string, program: IProgram, activeScopes: Set<EValueDeclaration>, recursionAllowed?: boolean, cancellationToken?: ICancellationToken): InferenceResult;
    private inferDeclaration;
    private checkTopLevelCaseBranches;
    private checkRecursion;
    private toTopLevelResult;
    private infer;
    private lambdaInference;
    private letInInference;
    private caseBranchInference;
    private inferChild;
    private inferChildDeclaration;
    private inferList;
    private inferIfElse;
    private inferReferenceElement;
    private inferReferencedValueDeclaration;
    private inferFunctionCallExpr;
    private inferBinOpExpr;
    private inferOperand;
    private inferOperatorAndPrecedence;
    private inferFieldAccessorFunctionExpr;
    private inferNegateExpr;
    private inferOperatorAsFunctionExpr;
    private inferFieldAccess;
    private inferFieldAccessTarget;
    private inferLambda;
    private inferCase;
    private inferRecord;
    private setBinding;
    private bindParameters;
    private bindFunctionDeclarationParameters;
    private bindPatternDeclarationParameters;
    private bindPattern;
    private bindTuplePattern;
    private bindUnionPattern;
    private bindConsPattern;
    private bindListPattern;
    private bindListPatternParts;
    private bindRecordPattern;
    private isAssignable;
    private isBranchesAssignable;
    private assignable;
    private mutableRecordAssignable;
    private recordAssignable;
    private calculateRecordDiff;
    private allAssignable;
    private functionAssignable;
    /**
     * Check that two type vars can be unified
     */
    private varsAssignable;
    private nonVarAssignableToVar;
    private typeclassesCompatible;
    private typeclassesConstrainToCompappend;
    private trackReplacement;
    private bindIfVar;
    private uniqueVars;
}
export {};
