"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ElmMakeDiagnostics = exports.CODE_ACTION_ELM_MAKE = exports.NAMING_ERROR = void 0;
/* eslint-disable @typescript-eslint/no-unsafe-call */
const path = __importStar(require("path"));
const tsyringe_1 = require("tsyringe");
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const elmWorkspaceMatcher_1 = require("../../util/elmWorkspaceMatcher");
const elmDiagnosticsHelper_1 = require("./elmDiagnosticsHelper");
const ELM_MAKE = "Elm";
exports.NAMING_ERROR = "NAMING ERROR";
const RANDOM_ID = Date.now().toString();
exports.CODE_ACTION_ELM_MAKE = `elmLS.elmMakeFixer-${RANDOM_ID}`;
class ElmMakeDiagnostics {
    constructor(host) {
        this.host = host;
        this.canRun = (sourceFile) => {
            return vscode_uri_1.URI.parse(sourceFile.uri).fsPath === "file" && !!this.host.execCmd;
        };
        this.createDiagnostics = (sourceFile) => __awaiter(this, void 0, void 0, function* () {
            const filePath = vscode_uri_1.URI.parse(sourceFile.uri);
            const program = this.elmWorkspaceMatcher.getProgramFor(filePath);
            return yield this.checkForErrors(program, sourceFile).then((issues) => {
                return issues.length === 0
                    ? new Map([[filePath.toString(), []]])
                    : elmDiagnosticsHelper_1.ElmDiagnosticsHelper.issuesToDiagnosticMap(issues, program.getRootPath());
            });
        });
        this.settings = tsyringe_1.container.resolve("Settings");
        this.connection = tsyringe_1.container.resolve("Connection");
        this.elmWorkspaceMatcher = new elmWorkspaceMatcher_1.ElmWorkspaceMatcher((uri) => uri);
    }
    onCodeAction(params) {
        const { uri } = params.textDocument;
        const elmMakeDiagnostics = this.filterElmMakeDiagnostics(params.context.diagnostics);
        return this.convertDiagnosticsToCodeActions(elmMakeDiagnostics, uri);
    }
    hasType(error) {
        return "type" in error;
    }
    convertDiagnosticsToCodeActions(diagnostics, uri) {
        const result = [];
        diagnostics.forEach((diagnostic) => {
            if (diagnostic.message.startsWith(exports.NAMING_ERROR) ||
                diagnostic.message.startsWith("BAD IMPORT") ||
                diagnostic.message.startsWith("UNKNOWN LICENSE") ||
                diagnostic.message.startsWith("UNKNOWN PACKAGE") ||
                diagnostic.message.startsWith("UNKNOWN EXPORT")) {
                // Offer the name suggestions from elm make to our users
                const regex = /^\s{4}#(.*)#$/gm;
                let matches;
                while ((matches = regex.exec(diagnostic.message)) !== null) {
                    // This is necessary to avoid infinite loops with zero-width matches
                    if (matches.index === regex.lastIndex) {
                        regex.lastIndex++;
                    }
                    matches
                        .filter((_, groupIndex) => groupIndex === 1)
                        .forEach((match) => {
                        result.push(this.createQuickFix(uri, match, diagnostic, `Change to \`${match}\``));
                    });
                }
            }
            else if (diagnostic.message.startsWith("MODULE NAME MISMATCH") ||
                diagnostic.message.startsWith("UNEXPECTED SYMBOL")) {
                // Offer the name suggestions from elm make to our users
                const regex = /# -> #(.*)#$/gm;
                const matches = regex.exec(diagnostic.message);
                if (matches !== null) {
                    result.push(this.createQuickFix(uri, matches[1], diagnostic, `Change to \`${matches[1]}\``));
                }
            }
        });
        return result;
    }
    createQuickFix(uri, replaceWith, diagnostic, title) {
        const map = {};
        if (!map[uri]) {
            map[uri] = [];
        }
        map[uri].push(vscode_languageserver_1.TextEdit.replace(diagnostic.range, replaceWith));
        return {
            diagnostics: [diagnostic],
            edit: { changes: map },
            kind: vscode_languageserver_1.CodeActionKind.QuickFix,
            title,
        };
    }
    filterElmMakeDiagnostics(diagnostics) {
        return diagnostics.filter((diagnostic) => diagnostic.source === ELM_MAKE);
    }
    checkForErrors(program, sourceFile) {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function* () {
            const settings = yield this.settings.getClientSettings();
            const workspaceRootPath = program.getRootPath().fsPath;
            const fileToRelativePath = (file) => path.relative(workspaceRootPath, vscode_uri_1.URI.parse(file.uri).fsPath);
            const sourceFilePath = fileToRelativePath(sourceFile);
            const forestFiles = program.getSourceFiles();
            const allFiles = forestFiles.some((file) => file.uri === sourceFile.uri)
                ? forestFiles
                : forestFiles.concat(sourceFile);
            const projectFiles = allFiles.filter((file) => !file.isDependency);
            const testFilesForSure = projectFiles.filter((file) => file.isTestFile);
            const otherFiles = projectFiles.filter((file) => !file.isTestFile);
            const entrypointsForSure = otherFiles.filter((file) => {
                var _a, _b;
                switch (file.project.type) {
                    case "application":
                        return (_b = (_a = file.exposing) === null || _a === void 0 ? void 0 : _a.has("main")) !== null && _b !== void 0 ? _b : false;
                    case "package":
                        return file.moduleName === undefined
                            ? false
                            : file.project.exposedModules.has(file.moduleName);
                }
            });
            const urisReferencedByEntrypoints = this.getUrisReferencedByEntrypoints(program, entrypointsForSure);
            const urisReferencedByTestsForSure = this.getUrisReferencedByEntrypoints(program, testFilesForSure);
            const onlyRunElmTest = entrypointsForSure.every((file) => urisReferencedByTestsForSure.has(file.uri));
            // Files that aren’t imported from any entrypoint. These could be:
            //
            // - Tests inside `src/`.
            // - New files that aren’t imported by anything yet.
            // - Old leftover files that aren’t imported by anything.
            // - Files that _are_ used and aren’t tests but that still end up here
            //   because of:
            //   - The project doesn’t use `main =`, like `review/` for elm-review.
            //   - The user has accidentally remove `main =` or not exposed it.
            //
            // Since these _could_ be test, we compile them with `elm-test make` rather
            // than `elm make`, so that "test-dependencies" are allowed. If they _aren’t_
            // tests, the only downside of this is that if you accidentally import a
            // test-dependency, you won’t get an error for that. It should be an OK tradeoff.
            const possiblyTestFiles = otherFiles.filter((file) => !urisReferencedByEntrypoints.has(file.uri));
            const argsElm = (files) => [
                "make",
                ...files.map(fileToRelativePath),
                "--report",
                "json",
                "--output",
                "/dev/null",
            ];
            const argsElmTest = (files) => {
                const args = [
                    "make",
                    ...files.map(fileToRelativePath),
                    "--report",
                    "json",
                ];
                if (settings.elmPath.trim().length > 0) {
                    args.push("--compiler", settings.elmPath);
                }
                return args;
            };
            const elmNotFound = "The 'elm' compiler is not available. Install Elm via 'npm install -g elm'.";
            const elmTestNotFound = "'elm-test' is not available. Install Elm via 'npm install -g elm-test'.";
            // - If all entrypoints are covered by tests, we only need to run `elm-test make`.
            // - Otherwise, call `elm make` for all entrypoints (if any).
            // - Call `elm-test make` for all tests (if any), plus potential tests.
            // - If there’s no `tests/` folder but files that _could_ be tests, try to
            //   call `elm-test make` but fall back to `elm make` in case they’re not
            //   tests and the user hasn’t got elm-test installed.
            const results = yield Promise.allSettled([
                entrypointsForSure.length > 0 && !onlyRunElmTest
                    ? (_b = (_a = this.host).execCmd) === null || _b === void 0 ? void 0 : _b.call(_a, [settings.elmPath, argsElm(entrypointsForSure)], [["elm", argsElm(entrypointsForSure)]], { notFoundText: elmNotFound }, workspaceRootPath)
                    : undefined,
                testFilesForSure.length === 0 && possiblyTestFiles.length > 0
                    ? (_d = (_c = this.host).execCmd) === null || _d === void 0 ? void 0 : _d.call(_c, [settings.elmTestPath, argsElmTest(possiblyTestFiles)], 
                    // These files _could_ be tests, but since there’s no `tests/` folder we can’t
                    // know if we should expect the user to have elm-test installed. If they don’t,
                    // they’ll get errors imports from "test-dependencies".
                    [
                        ["elm-test", argsElmTest(possiblyTestFiles)],
                        ["elm", argsElm(possiblyTestFiles)],
                    ], {
                        notFoundText: settings.elmTestPath === ""
                            ? elmTestNotFound
                            : // This uses `elmNotFound` since "elm" is the last alternative above.
                                elmNotFound,
                    }, workspaceRootPath)
                    : undefined,
                testFilesForSure.length > 0
                    ? (_f = (_e = this.host).execCmd) === null || _f === void 0 ? void 0 : _f.call(_e, [
                        settings.elmTestPath,
                        argsElmTest(testFilesForSure.concat(possiblyTestFiles)),
                    ], 
                    // Since there’s a `tests/` folder we expect the user to have elm-test installed.
                    [
                        [
                            "elm-test",
                            argsElmTest(testFilesForSure.concat(possiblyTestFiles)),
                        ],
                    ], { notFoundText: elmTestNotFound }, workspaceRootPath)
                    : undefined,
            ]);
            const lines = [];
            const linesSet = new Set();
            for (const result of results) {
                if (result.status === "fulfilled") {
                    continue;
                }
                const error = result.reason;
                if (typeof error === "string") {
                    continue;
                }
                else {
                    const execaError = error;
                    execaError.stderr.split("\n").forEach((line) => {
                        let errorObject;
                        try {
                            errorObject = JSON.parse(line);
                        }
                        catch (error) {
                            this.connection.console.warn("Received an invalid json, skipping error.");
                        }
                        if (errorObject &&
                            this.hasType(errorObject) &&
                            errorObject.type === "compile-errors") {
                            const compilerError = errorObject;
                            compilerError.errors.forEach((error) => {
                                error.problems.forEach((problem) => {
                                    const issue = {
                                        details: problem.message
                                            .map((message) => typeof message === "string"
                                            ? message
                                            : `#${message.string}#`)
                                            .join(""),
                                        file: error.path
                                            ? path.isAbsolute(error.path)
                                                ? path.relative(workspaceRootPath, error.path)
                                                : error.path
                                            : sourceFilePath,
                                        overview: problem.title,
                                        region: problem.region,
                                        subregion: "",
                                        tag: "error",
                                        type: "error",
                                    };
                                    const issueString = JSON.stringify(issue);
                                    if (!linesSet.has(issueString)) {
                                        lines.push(issue);
                                        linesSet.add(issueString);
                                    }
                                });
                            });
                        }
                        else if (errorObject &&
                            this.hasType(errorObject) &&
                            errorObject.type === "error") {
                            const error = errorObject;
                            this.checkIfVersionMismatchesAndCreateMessage(error);
                            const issue = {
                                details: error.message
                                    .map((message) => typeof message === "string" ? message : message.string)
                                    .join(""),
                                // elm-test might supply absolute paths to files
                                file: error.path
                                    ? path.relative(workspaceRootPath, error.path)
                                    : sourceFilePath,
                                overview: error.title,
                                region: {
                                    end: {
                                        column: 1,
                                        line: 1,
                                    },
                                    start: {
                                        column: 1,
                                        line: 1,
                                    },
                                },
                                subregion: "",
                                tag: "error",
                                type: "error",
                            };
                            lines.push(issue);
                            const issueString = JSON.stringify(issue);
                            if (!linesSet.has(issueString)) {
                                lines.push(issue);
                                linesSet.add(issueString);
                            }
                        }
                    });
                }
            }
            return lines;
        });
    }
    checkIfVersionMismatchesAndCreateMessage(errorObject) {
        if (errorObject.title === "ELM VERSION MISMATCH") {
            this.connection.window.showErrorMessage(errorObject.message
                .map((message) => typeof message === "string" ? message : message.string)
                .join(""));
        }
    }
    getUrisReferencedByEntrypoints(program, entrypoints) {
        const stack = entrypoints.slice();
        const result = new Set(entrypoints.map((file) => file.uri));
        for (let i = 0; i < stack.length; i++) {
            const file = stack[i];
            if (file.resolvedModules !== undefined) {
                for (const uri of file.resolvedModules.values()) {
                    const nextFile = program.getSourceFile(uri);
                    if (nextFile !== undefined &&
                        !nextFile.isDependency &&
                        !result.has(nextFile.uri)) {
                        result.add(nextFile.uri);
                        stack.push(nextFile);
                    }
                }
            }
        }
        return result;
    }
}
exports.ElmMakeDiagnostics = ElmMakeDiagnostics;
//# sourceMappingURL=elmMakeDiagnostics.js.map