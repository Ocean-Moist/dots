"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ElmReviewDiagnostics = exports.hasElmReviewFixes = void 0;
/* eslint-disable @typescript-eslint/no-unsafe-call */
const tsyringe_1 = require("tsyringe");
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const elmWorkspaceMatcher_1 = require("../../util/elmWorkspaceMatcher");
function hasElmReviewFixes(diagnostic) {
    var _a, _b;
    return (((_a = diagnostic === null || diagnostic === void 0 ? void 0 : diagnostic.data) === null || _a === void 0 ? void 0 : _a.code) === "elm_review" &&
        ((_b = diagnostic === null || diagnostic === void 0 ? void 0 : diagnostic.data) === null || _b === void 0 ? void 0 : _b.fixes.length) > 0);
}
exports.hasElmReviewFixes = hasElmReviewFixes;
function toLsRange({ start, end }) {
    return {
        start: {
            character: start.column - 1,
            line: start.line - 1,
        },
        end: {
            character: end.column - 1,
            line: end.line - 1,
        },
    };
}
class ElmReviewDiagnostics {
    constructor(host) {
        this.host = host;
        this.createDiagnostics = (sourceFile) => __awaiter(this, void 0, void 0, function* () {
            const filePath = vscode_uri_1.URI.parse(sourceFile.uri);
            const workspaceRootPath = this.elmWorkspaceMatcher
                .getProgramFor(filePath)
                .getRootPath();
            return yield this.checkForErrors(workspaceRootPath);
        });
        this.settings = tsyringe_1.container.resolve("Settings");
        this.connection = tsyringe_1.container.resolve("Connection");
        this.elmWorkspaceMatcher = new elmWorkspaceMatcher_1.ElmWorkspaceMatcher((uri) => uri);
    }
    canRun(sourceFile) {
        return (vscode_uri_1.URI.parse(sourceFile.uri).scheme === "file" && !!this.host.execCmdSync);
    }
    hasType(error) {
        return "type" in error;
    }
    checkForErrors(workspaceRootPath) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const settings = yield this.settings.getClientSettings();
            const fileErrors = new Map();
            if (settings.elmReviewDiagnostics === "off" ||
                !this.host.fileExists(vscode_uri_1.Utils.joinPath(workspaceRootPath, "review", "src", "ReviewConfig.elm"))) {
                return fileErrors;
            }
            const elmReviewCommand = settings.elmReviewPath;
            const cmdArguments = ["--report", "json", "--namespace", "vscode"];
            if (settings.elmPath.trim().length > 0) {
                cmdArguments.push("--compiler", settings.elmPath);
            }
            if (settings.elmFormatPath.trim().length > 0) {
                cmdArguments.push("--elm-format-path", settings.elmFormatPath);
            }
            const options = {
                cmdArguments: cmdArguments,
                notFoundText: "'elm-review' is not available. Install elm-review via 'npm install -g elm-review'.",
            };
            try {
                // Do nothing on success, but return that there were no errors
                (_b = (_a = this.host).execCmdSync) === null || _b === void 0 ? void 0 : _b.call(_a, elmReviewCommand, "elm-review", options, workspaceRootPath.fsPath);
                return fileErrors;
            }
            catch (error) {
                if (typeof error === "string") {
                    return fileErrors;
                }
                else {
                    const execaError = error;
                    let errorObject;
                    try {
                        errorObject = JSON.parse(execaError.stdout);
                    }
                    catch (error) {
                        this.connection.console.warn("Received an invalid json, skipping error.");
                    }
                    if (errorObject &&
                        this.hasType(errorObject) &&
                        errorObject.type === "review-errors") {
                        errorObject.errors.forEach(({ path, errors }) => {
                            const uri = vscode_uri_1.Utils.joinPath(workspaceRootPath, path).toString();
                            fileErrors.set(uri, errors
                                .filter((error) => !error.suppressed)
                                .map((error) => ({
                                message: error.message,
                                source: "elm-review",
                                range: toLsRange(error.region),
                                severity: settings.elmReviewDiagnostics === "error"
                                    ? vscode_languageserver_1.DiagnosticSeverity.Error
                                    : vscode_languageserver_1.DiagnosticSeverity.Warning,
                                tags: error.rule.startsWith("NoUnused")
                                    ? [vscode_languageserver_1.DiagnosticTag.Unnecessary]
                                    : undefined,
                                data: {
                                    uri,
                                    code: "elm_review",
                                    fixes: (error.fix || []).map((fix) => ({
                                        string: fix.string,
                                        range: toLsRange(fix.range),
                                    })),
                                },
                            })));
                        });
                    }
                    return fileErrors;
                }
            }
        });
    }
}
exports.ElmReviewDiagnostics = ElmReviewDiagnostics;
//# sourceMappingURL=elmReviewDiagnostics.js.map