"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RenameProvider = void 0;
const tsyringe_1 = require("tsyringe");
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const elmWorkspaceMatcher_1 = require("../util/elmWorkspaceMatcher");
const renameUtils_1 = require("../util/renameUtils");
const treeUtils_1 = require("../util/treeUtils");
class RenameProvider {
    constructor() {
        this.handleRenameRequest = (params) => {
            this.connection.console.info(`Renaming was requested`);
            let newName = params.newName;
            const affectedNodes = renameUtils_1.RenameUtils.getRenameAffectedNodes(params.program, params.textDocument.uri, params.position);
            newName = this.uppercaseNewNameIfModuleDeclaration(newName, affectedNodes);
            const renameChanges = [];
            const moduleDeclarationRenameChange = this.createModuleDeclarationRenameChange(affectedNodes, params.program, params, newName);
            if (moduleDeclarationRenameChange) {
                renameChanges.push(moduleDeclarationRenameChange);
            }
            const [edits, textDocumentEdits] = RenameProvider.getRenameEdits(affectedNodes, newName);
            return {
                changes: edits, // Fallback if the client doesn't implement documentChanges
                documentChanges: [...textDocumentEdits, ...renameChanges], //Order seems to be important here
            };
        };
        this.handlePrepareRenameRequest = (params) => {
            var _a, _b, _c, _d;
            this.connection.console.info(`Prepare rename was requested`);
            const affectedNodes = renameUtils_1.RenameUtils.getRenameAffectedNodes(params.program, params.textDocument.uri, params.position);
            if (affectedNodes === null || affectedNodes === void 0 ? void 0 : affectedNodes.references.length) {
                let node = affectedNodes.originalNode;
                // For a qualified value Component.Test.func, if renamed the module name, select the whole thing
                if (node.type === "upper_case_identifier" &&
                    ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === "value_qid") {
                    const moduleNameNodes = (_b = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("upper_case_identifier", node.parent)) !== null && _b !== void 0 ? _b : [];
                    const first = moduleNameNodes[0];
                    const last = moduleNameNodes[moduleNameNodes.length - 1];
                    return vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(first.startPosition.row, first.startPosition.column), vscode_languageserver_1.Position.create(last.endPosition.row, last.endPosition.column));
                }
                // Select the whole module uppercase id `Component.Test` instead of just `Test`
                if (((_d = (_c = node.parent) === null || _c === void 0 ? void 0 : _c.parent) === null || _d === void 0 ? void 0 : _d.type) === "module_declaration") {
                    node = node.parent;
                }
                return vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(node.startPosition.row, node.startPosition.column), vscode_languageserver_1.Position.create(node.endPosition.row, node.endPosition.column));
            }
            return null;
        };
        this.connection = tsyringe_1.container.resolve("Connection");
        this.connection.onPrepareRename(new elmWorkspaceMatcher_1.ElmWorkspaceMatcher((params) => vscode_uri_1.URI.parse(params.textDocument.uri)).handle(this.handlePrepareRenameRequest.bind(this)));
        this.connection.onRenameRequest(new elmWorkspaceMatcher_1.ElmWorkspaceMatcher((params) => vscode_uri_1.URI.parse(params.textDocument.uri)).handle(this.handleRenameRequest.bind(this)));
    }
    static getRenameEdits(affectedNodes, newName) {
        var _a, _b, _c, _d;
        const edits = {};
        let originalName = (_a = affectedNodes === null || affectedNodes === void 0 ? void 0 : affectedNodes.originalNode.text) !== null && _a !== void 0 ? _a : "";
        // Helps us to rename fully qualified functions without changing the last part
        if ((affectedNodes === null || affectedNodes === void 0 ? void 0 : affectedNodes.originalNode.type) === "upper_case_identifier" &&
            (((_b = affectedNodes.originalNode.parent) === null || _b === void 0 ? void 0 : _b.type) === "value_qid" ||
                ((_c = affectedNodes.originalNode.parent) === null || _c === void 0 ? void 0 : _c.type) === "upper_case_qid")) {
            const moduleNameNodes = (_d = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("upper_case_identifier", affectedNodes.originalNode.parent)) !== null && _d !== void 0 ? _d : [];
            originalName = moduleNameNodes.map((node) => node.text).join(".");
        }
        affectedNodes === null || affectedNodes === void 0 ? void 0 : affectedNodes.references.forEach((a) => {
            if (!edits[a.uri]) {
                edits[a.uri] = [];
            }
            const startColumn = a.node.startPosition.column + a.node.text.indexOf(originalName);
            const endColumn = startColumn + originalName.length;
            edits[a.uri].push(vscode_languageserver_1.TextEdit.replace(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(a.node.startPosition.row, startColumn), vscode_languageserver_1.Position.create(a.node.endPosition.row, endColumn)), newName));
        });
        const textDocumentEdits = [];
        for (const key in edits) {
            if (Object.prototype.hasOwnProperty.call(edits, key)) {
                const element = edits[key];
                textDocumentEdits.push(vscode_languageserver_1.TextDocumentEdit.create(vscode_languageserver_1.OptionalVersionedTextDocumentIdentifier.create(key, null), element));
            }
        }
        return [edits, textDocumentEdits];
    }
    createModuleDeclarationRenameChange(affectedNodes, program, params, newName) {
        var _a, _b;
        if (((_b = (_a = affectedNodes === null || affectedNodes === void 0 ? void 0 : affectedNodes.originalNode.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.type) === "module_declaration") {
            const newUri = this.generateUriFromModuleName(newName, program, params.textDocument.uri);
            if (newUri) {
                return {
                    kind: "rename",
                    oldUri: params.textDocument.uri,
                    newUri: newUri.toString(),
                };
            }
        }
    }
    uppercaseNewNameIfModuleDeclaration(newName, affectedNodes) {
        var _a, _b;
        if (((_b = (_a = affectedNodes === null || affectedNodes === void 0 ? void 0 : affectedNodes.originalNode.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.type) === "module_declaration") {
            return newName
                .split(".")
                .map((a) => a.charAt(0).toUpperCase() + a.slice(1))
                .join(".");
        }
        else {
            return newName;
        }
    }
    generateUriFromModuleName(moduleName, program, file) {
        const sourceDir = program.getSourceDirectoryOfFile(file);
        // The file is not in a source dir (shouldn't happen)
        if (!sourceDir) {
            return;
        }
        const newUri = `${sourceDir}/${moduleName.replace(/\./g, "/")}.elm`;
        return vscode_uri_1.URI.file(newUri);
    }
}
exports.RenameProvider = RenameProvider;
//# sourceMappingURL=renameProvider.js.map