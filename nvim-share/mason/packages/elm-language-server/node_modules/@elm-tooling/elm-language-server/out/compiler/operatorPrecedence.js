"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Binary = exports.Operand = exports.BinaryExprTree = void 0;
class BinaryExprTree {
    constructor(type) {
        this.type = type;
    }
    static parse(expression, operatorPrecedences) {
        return BinaryExprTree.parseExpression(expression, operatorPrecedences, BinaryExprTree.DEFAULT_PRECEDENCE, 0)[0];
    }
    static parseExpression(expression, operatorPrecedences, precedence, index) {
        var _a;
        let left = new Operand(expression[index]);
        if (index >= expression.length - 1) {
            return [left, index + 1];
        }
        let i = index + 1;
        function nextPrecendence() {
            var _a, _b;
            if (i >= expression.length - 1) {
                return BinaryExprTree.DEFAULT_PRECEDENCE;
            }
            else {
                return ((_b = (_a = operatorPrecedences.get(expression[i])) === null || _a === void 0 ? void 0 : _a.precedence) !== null && _b !== void 0 ? _b : BinaryExprTree.DEFAULT_PRECEDENCE);
            }
        }
        while (precedence < nextPrecendence()) {
            const operator = expression[i];
            const funcPrecedence = operatorPrecedences.get(operator);
            const rightPrecedence = (funcPrecedence === null || funcPrecedence === void 0 ? void 0 : funcPrecedence.associativity) === "RIGHT"
                ? funcPrecedence.precedence - 1
                : (_a = funcPrecedence === null || funcPrecedence === void 0 ? void 0 : funcPrecedence.precedence) !== null && _a !== void 0 ? _a : BinaryExprTree.DEFAULT_PRECEDENCE;
            const result = BinaryExprTree.parseExpression(expression, operatorPrecedences, rightPrecedence, i + 1);
            left = new Binary(left, operator, result[0]);
            i = result[1];
        }
        return [left, i];
    }
}
exports.BinaryExprTree = BinaryExprTree;
BinaryExprTree.DEFAULT_PRECEDENCE = -1;
class Operand extends BinaryExprTree {
    constructor(operand) {
        super("Operand");
        this.operand = operand;
    }
}
exports.Operand = Operand;
class Binary extends BinaryExprTree {
    constructor(left, operator, right) {
        super("Binary");
        this.left = left;
        this.operator = operator;
        this.right = right;
    }
}
exports.Binary = Binary;
//# sourceMappingURL=operatorPrecedence.js.map