"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const importUtils_1 = require("../../util/importUtils");
const refactorEditUtils_1 = require("../../util/refactorEditUtils");
const treeUtils_1 = require("../../util/treeUtils");
const diagnostics_1 = require("../../../compiler/diagnostics");
const codeActionProvider_1 = require("../codeActionProvider");
const errorCodes = [diagnostics_1.Diagnostics.MissingValue.code];
const fixId = "import";
codeActionProvider_1.CodeActionProvider.registerCodeAction({
    errorCodes,
    fixId,
    preferredAction: {
        priority: 1,
        thereCanOnlyBeOne: true,
    },
    getCodeActions: (params) => {
        const valueNode = treeUtils_1.TreeUtils.getNamedDescendantForRange(params.sourceFile, params.range);
        return getPossibleImports(params, params.range).map((possibleImport) => {
            const edit = getEditFromPossibleImport(params.sourceFile, params.range, possibleImport);
            const valueToImport = getValueToImport(valueNode, possibleImport);
            const importAlias = (edit === null || edit === void 0 ? void 0 : edit.importAlias) ? ` as "${edit.importAlias}"` : "";
            return codeActionProvider_1.CodeActionProvider.getCodeAction(params, valueToImport
                ? `Import '${valueToImport}' from module "${possibleImport.module}"${importAlias}`
                : `Import module "${possibleImport.module}"${importAlias}`, edit ? [edit.edit] : []);
        });
    },
    getFixAllCodeAction: (params) => {
        const possibleImportsCache = new Map();
        return codeActionProvider_1.CodeActionProvider.getFixAllCodeAction("Add all missing imports", params, errorCodes, fixId, (edits, diagnostic) => {
            var _a;
            const firstPossibleImport = getPossibleImports(params, diagnostic.range, possibleImportsCache)[0];
            if (firstPossibleImport) {
                const edit = (_a = getEditFromPossibleImport(params.sourceFile, diagnostic.range, firstPossibleImport)) === null || _a === void 0 ? void 0 : _a.edit;
                if (edit && !edits.find((e) => e.newText === edit.newText)) {
                    edits.push(edit);
                }
            }
        });
    },
});
function getPossibleImports(params, range, possibleImportsCache) {
    const valueNode = treeUtils_1.TreeUtils.getNamedDescendantForRange(params.sourceFile, range);
    const cached = possibleImportsCache === null || possibleImportsCache === void 0 ? void 0 : possibleImportsCache.get(params.sourceFile.uri);
    const possibleImports = cached !== null && cached !== void 0 ? cached : importUtils_1.ImportUtils.getPossibleImports(params.program, params.sourceFile);
    possibleImportsCache === null || possibleImportsCache === void 0 ? void 0 : possibleImportsCache.set(params.sourceFile.uri, possibleImports);
    // Add import quick fixes
    if (valueNode) {
        return possibleImports.filter((exposed) => {
            if (exposed.value === valueNode.text) {
                return true;
            }
            if (valueNode.type === "upper_case_qid" ||
                valueNode.type === "value_qid") {
                const targetValue = valueNode.namedChildren[valueNode.namedChildren.length - 1].text;
                const targetModule = getTargetModule(valueNode);
                return (exposed.value === targetValue &&
                    (targetModule.includes(".")
                        ? exposed.module === targetModule
                        : exposed.module.endsWith(targetModule)));
            }
            return false;
        });
    }
    return [];
}
function getEditFromPossibleImport(sourceFile, range, possibleImport) {
    const valueNode = treeUtils_1.TreeUtils.getNamedDescendantForRange(sourceFile, range);
    const targetModule = getTargetModule(valueNode);
    const edit = refactorEditUtils_1.RefactorEditUtils.addImport(sourceFile.tree, possibleImport.module, getValueToImport(valueNode, possibleImport), targetModule);
    if (edit) {
        return {
            edit,
            importAlias: possibleImport.module !== targetModule ? targetModule : undefined,
        };
    }
}
function getValueToImport(valueNode, possibleImport) {
    var _a;
    return valueNode.type !== "upper_case_qid" && valueNode.type !== "value_qid"
        ? (_a = possibleImport.valueToImport) !== null && _a !== void 0 ? _a : possibleImport.value
        : undefined;
}
function getTargetModule(valueNode) {
    return valueNode.namedChildren
        .slice(0, valueNode.namedChildren.length - 2) // Dots are also namedNodes
        .map((a) => a.text)
        .join("");
}
//# sourceMappingURL=importCodeAction.js.map