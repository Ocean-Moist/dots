"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HintHelper = void 0;
const treeUtils_1 = require("./treeUtils");
class HintHelper {
    static createHint(node, typeString) {
        var _a;
        if (!node) {
            return;
        }
        if (node.type === "module_declaration") {
            return this.createHintFromModule(node);
        }
        else if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === "let_in_expr" ||
            (node.type === "lower_pattern" &&
                !!treeUtils_1.TreeUtils.findParentOfType("let_in_expr", node))) {
            return this.createHintFromDefinitionInLet(node, typeString);
        }
        else if (node.type === "field_type") {
            return this.createHintFromFieldType(node);
        }
        else if (node.type === "port_annotation") {
            const name = node.childForFieldName("name");
            const typeExpression = node.childForFieldName("typeExpression");
            if (name && typeExpression) {
                let comment = "";
                if (node.previousNamedSibling &&
                    node.previousNamedSibling.type === "block_comment") {
                    comment = node.previousNamedSibling.text;
                }
                return this.formatHint(`${name.text} : ${typeExpression.text}`, comment);
            }
        }
        else {
            return this.createHintFromDefinition(node, typeString);
        }
    }
    static createHintFromFunctionParameter(node, typeString) {
        const annotation = treeUtils_1.TreeUtils.getTypeOrTypeAliasOfFunctionParameter(node);
        if (annotation) {
            return this.formatHint(annotation.text, "Local parameter");
        }
        if (node && typeString && typeString !== "unknown") {
            return this.formatHint(`${node.text} : ${typeString}`, "Local parameter");
        }
        return "Local parameter";
    }
    static createHintForTypeAliasReference(annotation, fieldName, parentName) {
        return this.formatHint(annotation, parentName
            ? `Refers to the \`${fieldName}\` field on \`${parentName}\``
            : `Refers to the \`${fieldName}\` field`);
    }
    static createHintFromDefinitionInLet(declaration, typeString) {
        var _a, _b;
        if (declaration) {
            const comment = "Defined in local let scope";
            let annotation;
            if (declaration.previousNamedSibling) {
                if (declaration.previousNamedSibling.type === "type_annotation") {
                    annotation = declaration.previousNamedSibling.text;
                }
            }
            if (!annotation && typeString) {
                const functionName = (_b = (_a = treeUtils_1.TreeUtils.getFunctionNameNodeFromDefinition(declaration)) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : declaration.text;
                annotation = `${functionName} : ${typeString}`;
            }
            return this.formatHint(annotation !== null && annotation !== void 0 ? annotation : "", comment);
        }
    }
    static createHintFromFieldType(node) {
        var _a, _b;
        const typeAlias = treeUtils_1.TreeUtils.findParentOfType("type_alias_declaration", node);
        return this.formatHint(node.text, `Field${typeAlias
            ? ` on the type alias \`${(_b = (_a = typeAlias === null || typeAlias === void 0 ? void 0 : typeAlias.childForFieldName("name")) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : ""}\``
            : ""}`);
    }
    static createHintFromDefinitionInCaseBranch() {
        const comment = "Defined in local case branch";
        return this.formatHint("", comment);
    }
    static createHintFromDefinition(declaration, typeString) {
        var _a, _b, _c, _d, _e, _f;
        if (!declaration) {
            return;
        }
        let code;
        let comment = "";
        let annotation = "";
        if (declaration.type === "type_declaration" ||
            declaration.type === "type_alias_declaration") {
            code = declaration.text;
        }
        if (declaration.type === "union_variant") {
            if (((_b = (_a = declaration.parent) === null || _a === void 0 ? void 0 : _a.previousNamedSibling) === null || _b === void 0 ? void 0 : _b.type) !== "block_comment") {
                code = declaration.text;
                if (declaration.parent) {
                    const typeName = (_c = treeUtils_1.TreeUtils.findFirstNamedChildOfType("upper_case_identifier", declaration.parent)) === null || _c === void 0 ? void 0 : _c.text;
                    comment =
                        `A variant on the union type \`${typeName !== null && typeName !== void 0 ? typeName : "unknown"}\`` || "";
                }
            }
            else {
                declaration = declaration.parent ? declaration.parent : declaration;
            }
        }
        if (declaration.parent &&
            declaration.type === "function_declaration_left") {
            declaration = declaration.parent;
        }
        if (declaration.previousNamedSibling) {
            if (declaration.previousNamedSibling.type === "type_annotation") {
                annotation = declaration.previousNamedSibling.text;
                if (declaration.previousNamedSibling.previousNamedSibling &&
                    declaration.previousNamedSibling.previousNamedSibling.type ===
                        "block_comment") {
                    comment = declaration.previousNamedSibling.previousNamedSibling.text;
                }
            }
            else if (declaration.previousNamedSibling.type === "block_comment") {
                comment = declaration.previousNamedSibling.text;
            }
            if (declaration.type === "value_declaration" &&
                ((_d = declaration.firstNamedChild) === null || _d === void 0 ? void 0 : _d.type) === "function_declaration_left") {
                code = declaration.firstNamedChild.text;
            }
        }
        const name = (_f = (_e = declaration.firstNamedChild) === null || _e === void 0 ? void 0 : _e.firstNamedChild) === null || _f === void 0 ? void 0 : _f.text;
        if (name && typeString) {
            annotation = `${name} : ${typeString}`;
        }
        return this.formatHint(annotation, comment, code);
    }
    static createHintFromModule(moduleNode) {
        if (moduleNode) {
            let comment = "";
            if (moduleNode.nextNamedSibling &&
                moduleNode.nextNamedSibling.type === "block_comment") {
                comment = moduleNode.nextNamedSibling.text;
            }
            return this.formatHint("", comment);
        }
    }
    static formatHint(annotation, comment, code) {
        let value = "";
        if (annotation) {
            value += this.wrapCodeInMarkdown(annotation);
            if (value.length > 0 && (code || comment)) {
                value += "\n\n---\n\n";
            }
        }
        if (code) {
            value += this.wrapCodeInMarkdown(code);
        }
        if (comment) {
            value += this.stripComment(comment);
        }
        return value;
    }
    static stripComment(comment) {
        let newComment = comment;
        if (newComment.startsWith("{-|")) {
            newComment = newComment.slice(3);
        }
        if (newComment.startsWith("{-")) {
            newComment = newComment.slice(2);
        }
        if (newComment.endsWith("-}")) {
            newComment = newComment.slice(0, -2);
        }
        return newComment.trim();
    }
    static wrapCodeInMarkdown(code) {
        return `\n\`\`\`elm\n${code}\n\`\`\`\n`;
    }
}
exports.HintHelper = HintHelper;
//# sourceMappingURL=hintHelper.js.map