"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiagnosticsProvider = exports.convertToCompilerDiagnostic = exports.convertFromCompilerDiagnostic = void 0;
const tsyringe_1 = require("tsyringe");
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const cancellation_1 = require("../../cancellation");
const protocol_1 = require("../../protocol");
const delayer_1 = require("../../util/delayer");
const elmWorkspaceMatcher_1 = require("../../util/elmWorkspaceMatcher");
const multistepOperation_1 = require("../../util/multistepOperation");
const textDocumentEvents_1 = require("../../util/textDocumentEvents");
const astProvider_1 = require("../astProvider");
const diagnosticsRequest_1 = require("./diagnosticsRequest");
const elmLsDiagnostics_1 = require("./elmLsDiagnostics");
const elmMakeDiagnostics_1 = require("./elmMakeDiagnostics");
const fileDiagnostics_1 = require("./fileDiagnostics");
const elmReviewDiagnostics_1 = require("./elmReviewDiagnostics");
function convertFromCompilerDiagnostic(diag) {
    return {
        message: diag.message,
        source: diag.source,
        severity: diag.severity,
        range: diag.range,
        data: {
            uri: diag.uri,
            code: diag.code,
        },
        tags: diag.tags,
    };
}
exports.convertFromCompilerDiagnostic = convertFromCompilerDiagnostic;
function convertToCompilerDiagnostic(diag) {
    var _a;
    return {
        message: diag.message,
        source: diag.source,
        severity: (_a = diag.severity) !== null && _a !== void 0 ? _a : vscode_languageserver_1.DiagnosticSeverity.Warning,
        range: diag.range,
        code: diag.data.code,
        uri: diag.data.uri,
        tags: diag.tags,
    };
}
exports.convertToCompilerDiagnostic = convertToCompilerDiagnostic;
class PendingDiagnostics extends Map {
    getOrderedFiles() {
        return Array.from(this.entries())
            .sort((a, b) => a[1] - b[1])
            .map((a) => a[0]);
    }
}
let DiagnosticsProvider = class DiagnosticsProvider {
    constructor() {
        var _a, _b;
        this.changeSeq = 0;
        this.disposables = [];
        this.clientSettings = tsyringe_1.container.resolve("ClientSettings");
        this.elmMakeDiagnostics = tsyringe_1.container.resolve(elmMakeDiagnostics_1.ElmMakeDiagnostics);
        this.elmReviewDiagnostics = tsyringe_1.container.resolve(elmReviewDiagnostics_1.ElmReviewDiagnostics);
        this.elmLsDiagnostics = tsyringe_1.container.resolve(elmLsDiagnostics_1.ElmLsDiagnostics);
        this.documentEvents = tsyringe_1.container.resolve(textDocumentEvents_1.TextDocumentEvents);
        this.connection = tsyringe_1.container.resolve("Connection");
        this.events = tsyringe_1.container.resolve(textDocumentEvents_1.TextDocumentEvents);
        this.elmWorkspaceMatcher = new elmWorkspaceMatcher_1.ElmWorkspaceMatcher((uri) => uri);
        this.diagnosticsOperation = new multistepOperation_1.MultistepOperation(this.connection);
        this.workspaces = tsyringe_1.container.resolve("ElmWorkspaces");
        const astProvider = tsyringe_1.container.resolve(astProvider_1.ASTProvider);
        this.currentDiagnostics = new Map();
        this.pendingDiagnostics = new PendingDiagnostics();
        this.diagnosticsDelayer = new delayer_1.Delayer(300);
        const clientInitiatedDiagnostics = (_b = (_a = this.clientSettings.extendedCapabilities) === null || _a === void 0 ? void 0 : _a.clientInitiatedDiagnostics) !== null && _b !== void 0 ? _b : false;
        const disableDiagnosticsOnChange = this.clientSettings.onlyUpdateDiagnosticsOnSave;
        const handleSaveOrOpen = (d) => {
            const program = this.elmWorkspaceMatcher.getProgramFor(vscode_uri_1.URI.parse(d.textDocument.uri));
            const sourceFile = program.getSourceFile(d.textDocument.uri);
            if (!sourceFile) {
                return;
            }
            if (program.getRootPath().scheme === "file") {
                void this.getElmMakeDiagnostics(sourceFile).then((hasElmMakeErrors) => {
                    if (hasElmMakeErrors) {
                        this.currentDiagnostics.forEach((_, uri) => {
                            this.updateDiagnostics(uri, 6 /* DiagnosticKind.ElmReview */, []);
                        });
                    }
                    else {
                        void this.getElmReviewDiagnostics(sourceFile);
                    }
                });
            }
            else {
                this.requestDiagnostics(sourceFile.uri);
            }
            // If we aren't doing them on change, we need to trigger them here
            if (disableDiagnosticsOnChange) {
                this.updateDiagnostics(sourceFile.uri, 2 /* DiagnosticKind.ElmLS */, this.elmLsDiagnostics.createDiagnostics(sourceFile, program));
            }
        };
        this.disposables.push(this.events.onDidOpen(handleSaveOrOpen));
        this.disposables.push(this.events.onDidSave(handleSaveOrOpen));
        if (clientInitiatedDiagnostics) {
            this.disposables.push(this.connection.onRequest(protocol_1.GetDiagnosticsRequest, (params, cancellationToken) => this.getDiagnostics(params.files, params.delay, cancellationToken)));
        }
        this.disposables.push(this.connection.onDidChangeConfiguration((params) => {
            this.clientSettings = params.settings;
            if (this.clientSettings.disableElmLSDiagnostics) {
                this.currentDiagnostics.forEach((_, uri) => this.updateDiagnostics(uri, 2 /* DiagnosticKind.ElmLS */, []));
            }
            else {
                this.workspaces.forEach((program) => {
                    if (!program.getForest(false)) {
                        return;
                    }
                    program.getSourceFiles().forEach((sourceFile) => {
                        if (sourceFile.writeable) {
                            this.updateDiagnostics(sourceFile.uri, 2 /* DiagnosticKind.ElmLS */, this.elmLsDiagnostics.createDiagnostics(sourceFile, program));
                        }
                    });
                });
            }
        }));
        if (!clientInitiatedDiagnostics && !disableDiagnosticsOnChange) {
            void this.requestAllDiagnostics();
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.disposables.push(astProvider.onTreeChange(({ sourceFile }) => {
            if (!clientInitiatedDiagnostics && !disableDiagnosticsOnChange) {
                this.requestDiagnostics(sourceFile.uri);
            }
        }));
        this.disposables.push(astProvider.onTreeDelete(({ uri }) => {
            this.deleteDiagnostics(uri);
        }));
        this.disposables.push(this.documentEvents.onDidChange((params) => {
            this.change();
            this.updateDiagnostics(params.textDocument.uri, 6 /* DiagnosticKind.ElmReview */, []);
            // We need to cancel the request as soon as possible
            if (!clientInitiatedDiagnostics && !disableDiagnosticsOnChange) {
                if (this.pendingRequest) {
                    this.pendingRequest.cancel();
                    this.pendingRequest = undefined;
                }
            }
        }));
    }
    interruptDiagnostics(f) {
        if (!this.pendingRequest) {
            return f();
        }
        this.pendingRequest.cancel();
        this.pendingRequest = undefined;
        const result = f();
        this.triggerDiagnostics();
        return result;
    }
    interruptDiagnosticsAsync(f) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.pendingRequest) {
                return f();
            }
            this.pendingRequest.cancel();
            this.pendingRequest = undefined;
            const result = yield f();
            this.triggerDiagnostics();
            return result;
        });
    }
    getCurrentDiagnostics(uri, kind) {
        var _a, _b, _c, _d;
        if (kind) {
            return (_b = (_a = this.currentDiagnostics.get(uri)) === null || _a === void 0 ? void 0 : _a.getForKind(kind)) !== null && _b !== void 0 ? _b : [];
        }
        return (_d = (_c = this.currentDiagnostics.get(uri)) === null || _c === void 0 ? void 0 : _c.get()) !== null && _d !== void 0 ? _d : [];
    }
    /**
     * Used for tests only
     */
    forceElmLsDiagnosticsUpdate(sourceFile, program) {
        this.updateDiagnostics(sourceFile.uri, 2 /* DiagnosticKind.ElmLS */, this.elmLsDiagnostics.createDiagnostics(sourceFile, program));
    }
    dispose() {
        this.disposables.forEach((d) => d.dispose());
    }
    requestDiagnostics(uri) {
        this.pendingDiagnostics.set(uri, Date.now());
        this.triggerDiagnostics();
    }
    requestAllDiagnostics() {
        return __awaiter(this, void 0, void 0, function* () {
            for (const program of this.workspaces) {
                yield program.init();
                if (!program.getForest(false)) {
                    return;
                }
                program.getSourceFiles().forEach(({ uri, writeable }) => {
                    if (writeable) {
                        this.pendingDiagnostics.set(uri, Date.now());
                    }
                });
            }
            this.triggerDiagnostics();
        });
    }
    triggerDiagnostics(delay = 200) {
        const sendPendingDiagnostics = () => {
            const orderedFiles = this.pendingDiagnostics.getOrderedFiles();
            if (this.pendingRequest) {
                this.pendingRequest.cancel();
                this.pendingRequest.files.forEach((file) => {
                    if (!orderedFiles.includes(file)) {
                        orderedFiles.push(file);
                    }
                });
                this.pendingRequest = undefined;
            }
            // Add all open files to request
            const openFiles = this.events.getOpenUris();
            openFiles.forEach((file) => {
                if (!orderedFiles.includes(file)) {
                    orderedFiles.push(file);
                }
            });
            if (orderedFiles.length) {
                const request = (this.pendingRequest = diagnosticsRequest_1.DiagnosticsRequest.execute(this.getDiagnostics.bind(this), orderedFiles, () => {
                    if (request === this.pendingRequest) {
                        this.pendingRequest = undefined;
                    }
                }));
            }
            this.pendingDiagnostics.clear();
        };
        void this.diagnosticsDelayer.trigger(sendPendingDiagnostics, delay);
    }
    updateDiagnostics(uri, kind, diagnostics) {
        let didUpdate = false;
        let fileDiagnostics = this.currentDiagnostics.get(uri);
        if (fileDiagnostics) {
            didUpdate = fileDiagnostics.update(kind, diagnostics);
        }
        else if (diagnostics.length > 0) {
            fileDiagnostics = new fileDiagnostics_1.FileDiagnostics(uri);
            fileDiagnostics.update(kind, diagnostics);
            this.currentDiagnostics.set(uri, fileDiagnostics);
            didUpdate = true;
        }
        if (didUpdate) {
            const fileDiagnostics = this.currentDiagnostics.get(uri);
            void this.connection.sendDiagnostics({
                uri,
                diagnostics: fileDiagnostics ? fileDiagnostics.get() : [],
            });
        }
    }
    deleteDiagnostics(uri) {
        this.currentDiagnostics.delete(uri);
        void this.connection.sendDiagnostics({
            uri,
            diagnostics: [],
        });
    }
    getDiagnostics(files, delay, cancellationToken) {
        const followMs = Math.min(delay, 200);
        const serverCancellationToken = new cancellation_1.ServerCancellationToken(cancellationToken);
        return new Promise((resolve) => this.diagnosticsOperation.startNew(cancellationToken, (next) => {
            const seq = this.changeSeq;
            let index = 0;
            const goNext = () => {
                index++;
                if (files.length > index) {
                    next.delay(followMs, checkOne);
                }
            };
            const checkOne = () => {
                if (this.changeSeq !== seq) {
                    return;
                }
                const uri = files[index];
                const program = this.elmWorkspaceMatcher.getProgramFor(vscode_uri_1.URI.parse(uri));
                const sourceFile = program.getSourceFile(uri);
                if (!sourceFile) {
                    goNext();
                    return;
                }
                next.immediate(() => {
                    this.updateDiagnostics(uri, 0 /* DiagnosticKind.ElmMake */, []);
                    this.updateDiagnostics(uri, 3 /* DiagnosticKind.Syntactic */, program
                        .getSyntacticDiagnostics(sourceFile)
                        .map(convertFromCompilerDiagnostic));
                    if (this.changeSeq !== seq) {
                        return;
                    }
                    next.promise(() => __awaiter(this, void 0, void 0, function* () {
                        const diagnostics = yield program.getSemanticDiagnosticsAsync(sourceFile, serverCancellationToken);
                        if (this.changeSeq !== seq) {
                            return;
                        }
                        this.updateDiagnostics(uri, 4 /* DiagnosticKind.Semantic */, diagnostics.map(convertFromCompilerDiagnostic));
                        next.immediate(() => {
                            this.updateDiagnostics(uri, 5 /* DiagnosticKind.Suggestion */, this.elmLsDiagnostics.createSuggestionDiagnostics(sourceFile, program, serverCancellationToken));
                            if (this.changeSeq !== seq) {
                                return;
                            }
                            if (!this.clientSettings.disableElmLSDiagnostics) {
                                next.immediate(() => {
                                    this.updateDiagnostics(uri, 2 /* DiagnosticKind.ElmLS */, this.elmLsDiagnostics.createDiagnostics(sourceFile, program));
                                    goNext();
                                });
                            }
                            else {
                                goNext();
                            }
                        });
                    }));
                });
            };
            if (files.length > 0 && this.changeSeq === seq) {
                next.delay(delay, checkOne);
            }
        }, resolve));
    }
    getElmMakeDiagnostics(sourceFile) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const elmMakeDiagnostics = yield this.elmMakeDiagnostics.createDiagnostics(sourceFile);
            this.resetDiagnostics(elmMakeDiagnostics, 0 /* DiagnosticKind.ElmMake */);
            elmMakeDiagnostics.forEach((diagnostics, diagnosticsUri) => {
                this.updateDiagnostics(diagnosticsUri, 3 /* DiagnosticKind.Syntactic */, []);
                this.updateDiagnostics(diagnosticsUri, 4 /* DiagnosticKind.Semantic */, []);
                this.updateDiagnostics(diagnosticsUri, 0 /* DiagnosticKind.ElmMake */, diagnostics);
            });
            this.currentDiagnostics.forEach((_, uri) => {
                if (!elmMakeDiagnostics.has(uri)) {
                    this.updateDiagnostics(uri, 0 /* DiagnosticKind.ElmMake */, []);
                }
            });
            // return true if elm make returned non empty results,
            // it returns `new Map([[sourceFile.uri, []]])` in case of no errors
            return !(elmMakeDiagnostics.size === 1 &&
                ((_a = elmMakeDiagnostics.get(sourceFile.uri)) === null || _a === void 0 ? void 0 : _a.length) === 0);
        });
    }
    getElmReviewDiagnostics(sourceFile) {
        return __awaiter(this, void 0, void 0, function* () {
            const elmReviewDiagnostics = yield this.elmReviewDiagnostics.createDiagnostics(sourceFile);
            // remove old elm-review diagnostics
            this.resetDiagnostics(elmReviewDiagnostics, 6 /* DiagnosticKind.ElmReview */);
            // add new elm-review diagnostics
            elmReviewDiagnostics.forEach((diagnostics, uri) => {
                this.updateDiagnostics(uri, 6 /* DiagnosticKind.ElmReview */, diagnostics);
            });
        });
    }
    resetDiagnostics(diagnosticList, diagnosticKind) {
        this.currentDiagnostics.forEach((fileDiagnostics, diagnosticsUri) => {
            if (!diagnosticList.has(diagnosticsUri) &&
                fileDiagnostics.getForKind(diagnosticKind).length > 0) {
                diagnosticList.set(diagnosticsUri, []);
            }
        });
    }
    change() {
        this.changeSeq++;
    }
};
exports.DiagnosticsProvider = DiagnosticsProvider;
exports.DiagnosticsProvider = DiagnosticsProvider = __decorate([
    (0, tsyringe_1.injectable)(),
    __metadata("design:paramtypes", [])
], DiagnosticsProvider);
//# sourceMappingURL=diagnosticsProvider.js.map