"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCancellationStrategyFromArgv = exports.getCancellationFilePath = exports.getCancellationFolderPath = exports.FileBasedCancellationTokenSource = void 0;
const fs = __importStar(require("fs"));
const os = __importStar(require("os"));
const path_1 = __importDefault(require("path"));
const vscode_languageserver_1 = require("vscode-languageserver");
/**
 * File based cancellation mostly taken from pyright: https://github.com/microsoft/pyright/blob/a9d2528574087cc2f8c10a7c3aaeb287eb64a870/packages/pyright-internal/src/common/cancellationUtils.ts#L48
 */
class FileBasedToken {
    constructor(_cancellationFilePath) {
        this._cancellationFilePath = _cancellationFilePath;
        this._isCancelled = false;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this.dispose();
            }
        }
    }
    get isCancellationRequested() {
        if (this._isCancelled) {
            return true;
        }
        if (this._pipeExists()) {
            // the first time it encounters cancellation file, it will
            // cancel itself and raise cancellation event.
            // in this mode, cancel() might not be called explicitly by jsonrpc layer
            this.cancel();
        }
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (!this._emitter) {
            this._emitter = new vscode_languageserver_1.Emitter();
        }
        return this._emitter.event;
    }
    dispose() {
        if (this._emitter) {
            this._emitter.dispose();
            this._emitter = undefined;
        }
    }
    _pipeExists() {
        try {
            fs.statSync(this._cancellationFilePath);
            return true;
        }
        catch (e) {
            return false;
        }
    }
}
class FileBasedCancellationTokenSource {
    constructor(_cancellationFilePath) {
        this._cancellationFilePath = _cancellationFilePath;
    }
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new FileBasedToken(this._cancellationFilePath);
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = vscode_languageserver_1.CancellationToken.Cancelled;
        }
        else {
            this._token.cancel();
        }
    }
    dispose() {
        if (!this._token) {
            // ensure to initialize with an empty token if we had none
            this._token = vscode_languageserver_1.CancellationToken.None;
        }
        else if (this._token instanceof FileBasedToken) {
            // actually dispose
            this._token.dispose();
        }
    }
}
exports.FileBasedCancellationTokenSource = FileBasedCancellationTokenSource;
function getCancellationFolderPath(folderName) {
    return path_1.default.join(os.tmpdir(), "elm-language-server-cancellation", folderName);
}
exports.getCancellationFolderPath = getCancellationFolderPath;
function getCancellationFilePath(folderName, id) {
    return path_1.default.join(getCancellationFolderPath(folderName), `cancellation-${String(id)}.tmp`);
}
exports.getCancellationFilePath = getCancellationFilePath;
class FileCancellationReceiverStrategy {
    constructor(folderName) {
        this.folderName = folderName;
    }
    createCancellationTokenSource(id) {
        return new FileBasedCancellationTokenSource(getCancellationFilePath(this.folderName, id));
    }
}
let cancellationFolderName;
function getCancellationStrategyFromArgv(argv) {
    let receiver;
    for (let i = 0; i < argv.length; i++) {
        const arg = argv[i];
        if (arg === "--cancellationReceive") {
            receiver = createReceiverStrategyFromArgv(argv[i + 1]);
        }
        else {
            const args = arg.split("=");
            if (args[0] === "--cancellationReceive") {
                receiver = createReceiverStrategyFromArgv(args[1]);
            }
        }
    }
    if (receiver && !cancellationFolderName) {
        cancellationFolderName = receiver
            .folderName;
    }
    receiver = receiver ? receiver : vscode_languageserver_1.CancellationReceiverStrategy.Message;
    return { receiver, sender: vscode_languageserver_1.CancellationSenderStrategy.Message };
    function createReceiverStrategyFromArgv(arg) {
        const folderName = extractCancellationFolderName(arg);
        return folderName
            ? new FileCancellationReceiverStrategy(folderName)
            : undefined;
    }
    function extractCancellationFolderName(arg) {
        const fileRegex = /^file:(.+)$/;
        const folderName = fileRegex.exec(arg);
        return folderName ? folderName[1] : undefined;
    }
}
exports.getCancellationStrategyFromArgv = getCancellationStrategyFromArgv;
//# sourceMappingURL=cancellation.js.map