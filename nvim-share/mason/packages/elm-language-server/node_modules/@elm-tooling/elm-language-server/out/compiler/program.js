"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Program = void 0;
const tsyringe_1 = require("tsyringe");
const vscode_uri_1 = require("vscode-uri");
const elmPackageCache_1 = require("./elmPackageCache");
const forest_1 = require("./forest");
const utils = __importStar(require("./utils/elmUtils"));
const possibleImportsCache_1 = require("../common/util/possibleImportsCache");
const typeCache_1 = require("./typeCache");
const typeChecker_1 = require("./typeChecker");
const commandManager_1 = require("../common/commandManager");
class Program {
    constructor(rootPath, programHost) {
        this.rootPath = rootPath;
        this.dirty = true;
        this.resolvedPackageCache = new Map();
        this.filesWatching = new Set();
        this._isInitialized = false;
        this.disposables = [];
        this.checkedKernelFiles = new Set();
        this.settings = tsyringe_1.container.resolve("Settings");
        this.connection = tsyringe_1.container.resolve("Connection");
        this.parser = tsyringe_1.container.resolve("Parser");
        this.connection.console.info(`Starting language server for folder: ${this.rootPath.toString()}`);
        this.typeCache = new typeCache_1.TypeCache();
        this.possibleImportsCache = new possibleImportsCache_1.PossibleImportsCache();
        this.diagnosticsCache = new Map();
        this.host = programHost;
    }
    init(progressCallback) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this._isInitialized) {
                return;
            }
            if (this._initializePromise) {
                (_a = this._initializeProgressCallback) !== null && _a !== void 0 ? _a : (this._initializeProgressCallback = progressCallback);
                return this._initializePromise;
            }
            this._initializePromise = this.initWorkspace();
            yield this._initializePromise;
            this._isInitialized = true;
        });
    }
    get isInitialized() {
        return this._isInitialized;
    }
    hasDocument(uri) {
        var _a;
        return !!((_a = this.forest) === null || _a === void 0 ? void 0 : _a.getTree(uri.toString()));
    }
    isInSourceDirectory(uri) {
        return !!this.getSourceDirectoryOfFile(uri);
    }
    getSourceDirectoryOfFile(uri) {
        if (!this.rootProject) {
            return undefined;
        }
        uri = vscode_uri_1.URI.parse(uri).toString();
        return [
            ...this.rootProject.sourceDirectories,
            ...this.rootProject.testDirectories,
        ].find((elmFolder) => uri.startsWith(elmFolder));
    }
    getSourceFile(uri) {
        return this.getForest().getByUri(uri);
    }
    getSourceFiles() {
        return Array.from(this.getForest().sourceFiles.values());
    }
    getSourceFileOfImportableModule(sourceFile, importableModuleName) {
        let moduleUri = sourceFile.project.moduleToUriMap.get(importableModuleName);
        if (!moduleUri && sourceFile.isTestFile) {
            moduleUri =
                sourceFile.project.testModuleToUriMap.get(importableModuleName);
        }
        if (moduleUri) {
            return this.getSourceFile(moduleUri);
        }
        else {
            return undefined;
        }
    }
    getKernelSourceFileOfImportableModule(sourceFile, importableModuleName) {
        var _a, _b;
        if (utils.nameIsKernel(importableModuleName) &&
            utils.isKernelProject(sourceFile.project)) {
            const moduleUri = (_a = sourceFile.project.moduleToUriMap.get(importableModuleName)) !== null && _a !== void 0 ? _a : utils
                .getModuleUri(importableModuleName, vscode_uri_1.Utils.joinPath(vscode_uri_1.URI.parse(sourceFile.project.uri), "src"), sourceFile.project)
                .toString();
            const kernelSourceFile = this.getForest().getKernelSourceFile(moduleUri);
            if (kernelSourceFile) {
                return kernelSourceFile;
            }
            if (!this.checkedKernelFiles.has(moduleUri)) {
                this.checkedKernelFiles.add(moduleUri);
                if (this.host.fileExists(vscode_uri_1.URI.parse(moduleUri))) {
                    sourceFile.project.moduleToUriMap.set(importableModuleName, moduleUri);
                    return this.getForest().setKernelSourceFile(moduleUri, sourceFile.project, (_b = sourceFile.maintainerAndPackageName) !== null && _b !== void 0 ? _b : "", importableModuleName);
                }
            }
        }
    }
    getForest(synchronize = true) {
        if (this.dirty && synchronize) {
            this.forest.synchronize();
            this.dirty = false;
        }
        return this.forest;
    }
    getRootPath() {
        return this.rootPath;
    }
    getTypeCache() {
        return this.typeCache;
    }
    getTypeChecker() {
        var _a;
        if (this.dirty) {
            this.forest.synchronize();
            this.dirty = false;
        }
        return (_a = this.typeChecker) !== null && _a !== void 0 ? _a : (this.typeChecker = (0, typeChecker_1.createTypeChecker)(this));
    }
    markAsDirty() {
        if (!this.dirty) {
            this.dirty = true;
            this.typeChecker = undefined;
            this.diagnosticsCache.clear();
        }
    }
    getPossibleImportsCache() {
        return this.possibleImportsCache;
    }
    getSemanticDiagnostics(sourceFile, cancellationToken) {
        const cached = this.diagnosticsCache.get(sourceFile.uri);
        if (cached) {
            return cached;
        }
        const diagnostics = this.getTypeChecker().getDiagnostics(sourceFile, cancellationToken);
        this.diagnosticsCache.set(sourceFile.uri, diagnostics);
        return diagnostics;
    }
    getSemanticDiagnosticsAsync(sourceFile, cancellationToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const cached = this.diagnosticsCache.get(sourceFile.uri);
            if (cached) {
                return Promise.resolve(cached);
            }
            const diagnostics = yield this.getTypeChecker().getDiagnosticsAsync(sourceFile, cancellationToken);
            this.diagnosticsCache.set(sourceFile.uri, diagnostics);
            return diagnostics;
        });
    }
    getSyntacticDiagnostics(sourceFile) {
        // Getting the type checker will bind the file if its not
        this.getTypeChecker();
        return [...sourceFile.parseDiagnostics, ...sourceFile.bindDiagnostics];
    }
    getSuggestionDiagnostics(sourceFile, cancellationToken) {
        return this.getTypeChecker().getSuggestionDiagnostics(sourceFile, cancellationToken);
    }
    getImportableModules(sourceFile) {
        return Array.from(sourceFile.project.moduleToUriMap.entries()).map(([moduleName, uri]) => ({
            moduleName,
            uri,
        }));
    }
    dispose() {
        this.disposables.forEach((disposable) => disposable.dispose());
    }
    initWorkspace() {
        return __awaiter(this, void 0, void 0, function* () {
            const clientSettings = yield this.settings.getClientSettings();
            const pathToElmJson = vscode_uri_1.Utils.joinPath(this.rootPath, "elm.json");
            this.connection.console.info(`Reading elm.json from ${pathToElmJson.toString()}`);
            if (!this.filesWatching.has(pathToElmJson.toString())) {
                this.disposables.push(this.host.watchFile(pathToElmJson, () => {
                    void this.connection.window
                        .createWorkDoneProgress()
                        .then((progress) => {
                        progress.begin("Restarting Elm Language Server", 0);
                        this._initializeProgressCallback = (percent) => {
                            progress.report(percent, `${percent.toFixed(0)}%`);
                        };
                        this.initWorkspace()
                            .then(() => progress.done())
                            .catch(() => {
                            //
                        });
                    });
                }));
                this.filesWatching.add(pathToElmJson.toString());
            }
            try {
                elmPackageCache_1.ElmPackageCache.packagesRoot = this.host.getElmPackagesRoot(this.rootPath, clientSettings);
                try {
                    this.elmPackageCache = new elmPackageCache_1.ElmPackageCache(this.loadElmJson.bind(this), this.host);
                }
                catch (error) {
                    if (error instanceof Error && error.stack) {
                        this.connection.window.showErrorMessage(`Failed constructing ElmPackageCache for ${pathToElmJson.toString()}:\n${error.stack}`);
                    }
                    this.connection.window.showInformationMessage("The package cache is probably broken. Try a restart after removing '~/.elm' or '%APPDATA%\\elm'." +
                        "If the error still occurs, try running 'elm init' in a different folder." +
                        "If the error appears again, check your PATH for multiple elm installations and verify your installed version");
                    throw error;
                }
                this.rootProject = yield this.loadRootProject(pathToElmJson);
                this.forest = new forest_1.Forest(this.rootProject);
                // Stage 1 is finding all elm files in the project
                // Stage 2 is parsing all elm files in the project
                const PROGRESS_STAGES = 2;
                const totalProgress = { percent: 0 };
                const stageProgressCallback = (percent) => {
                    var _a;
                    (_a = this._initializeProgressCallback) === null || _a === void 0 ? void 0 : _a.call(this, (totalProgress.percent += percent / PROGRESS_STAGES));
                };
                const elmFilePaths = yield this.findElmFilesInProject(this.rootProject, stageProgressCallback);
                this.connection.console.info(`Found ${elmFilePaths.length} files to add to the project`);
                if (elmFilePaths.every((a) => a.project !== this.rootProject)) {
                    this.connection.window.showErrorMessage("The path or paths you entered in the 'source-directories' field of your 'elm.json' does not contain any elm files.");
                }
                const promiseList = [];
                const PARSE_STAGES = 2;
                const progressDelta = 100 / (elmFilePaths.length * PARSE_STAGES);
                for (const filePath of elmFilePaths) {
                    stageProgressCallback(progressDelta);
                    promiseList.push(this.readAndAddToForest(filePath).then((result) => {
                        stageProgressCallback(progressDelta);
                        return result;
                    }));
                }
                yield Promise.all(promiseList);
                commandManager_1.CommandManager.initHandlers(this.connection);
                this.connection.console.info(`Done parsing all files for ${pathToElmJson.toString()}`);
            }
            catch (error) {
                if (error instanceof Error && error.stack) {
                    this.connection.console.error(`Error parsing files for ${pathToElmJson.toString()}:\n${error.stack}`);
                }
            }
            if (this.forest === null) {
                this.connection.window.showWarningMessage(`Extension will not work at all: workspace initialization failed for ${pathToElmJson.toString()}` +
                    "For more information, check your extension logs (VSCode: F1 > Output, dropdown on the right, 'Elm (project name)')");
            }
        });
    }
    loadRootProject(elmJsonPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const elmJson = yield this.loadElmJson(elmJsonPath);
            if (elmJson.type === "application") {
                const allDependencies = new Map(Object.entries(Object.assign(Object.assign(Object.assign(Object.assign({}, elmJson.dependencies.direct), elmJson.dependencies.indirect), elmJson["test-dependencies"].direct), elmJson["test-dependencies"].indirect)).map(([dep, version]) => [dep, utils.parseVersion(version)]));
                return {
                    type: "application",
                    uri: this.rootPath.toString(),
                    sourceDirectories: elmJson["source-directories"].map((folder) => vscode_uri_1.Utils.resolvePath(this.rootPath, folder).toString()),
                    testDirectories: [vscode_uri_1.Utils.joinPath(this.rootPath, "tests").toString()],
                    dependencies: yield this.loadDependencyMap(elmJson.dependencies.direct, allDependencies),
                    testDependencies: yield this.loadDependencyMap(elmJson["test-dependencies"].direct, allDependencies),
                    moduleToUriMap: new Map(),
                    testModuleToUriMap: new Map(),
                };
            }
            else {
                const deps = new Map(Object.entries(Object.assign(elmJson.dependencies, elmJson["test-dependencies"])).map(([dep, version]) => [dep, utils.parseConstraint(version)]));
                const solvedVersions = yield utils.solveDependencies(this.elmPackageCache, deps);
                if (!solvedVersions) {
                    this.connection.window.showErrorMessage("There is a problem with elm.json. Could not solve dependencies with the given constraints. Try running `elm make` to install missing dependencies.");
                    throw new Error("Unsolvable package constraints");
                }
                return {
                    type: "package",
                    uri: this.rootPath.toString(),
                    sourceDirectories: [vscode_uri_1.Utils.joinPath(this.rootPath, "src").toString()],
                    testDirectories: [vscode_uri_1.Utils.joinPath(this.rootPath, "tests").toString()],
                    dependencies: yield this.loadDependencyMap(elmJson.dependencies, solvedVersions),
                    testDependencies: yield this.loadDependencyMap(elmJson["test-dependencies"], solvedVersions),
                    exposedModules: new Set(utils.flattenExposedModules(elmJson["exposed-modules"])),
                    moduleToUriMap: new Map(),
                    maintainerAndPackageName: elmJson.name,
                    testModuleToUriMap: new Map(),
                    isDependency: false,
                };
            }
        });
    }
    loadPackage(packageName, packageVersions) {
        return __awaiter(this, void 0, void 0, function* () {
            const version = packageVersions.get(packageName);
            if (!version) {
                throw new Error("Problem getting package version");
            }
            // Version shouldn't be necessary, but it won't hurt
            const cacheKey = `${packageName}@${version.string}`;
            const cached = this.resolvedPackageCache.get(cacheKey);
            if (cached) {
                return Promise.resolve(cached);
            }
            const maintainer = packageName.substring(0, packageName.indexOf("/"));
            const name = packageName.substring(packageName.indexOf("/") + 1, packageName.length);
            const pathToPackageWithVersion = vscode_uri_1.Utils.joinPath(elmPackageCache_1.ElmPackageCache.packagesRoot, `${maintainer}/${name}/${version.string}`);
            const elmJsonPath = vscode_uri_1.Utils.joinPath(pathToPackageWithVersion, "elm.json");
            const elmJson = yield this.loadElmJson(elmJsonPath);
            if (elmJson.type === "package") {
                const resolvedPackage = {
                    type: "package",
                    uri: pathToPackageWithVersion.toString(),
                    sourceDirectories: [
                        vscode_uri_1.Utils.joinPath(pathToPackageWithVersion, "src").toString(),
                    ],
                    testDirectories: [
                        vscode_uri_1.Utils.joinPath(pathToPackageWithVersion, "tests").toString(),
                    ],
                    dependencies: yield this.loadDependencyMap(elmJson.dependencies, packageVersions),
                    testDependencies: new Map(),
                    exposedModules: new Set(utils.flattenExposedModules(elmJson["exposed-modules"])),
                    moduleToUriMap: new Map(),
                    maintainerAndPackageName: elmJson.name,
                    testModuleToUriMap: new Map(),
                    isDependency: true,
                };
                this.resolvedPackageCache.set(cacheKey, resolvedPackage);
                return resolvedPackage;
            }
            else {
                throw new Error("Should never happen");
            }
        });
    }
    loadDependencyMap(deps, packageVersions) {
        return __awaiter(this, void 0, void 0, function* () {
            const dependencyMap = new Map();
            for (const dep in deps) {
                dependencyMap.set(dep, yield this.loadPackage(dep, packageVersions));
            }
            return dependencyMap;
        });
    }
    /**
     * Get all unique source directories from project dependency tree
     */
    getSourceDirectories(project) {
        const sourceDirs = new Map([
            ...project.sourceDirectories,
            ...(project === this.rootProject ? project.testDirectories : []),
        ].map((sourceDir) => [vscode_uri_1.URI.parse(sourceDir).toString(), project]));
        project.dependencies.forEach((dep) => this.getSourceDirectories(dep).forEach((project, sourceDir) => sourceDirs.set(sourceDir, project)));
        if (project === this.rootProject) {
            project.testDependencies.forEach((dep) => this.getSourceDirectories(dep).forEach((project, sourceDir) => sourceDirs.set(sourceDir, project)));
        }
        return sourceDirs;
    }
    findElmFilesInProject(project, progressCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            const elmFilePathPromises = [];
            const sourceDirectories = this.getSourceDirectories(project);
            const progressDelta = 100 / sourceDirectories.size;
            sourceDirectories.forEach((project, sourceDir) => {
                elmFilePathPromises.push(this.findElmFilesInProjectWorker(vscode_uri_1.URI.parse(sourceDir), project).then((data) => {
                    progressCallback(progressDelta);
                    return data;
                }));
            });
            const elmFiles = (yield Promise.all(elmFilePathPromises)).flatMap((a) => a);
            this.findExposedModulesOfDependencies(project);
            // If we have a tree, then it means it is a package that we need to check for internal dependencies
            const unresolvedFiles = elmFiles.filter((elmFile) => elmFile.tree);
            while (unresolvedFiles.length > 0) {
                const elmFile = unresolvedFiles.shift();
                if (!elmFile || !elmFile.tree) {
                    this.connection.console.error("Unexpected error occurred while resolving internal dependencies");
                    continue;
                }
                const promies = elmFile.tree.rootNode.children
                    .filter((a) => a.type === "import_clause")
                    .map((imp) => imp.childForFieldName("moduleName"))
                    .map((moduleNode) => __awaiter(this, void 0, void 0, function* () {
                    if (!moduleNode) {
                        return;
                    }
                    const moduleName = moduleNode.text;
                    // Only package projects can have unresolved internal dependencies
                    const project = elmFile.project;
                    if (project.type === "package" &&
                        !project.moduleToUriMap.has(moduleName)) {
                        // We need to try for each source directory, but only 1 will work
                        for (const sourceDir of project.sourceDirectories) {
                            const elmFile = yield this.tryAddModule(moduleName, vscode_uri_1.URI.parse(sourceDir), project);
                            if (elmFile) {
                                elmFiles.push(elmFile);
                                // Kernel files won't have a tree and don't need further processing
                                if (elmFile.tree) {
                                    unresolvedFiles.push(elmFile);
                                }
                            }
                        }
                    }
                }));
                yield Promise.all(promies);
            }
            return elmFiles;
        });
    }
    findElmFilesInProjectWorker(sourceDir, project) {
        return __awaiter(this, void 0, void 0, function* () {
            const elmFiles = [];
            const maintainerAndPackageName = project.type === "package" ? project.maintainerAndPackageName : undefined;
            const isDependency = project.type === "package" ? project.isDependency : false;
            this.connection.console.info(`Glob ${sourceDir.toString()}/**/*.elm`);
            // If it is a virtual package then we can't find elm files using glob
            // We need to use the exposed modules and then for each file follow the imports to find internal modules
            // We do this in the findElmFilesInProject after we have loaded all the initial files
            if (project.type === "package" && sourceDir.scheme === "elm-virtual-file") {
                const promises = Array.from(project.exposedModules.values()).map((moduleName) => __awaiter(this, void 0, void 0, function* () {
                    const elmFile = yield this.tryAddModule(moduleName, sourceDir, project);
                    if (elmFile) {
                        elmFiles.push(elmFile);
                    }
                }));
                yield Promise.all(promises);
            }
            else {
                (yield this.host.readDirectory(sourceDir, /* include */ "**/*.elm")).forEach((elmFilePath) => {
                    var _a, _b;
                    const moduleName = utils.getModuleName(elmFilePath.toString(), sourceDir.toString());
                    const isTestFile = project.type === "application" &&
                        ((_b = (_a = this.getSourceDirectoryOfFile(elmFilePath.toString())) === null || _a === void 0 ? void 0 : _a.endsWith("tests")) !== null && _b !== void 0 ? _b : false);
                    if (isTestFile) {
                        project.testModuleToUriMap.set(moduleName, elmFilePath.toString());
                    }
                    else {
                        project.moduleToUriMap.set(moduleName, elmFilePath.toString());
                    }
                    elmFiles.push({
                        maintainerAndPackageName,
                        path: elmFilePath,
                        project,
                        isTestFile,
                        isDependency,
                        isKernel: false,
                    });
                });
            }
            return elmFiles;
        });
    }
    tryAddModule(moduleName, sourceDir, project) {
        return __awaiter(this, void 0, void 0, function* () {
            const modulePath = utils.getModuleUri(moduleName, sourceDir, project);
            try {
                const fileContent = yield this.host.readFile(modulePath);
                project.moduleToUriMap.set(moduleName, modulePath.toString());
                const isKernel = modulePath.toString().endsWith(".js");
                return {
                    maintainerAndPackageName: project.maintainerAndPackageName,
                    path: modulePath,
                    project,
                    isTestFile: false,
                    isDependency: true,
                    tree: isKernel ? undefined : this.parser.parse(fileContent),
                    isKernel,
                    moduleName,
                };
            }
            catch (e) {
                // The module might be in another source directory
            }
        });
    }
    readAndAddToForest(elmFile) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const uri = elmFile.path.toString();
                this.connection.console.info(`Adding ${uri}`);
                if (elmFile.isKernel) {
                    this.forest.setKernelSourceFile(uri, elmFile.project, (_a = elmFile.maintainerAndPackageName) !== null && _a !== void 0 ? _a : "", (_b = elmFile.moduleName) !== null && _b !== void 0 ? _b : "");
                }
                else {
                    const tree = (_c = elmFile.tree) !== null && _c !== void 0 ? _c : this.parser.parse(yield this.host.readFile(elmFile.path));
                    this.forest.setSourceFile(uri, elmFile.project === this.rootProject, tree, elmFile.isTestFile, elmFile.isDependency, elmFile.project, elmFile.maintainerAndPackageName);
                }
            }
            catch (error) {
                if (error instanceof Error && error.stack) {
                    this.connection.console.error(error.stack);
                }
            }
        });
    }
    findExposedModulesOfDependencies(project) {
        // For each dependency, find every exposed module
        project.dependencies.forEach((dep) => {
            dep.moduleToUriMap.forEach((uri, module) => {
                if (dep.exposedModules.has(module)) {
                    project.moduleToUriMap.set(module, uri);
                }
            });
            this.findExposedModulesOfDependencies(dep);
        });
        if (project === this.rootProject) {
            project.testDependencies.forEach((dep) => {
                dep.moduleToUriMap.forEach((uri, module) => {
                    if (dep.exposedModules.has(module)) {
                        project.testModuleToUriMap.set(module, uri);
                    }
                });
                this.findExposedModulesOfDependencies(dep);
            });
        }
    }
    loadElmJson(elmJsonPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return JSON.parse(yield this.host.readFile(elmJsonPath));
        });
    }
}
exports.Program = Program;
//# sourceMappingURL=program.js.map