"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bindTreeContainer = void 0;
const multiMap_1 = require("../common/util/multiMap");
const treeUtils_1 = require("../common/util/treeUtils");
const utils_1 = require("../common/util/utils");
const syntaxNodeMap_1 = require("./utils/syntaxNodeMap");
const diagnostics_1 = require("./diagnostics");
const imports_1 = require("./imports");
function createSymbolMap() {
    return new multiMap_1.MultiMap();
}
function bindTreeContainer(sourceFile) {
    if (sourceFile.symbolLinks) {
        return;
    }
    const symbolLinks = new syntaxNodeMap_1.SyntaxNodeMap();
    const nonShadowableNames = new Set();
    let container;
    let parent;
    const treeCursor = sourceFile.tree.walk();
    bind();
    sourceFile.symbolLinks = symbolLinks;
    sourceFile.nonShadowableNames = nonShadowableNames;
    // Bind exposing must happen after symbolLinks is bound
    bindExposing();
    function forEachChild(func) {
        if (treeCursor.gotoFirstChild()) {
            func();
            while (treeCursor.gotoNextSibling()) {
                func();
            }
            treeCursor.gotoParent();
        }
    }
    function bind() {
        const node = treeCursor.currentNode();
        switch (node.type) {
            case "file":
            case "let_in_expr":
            case "anonymous_function_expr":
            case "case_of_branch":
                bindContainer(node);
                break;
            case "value_declaration":
                bindValueDeclaration(node);
                break;
            case "function_declaration_left":
                bindFunctionDeclarationLeft(node);
                break;
            case "type_declaration":
                bindTypeDeclaration(node);
                break;
            case "type_alias_declaration":
                bindTypeAliasDeclaration(node);
                break;
            case "lower_type_name":
                bindLowerTypeName(node);
                break;
            case "port_annotation":
                bindPortAnnotation(node);
                break;
            case "infix_declaration":
                bindInfixDeclaration(node);
                break;
            case "pattern":
                bindPattern(node);
                break;
            case "import_clause":
                bindImportClause(node);
                break;
            case "ERROR":
                sourceFile.parseDiagnostics.push((0, diagnostics_1.error)(node, diagnostics_1.Diagnostics.Parsing));
                break;
            default:
                forEachChild(bind);
        }
    }
    function bindContainer(node) {
        const savedContainer = container;
        const savedParent = parent;
        container = createSymbolMap();
        parent = node;
        symbolLinks.set(node, container);
        if (node.type === "file") {
            bindDefaultImports();
        }
        forEachChild(bind);
        container = savedContainer;
        parent = savedParent;
    }
    function bindValueDeclaration(node) {
        var _a;
        // Bind the function name
        const functionDeclarationLeft = node.childForFieldName("functionDeclarationLeft");
        if (functionDeclarationLeft && functionDeclarationLeft.firstChild) {
            const functionName = functionDeclarationLeft.firstChild.text;
            container.set(functionName, {
                name: functionName,
                node: functionDeclarationLeft,
                type: "Function",
            });
            // Add to nonShadowableNames if it is top level
            if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === "file") {
                nonShadowableNames.add(functionDeclarationLeft.firstChild.text);
            }
        }
        else {
            // If there is a pattern, bind it to the parent container
            const pattern = node.childForFieldName("pattern");
            if (pattern) {
                pattern.descendantsOfType("lower_pattern").forEach((lowerPattern) => {
                    container.set(lowerPattern.text, {
                        name: lowerPattern.text,
                        node: lowerPattern,
                        type: "Function", // This isn't a good type
                    });
                });
            }
        }
        // Bind the rest of the container
        bindContainer(node);
    }
    function bindFunctionDeclarationLeft(node) {
        node.descendantsOfType("lower_pattern").forEach((lowerPattern) => {
            container.set(lowerPattern.text, {
                name: lowerPattern.text,
                node: lowerPattern,
                type: "FunctionParameter",
            });
        });
    }
    function bindTypeDeclaration(node) {
        var _a, _b;
        const unionVariants = (_b = (_a = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("union_variant", node)) === null || _a === void 0 ? void 0 : _a.map((unionVariant) => {
            const name = unionVariant.childForFieldName("name");
            if (name) {
                return {
                    name: name.text,
                    node: unionVariant,
                    type: "UnionConstructor",
                };
            }
        }).filter(utils_1.Utils.notUndefined)) !== null && _b !== void 0 ? _b : [];
        // Union variants get bound to the parent container
        unionVariants.forEach((variant) => {
            container.set(variant.name, Object.assign(Object.assign({}, variant), { type: variant.type }));
        });
        const name = node.childForFieldName("name");
        if (name) {
            container.set(name.text, {
                name: name.text,
                node,
                type: "Type",
                constructors: unionVariants,
            });
        }
        // Bind type variables
        bindContainer(node);
    }
    function bindTypeAliasDeclaration(node) {
        var _a, _b;
        const name = node.childForFieldName("name");
        if (name) {
            const isRecordConstructor = ((_b = (_a = node.childForFieldName("typeExpression")) === null || _a === void 0 ? void 0 : _a.children[0]) === null || _b === void 0 ? void 0 : _b.type) ===
                "record_type";
            container.set(name.text, {
                name: name.text,
                node,
                type: "TypeAlias",
                constructors: isRecordConstructor
                    ? [{ name: name.text, node, type: "TypeAlias" }]
                    : [],
            });
        }
        // Bind type variables
        bindContainer(node);
    }
    function bindLowerTypeName(node) {
        container.set(node.text, { name: node.text, node, type: "TypeVariable" });
    }
    function bindPortAnnotation(node) {
        // TODO: Use field
        const name = treeUtils_1.TreeUtils.findFirstNamedChildOfType("lower_case_identifier", node);
        if (name) {
            container.set(name.text, { name: name.text, node, type: "Port" });
        }
    }
    function bindInfixDeclaration(node) {
        const operator = node.childForFieldName("operator");
        const name = node.lastNamedChild;
        if (operator && name) {
            container.set(operator.text, {
                name: operator.text,
                node,
                type: "Operator",
            });
            container.set(name.text, { name: name.text, node, type: "Operator" });
        }
    }
    function bindPattern(node) {
        node.descendantsOfType("lower_pattern").forEach((lowerPattern) => {
            switch (parent.type) {
                case "anonymous_function_expr":
                    container.set(lowerPattern.text, {
                        name: lowerPattern.text,
                        node: lowerPattern,
                        type: "AnonymousFunctionParameter",
                    });
                    break;
                case "case_of_branch":
                    container.set(lowerPattern.text, {
                        name: lowerPattern.text,
                        node: lowerPattern,
                        type: "CasePattern",
                    });
                    break;
            }
        });
    }
    function bindDefaultImports() {
        imports_1.Imports.getVirtualImports().forEach(bindImportClause);
    }
    function bindImportClause(node) {
        const asClause = node.childForFieldName("asClause");
        let name;
        if (asClause) {
            name = asClause.childForFieldName("name");
        }
        else {
            name = node.childForFieldName("moduleName");
        }
        if (name) {
            container.set(name.text, { name: name.text, node, type: "Import" });
        }
    }
    function bindExposing() {
        const tree = sourceFile.tree;
        const exposed = new Map();
        const moduleDeclaration = treeUtils_1.TreeUtils.findModuleDeclaration(tree);
        if (moduleDeclaration) {
            const exposingList = moduleDeclaration.childForFieldName("exposing");
            if (exposingList) {
                const rootSymbols = symbolLinks.get(tree.rootNode);
                if (exposingList.childForFieldName("doubleDot")) {
                    rootSymbols === null || rootSymbols === void 0 ? void 0 : rootSymbols.forEach((symbol) => {
                        switch (symbol.type) {
                            case "Function":
                            case "TypeAlias":
                            case "Type":
                            case "Port":
                                exposed.set(symbol.name, symbol);
                                break;
                        }
                    });
                }
                else {
                    const exposedOperators = treeUtils_1.TreeUtils.descendantsOfType(exposingList, "operator_identifier");
                    for (const value of exposedOperators) {
                        const functionNode = treeUtils_1.TreeUtils.findOperator(sourceFile, value.text);
                        if (functionNode) {
                            exposed.set(value.text, {
                                name: value.text,
                                node: functionNode,
                                type: "Operator",
                            });
                        }
                        else {
                            sourceFile.bindDiagnostics.push((0, diagnostics_1.error)(value, diagnostics_1.Diagnostics.ExportNotFound, "operator", value.text));
                        }
                    }
                    treeUtils_1.TreeUtils.descendantsOfType(exposingList, "exposed_value")
                        .map((a) => a)
                        .forEach((exposedValue) => {
                        const symbol = rootSymbols === null || rootSymbols === void 0 ? void 0 : rootSymbols.get(exposedValue.text);
                        if (symbol) {
                            exposed.set(exposedValue.text, symbol);
                        }
                        else {
                            sourceFile.bindDiagnostics.push((0, diagnostics_1.error)(exposedValue, diagnostics_1.Diagnostics.ExportNotFound, "value", exposedValue.text));
                        }
                    });
                    const exposedTypes = treeUtils_1.TreeUtils.descendantsOfType(exposingList, "exposed_type");
                    exposedTypes.forEach((exposedType) => {
                        const doubleDot = treeUtils_1.TreeUtils.descendantsOfType(exposedType, "double_dot");
                        if (doubleDot.length > 0) {
                            const name = treeUtils_1.TreeUtils.findFirstNamedChildOfType("upper_case_identifier", exposedType);
                            if (name) {
                                const symbol = rootSymbols === null || rootSymbols === void 0 ? void 0 : rootSymbols.get(name.text, (symbol) => symbol.type === "Type" || symbol.type === "TypeAlias");
                                if (symbol) {
                                    if (symbol.type === "Type") {
                                        exposed.set(name.text, symbol);
                                    }
                                    else if (symbol.type === "TypeAlias") {
                                        sourceFile.bindDiagnostics.push((0, diagnostics_1.error)(exposedType, diagnostics_1.Diagnostics.ExportOpenAlias));
                                    }
                                }
                                else {
                                    sourceFile.bindDiagnostics.push((0, diagnostics_1.error)(exposedType, diagnostics_1.Diagnostics.ExportNotFound, "type", exposedType.text));
                                }
                            }
                        }
                        else {
                            const symbol = rootSymbols === null || rootSymbols === void 0 ? void 0 : rootSymbols.get(exposedType.text, (symbol) => symbol.type === "Type" || symbol.type === "TypeAlias");
                            if (symbol) {
                                exposed.set(exposedType.text, symbol.type === "Type"
                                    ? Object.assign(Object.assign({}, symbol), { constructors: [] }) : symbol);
                            }
                            else {
                                sourceFile.bindDiagnostics.push((0, diagnostics_1.error)(exposedType, diagnostics_1.Diagnostics.ExportNotFound, "type", exposedType.text));
                            }
                        }
                    });
                }
            }
        }
        sourceFile.exposing = exposed;
    }
}
exports.bindTreeContainer = bindTreeContainer;
//# sourceMappingURL=binder.js.map