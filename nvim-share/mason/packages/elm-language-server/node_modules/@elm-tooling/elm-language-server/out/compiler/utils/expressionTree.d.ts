import { SyntaxNode } from "web-tree-sitter";
import { OperatorAssociativity } from "../operatorPrecedence";
import { IProgram } from "../program";
import { Diagnostic } from "../diagnostics";
export declare let definitionTime: number;
export declare let mappingTime: number;
export declare function resetDefinitionAndMappingTime(): void;
export type Expression = EAnonymousFunctionExpr | EAnythingPattern | EBinOpExpr | ECaseOfBranch | ECaseOfExpr | ECharConstantExpr | EConsPattern | EField | EFieldAccessExpr | EFieldAccessorFunctionExpr | EFieldType | EFunctionCallExpr | EFunctionDeclarationLeft | EGlslCodeExpr | EIfElseExpr | EInfixDeclaration | ELetInExpr | EListExpr | EListPattern | ELowerPattern | ELowerTypeName | ENegateExpr | ENumberConstant | ENullaryConstructorArgumentPattern | EOperator | EOperatorAsFunctionExpr | EPattern | EPortAnnotation | ERecordExpr | ERecordType | ERecordPattern | EStringConstant | ETupleExpr | ETuplePattern | ETupleType | ETypeAliasDeclaration | ETypeAnnotation | ETypeDeclaration | ETypeExpression | ETypeRef | ETypeVariable | EUnionPattern | EUnionVariant | EUnitExpr | EValueDeclaration | EValueExpr;
export interface EValueDeclaration extends SyntaxNode {
    nodeType: "ValueDeclaration";
    params: string[];
    body?: SyntaxNode;
    typeAnnotation?: SyntaxNode;
    pattern?: SyntaxNode;
}
export interface EFunctionCallExpr extends SyntaxNode {
    nodeType: "FunctionCallExpr";
    target: Expression;
    args: Expression[];
}
export interface EIfElseExpr extends SyntaxNode {
    nodeType: "IfElseExpr";
    exprList: Expression[];
}
export interface ELetInExpr extends SyntaxNode {
    nodeType: "LetInExpr";
    valueDeclarations: EValueDeclaration[];
    body: Expression;
}
export interface ECaseOfExpr extends SyntaxNode {
    nodeType: "CaseOfExpr";
    expr: Expression;
    branches: ECaseOfBranch[];
}
export interface ECaseOfBranch extends SyntaxNode {
    nodeType: "CaseOfBranch";
    pattern: EPattern;
    expr: Expression;
}
export interface EAnonymousFunctionExpr extends SyntaxNode {
    nodeType: "AnonymousFunctionExpr";
    params: EPattern[];
    expr: Expression;
}
export interface EUnionVariant extends SyntaxNode {
    nodeType: "UnionVariant";
    name: string;
    params: Expression[];
}
export interface EUnionPattern extends SyntaxNode {
    nodeType: "UnionPattern";
    constructor: SyntaxNode;
    namedParams: Expression[];
    argPatterns: Expression[];
}
export interface EValueExpr extends SyntaxNode {
    nodeType: "ValueExpr";
    name: string;
}
export interface EBinOpExpr extends SyntaxNode {
    nodeType: "BinOpExpr";
    parts: Expression[];
}
export interface EOperator extends SyntaxNode {
    nodeType: "Operator";
}
export interface EOperatorAsFunctionExpr extends SyntaxNode {
    nodeType: "OperatorAsFunctionExpr";
    operator: EOperator;
}
export interface ENumberConstant extends SyntaxNode {
    nodeType: "NumberConstant";
    isFloat: boolean;
}
export interface EStringConstant extends SyntaxNode {
    nodeType: "StringConstant";
}
export interface ETypeExpression extends SyntaxNode {
    nodeType: "TypeExpression";
    segments: Expression[];
}
export interface ETypeRef extends SyntaxNode {
    nodeType: "TypeRef";
}
export interface ETypeDeclaration extends SyntaxNode {
    nodeType: "TypeDeclaration";
    name: string;
    typeNames: Expression[];
}
export interface ETypeVariable extends SyntaxNode {
    nodeType: "TypeVariable";
}
export interface ETypeAnnotation extends SyntaxNode {
    nodeType: "TypeAnnotation";
    name: string;
    typeExpression?: ETypeExpression;
}
export interface EInfixDeclaration extends SyntaxNode {
    nodeType: "InfixDeclaration";
    precedence: number;
    associativity: OperatorAssociativity;
}
export interface EFunctionDeclarationLeft extends SyntaxNode {
    nodeType: "FunctionDeclarationLeft";
    params: Pattern[];
}
type Pattern = EPattern | ELowerPattern;
export interface EPattern extends SyntaxNode {
    nodeType: "Pattern";
    patternAs?: ELowerPattern;
}
export interface ELowerPattern extends SyntaxNode {
    nodeType: "LowerPattern";
}
export interface ELowerTypeName extends SyntaxNode {
    nodeType: "LowerTypeName";
}
export interface EUnitExpr extends SyntaxNode {
    nodeType: "UnitExpr";
}
export interface ETupleExpr extends SyntaxNode {
    nodeType: "TupleExpr";
    exprList: Expression[];
}
export interface EAnythingPattern extends SyntaxNode {
    nodeType: "AnythingPattern";
}
export interface ETuplePattern extends SyntaxNode {
    nodeType: "TuplePattern";
    patterns: EPattern[];
}
export interface ETupleType extends SyntaxNode {
    nodeType: "TupleType";
    typeExpressions: ETypeExpression[];
    unitExpr?: EUnitExpr;
}
export interface EListExpr extends SyntaxNode {
    nodeType: "ListExpr";
    exprList: Expression[];
}
export interface EListPattern extends SyntaxNode {
    nodeType: "ListPattern";
    parts: Expression[];
}
export interface EConsPattern extends SyntaxNode {
    nodeType: "ConsPattern";
    parts: Expression[];
}
export interface EFieldType extends SyntaxNode {
    nodeType: "FieldType";
    name: string;
    typeExpression: ETypeExpression;
}
export interface ERecordType extends SyntaxNode {
    nodeType: "RecordType";
    baseType: Expression;
    fieldTypes: EFieldType[];
}
export interface ETypeAliasDeclaration extends SyntaxNode {
    nodeType: "TypeAliasDeclaration";
    name: SyntaxNode;
    typeVariables: Expression[];
    typeExpression: ETypeExpression;
}
export interface EField extends SyntaxNode {
    nodeType: "Field";
    name: Expression;
    expression: Expression;
}
export interface EFieldAccessExpr extends SyntaxNode {
    nodeType: "FieldAccessExpr";
    target: Expression;
}
export interface EFieldAccessorFunctionExpr extends SyntaxNode {
    nodeType: "FieldAccessorFunctionExpr";
}
export interface ERecordPattern extends SyntaxNode {
    nodeType: "RecordPattern";
    patternList: ELowerPattern[];
}
export interface ERecordExpr extends SyntaxNode {
    nodeType: "RecordExpr";
    baseRecord: SyntaxNode;
    fields: EField[];
}
export interface EPortAnnotation extends SyntaxNode {
    nodeType: "PortAnnotation";
    name: string;
    typeExpression: ETypeExpression;
}
export interface ECharConstantExpr extends SyntaxNode {
    nodeType: "CharConstantExpr";
}
export interface EGlslCodeExpr extends SyntaxNode {
    nodeType: "GlslCodeExpr";
    content: SyntaxNode;
}
export interface ENegateExpr extends SyntaxNode {
    nodeType: "NegateExpr";
    expression: Expression;
}
export interface ENullaryConstructorArgumentPattern extends SyntaxNode {
    nodeType: "NullaryConstructorArgumentPattern";
}
export declare function mapSyntaxNodeToExpression(node: SyntaxNode | null | undefined): Expression | undefined;
export declare function mapTypeAliasDeclaration(typeAliasDeclaration: ETypeAliasDeclaration): void;
export declare function mapTypeDeclaration(typeDeclaration: ETypeDeclaration): void;
export declare function mapTypeAnnotation(typeAnnotation: ETypeAnnotation): void;
export declare function findDefinition(e: SyntaxNode | undefined | null, program: IProgram): {
    expr?: Expression;
    diagnostics: Diagnostic[];
};
export {};
