"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TreeUtils = void 0;
const positionUtil_1 = require("../positionUtil");
const expressionTree_1 = require("../../compiler/utils/expressionTree");
const functionNameRegex = new RegExp("[a-zA-Z0-9_]+");
class TreeUtils {
    static getModuleNameNode(tree) {
        var _a;
        const moduleDeclaration = this.findModuleDeclaration(tree);
        return (_a = moduleDeclaration === null || moduleDeclaration === void 0 ? void 0 : moduleDeclaration.childForFieldName("name")) !== null && _a !== void 0 ? _a : undefined;
    }
    static getModuleNameCommentNode(tree) {
        var _a;
        const moduleDeclaration = this.findModuleDeclaration(tree);
        return ((_a = moduleDeclaration === null || moduleDeclaration === void 0 ? void 0 : moduleDeclaration.nextNamedSibling) === null || _a === void 0 ? void 0 : _a.type) === "block_comment"
            ? moduleDeclaration.nextNamedSibling
            : undefined;
    }
    static getModuleExposingListNodes(tree) {
        const moduleNode = TreeUtils.findModuleDeclaration(tree);
        if (moduleNode) {
            return [
                ...moduleNode.descendantsOfType(["exposed_value", "exposed_type"]),
            ];
        }
        return [];
    }
    static findFirstNamedChildOfType(type, node) {
        return node.children.find((child) => child.type === type);
    }
    static findAllNamedChildrenOfType(type, node) {
        const result = Array.isArray(type)
            ? node.children.filter((child) => type.includes(child.type))
            : node.children.filter((child) => child.type === type);
        return result.length === 0 ? undefined : result;
    }
    static findExposedFunctionNode(node, functionName) {
        if (node) {
            const exposingList = this.findFirstNamedChildOfType("exposing_list", node);
            if (exposingList) {
                const doubleDot = this.findFirstNamedChildOfType("double_dot", exposingList);
                if (doubleDot) {
                    return undefined;
                }
            }
            const descendants = TreeUtils.descendantsOfType(node, "exposed_value");
            return descendants.find((desc) => desc.text === functionName);
        }
    }
    static isExposedFunctionOrPort(tree, functionName) {
        const module = this.findModuleDeclaration(tree);
        if (module) {
            const exposingList = this.findFirstNamedChildOfType("exposing_list", module);
            if (exposingList) {
                const doubleDot = exposingList.childForFieldName("doubleDot");
                if (doubleDot) {
                    return true;
                }
            }
            const descendants = TreeUtils.descendantsOfType(module, "exposed_value");
            return descendants.some((desc) => desc.text === functionName);
        }
        return false;
    }
    static findExposedTypeOrTypeAliasNode(node, typeName) {
        if (node) {
            const exposingList = this.findFirstNamedChildOfType("exposing_list", node);
            if (exposingList) {
                const doubleDot = this.findFirstNamedChildOfType("double_dot", exposingList);
                if (doubleDot) {
                    return undefined;
                }
            }
            const descendants = TreeUtils.descendantsOfType(node, "exposed_type");
            const match = descendants.find((desc) => desc.text === typeName || `${desc.text}(`.startsWith(typeName));
            if (match && match.firstNamedChild) {
                return match.firstNamedChild;
            }
        }
        return undefined;
    }
    static isExposedTypeOrTypeAlias(tree, typeName) {
        const module = this.findModuleDeclaration(tree);
        if (module) {
            const exposingList = this.findFirstNamedChildOfType("exposing_list", module);
            if (exposingList) {
                const doubleDot = this.findFirstNamedChildOfType("double_dot", exposingList);
                if (doubleDot) {
                    return true;
                }
            }
            const typeNameDoubleDot = `${typeName}(..)`;
            const descendants = TreeUtils.descendantsOfType(module, "exposed_type");
            return descendants.some((desc) => desc.text === typeName || desc.text === typeNameDoubleDot);
        }
        return false;
    }
    static findUnionConstructorCalls(tree, unionConstructorName, moduleNamePrefix) {
        const upperCaseQid = TreeUtils.descendantsOfType(tree.rootNode, "upper_case_qid");
        if (upperCaseQid.length > 0) {
            const result = upperCaseQid.filter((a) => (a.text === unionConstructorName ||
                (moduleNamePrefix &&
                    a.text === `${moduleNamePrefix}.${unionConstructorName}`)) &&
                a.parent &&
                a.parent.type !== "type_ref" &&
                a.parent.type !== "import_clause");
            return result.length === 0 ? undefined : result;
        }
    }
    static findOperator(sourceFile, operatorName) {
        var _a, _b, _c;
        const rootSymbols = (_a = sourceFile.symbolLinks) === null || _a === void 0 ? void 0 : _a.get(sourceFile.tree.rootNode);
        const operatorNode = (_b = rootSymbols === null || rootSymbols === void 0 ? void 0 : rootSymbols.get(operatorName)) === null || _b === void 0 ? void 0 : _b.node;
        if (operatorNode) {
            const functionReference = TreeUtils.findFirstNamedChildOfType("value_expr", operatorNode);
            if (functionReference) {
                return (_c = rootSymbols === null || rootSymbols === void 0 ? void 0 : rootSymbols.get(functionReference.text, (s) => s.node.type !== "infix_declaration")) === null || _c === void 0 ? void 0 : _c.node;
            }
        }
    }
    static findTypeDeclaration(tree, typeName) {
        const types = this.findAllTypeDeclarations(tree);
        if (types) {
            return types.find((a) => a.children.length > 1 &&
                a.children[1].type === "upper_case_identifier" &&
                a.children[1].text === typeName);
        }
    }
    static findModuleDeclaration(tree) {
        var _a;
        return (_a = tree.rootNode.childForFieldName("moduleDeclaration")) !== null && _a !== void 0 ? _a : undefined;
    }
    static findAllTopLevelFunctionDeclarations(tree) {
        const result = tree.rootNode.children.filter((a) => a.type === "value_declaration");
        return result.length === 0 ? undefined : result;
    }
    static getFunctionNameNodeFromDefinition(node) {
        if (node.type === "lower_case_identifier") {
            return node;
        }
        const declaration = node.type == "function_declaration_left"
            ? node
            : node.childForFieldName("functionDeclarationLeft");
        if (declaration && declaration.firstNamedChild) {
            return declaration.firstNamedChild;
        }
    }
    static getTypeOrTypeAliasOrPortNameNodeFromDefinition(node) {
        var _a;
        return (_a = node.childForFieldName("name")) !== null && _a !== void 0 ? _a : undefined;
    }
    static isTypeUsage(upperCaseQid) {
        var _a;
        return (!!TreeUtils.findParentOfType("type_ref", upperCaseQid) ||
            ((_a = upperCaseQid.parent) === null || _a === void 0 ? void 0 : _a.type) === "exposed_type");
    }
    static isConstructorUsage(upperCaseQid) {
        var _a;
        return ((_a = upperCaseQid.parent) === null || _a === void 0 ? void 0 : _a.type) === "value_expr";
    }
    static findTypeOrTypeAliasCalls(tree, typeOrTypeAliasName, nodeType) {
        const upperCaseQids = TreeUtils.descendantsOfType(tree.rootNode, "upper_case_qid");
        const supportsTypeUsage = nodeType === "Type" || nodeType === "TypeAlias";
        const supportsConstructorUsage = nodeType === "TypeAlias";
        return upperCaseQids.filter((a) => {
            return (a.text === typeOrTypeAliasName &&
                ((supportsTypeUsage && TreeUtils.isTypeUsage(a)) ||
                    (supportsConstructorUsage && TreeUtils.isConstructorUsage(a))));
        });
    }
    static findAllTypeDeclarations(tree) {
        return this.findAllNamedChildrenOfType("type_declaration", tree.rootNode);
    }
    /**
     * @deprecated Should not be used due to performance. Use bindings instead
     */
    static findImportClauseByName(tree, moduleName) {
        const allImports = this.findAllImportClauseNodes(tree);
        if (allImports) {
            return allImports.find((a) => a.children.length > 1 &&
                a.children[1].type === "upper_case_qid" &&
                a.children[1].text === moduleName);
        }
    }
    static getTypeOrTypeAliasOfFunctionParameter(node) {
        if (node &&
            node.parent &&
            node.parent.parent &&
            node.parent.parent.parent &&
            node.parent.parent.parent.previousNamedSibling &&
            node.parent.parent.parent.previousNamedSibling.type ===
                "type_annotation" &&
            node.parent.parent.parent.previousNamedSibling.lastNamedChild) {
            const functionParameterNodes = TreeUtils.findAllNamedChildrenOfType(["pattern", "lower_pattern", "record_pattern"], node.parent.parent);
            if (functionParameterNodes) {
                const matchIndex = functionParameterNodes.findIndex((a) => a.text === node.text);
                const typeAnnotationNodes = TreeUtils.findAllNamedChildrenOfType(["type_ref", "type_expression"], node.parent.parent.parent.previousNamedSibling.lastNamedChild);
                if (typeAnnotationNodes) {
                    return typeAnnotationNodes[matchIndex];
                }
            }
        }
    }
    static getReturnTypeOrTypeAliasOfFunctionDefinition(node) {
        var _a, _b, _c;
        if (node && ((_a = node.previousNamedSibling) === null || _a === void 0 ? void 0 : _a.type) === "type_annotation") {
            const typeAnnotationNodes = TreeUtils.descendantsOfType(node.previousNamedSibling, "type_ref");
            if (typeAnnotationNodes) {
                const type = typeAnnotationNodes[typeAnnotationNodes.length - 1];
                return (_c = (_b = type.firstNamedChild) === null || _b === void 0 ? void 0 : _b.firstNamedChild) !== null && _c !== void 0 ? _c : type;
            }
        }
    }
    static getRecordTypeOfFunctionRecordParameter(node, program) {
        var _a;
        const checker = program.getTypeChecker();
        if (((_a = node === null || node === void 0 ? void 0 : node.parent) === null || _a === void 0 ? void 0 : _a.type) === "function_call_expr" &&
            node.parent.firstNamedChild) {
            const functionCallExpr = (0, expressionTree_1.mapSyntaxNodeToExpression)(node.parent);
            const parameterIndex = functionCallExpr.namedChildren.map((c) => c.text).indexOf(node.text) -
                1;
            const foundType = checker.findType(functionCallExpr.target);
            if (foundType.nodeType === "Function") {
                const paramType = foundType.params[parameterIndex];
                if (paramType.nodeType === "Record") {
                    return paramType;
                }
            }
        }
    }
    static getTypeAliasOfRecordField(node, sourceFile, program) {
        var _a, _b, _c;
        const fieldName = (_b = (_a = node === null || node === void 0 ? void 0 : node.parent) === null || _a === void 0 ? void 0 : _a.firstNamedChild) === null || _b === void 0 ? void 0 : _b.text;
        let recordType = TreeUtils.getTypeAliasOfRecord(node, sourceFile, program);
        while (!recordType && ((_c = node === null || node === void 0 ? void 0 : node.parent) === null || _c === void 0 ? void 0 : _c.parent)) {
            node = node.parent.parent;
            recordType = TreeUtils.getTypeAliasOfRecordField(node, sourceFile, program);
        }
        const recordTypeSourceFile = recordType
            ? program.getSourceFile(recordType.tree.uri)
            : undefined;
        if (recordType && recordTypeSourceFile) {
            const fieldTypes = TreeUtils.descendantsOfType(recordType, "field_type");
            const fieldNode = fieldTypes.find((a) => {
                var _a;
                return (((_a = TreeUtils.findFirstNamedChildOfType("lower_case_identifier", a)) === null || _a === void 0 ? void 0 : _a.text) === fieldName);
            });
            if (fieldNode) {
                const typeExpression = TreeUtils.findFirstNamedChildOfType("type_expression", fieldNode);
                if (typeExpression) {
                    const typeNode = TreeUtils.descendantsOfType(typeExpression, "upper_case_identifier");
                    if (typeNode.length > 0) {
                        const typeAliasNode = program
                            .getTypeChecker()
                            .findDefinition(typeNode[0], recordTypeSourceFile).symbol;
                        if (typeAliasNode) {
                            return typeAliasNode.node;
                        }
                    }
                }
            }
        }
    }
    static getTypeAliasOfRecord(node, sourceFile, program) {
        var _a, _b, _c, _d;
        if ((_a = node === null || node === void 0 ? void 0 : node.parent) === null || _a === void 0 ? void 0 : _a.parent) {
            let type = (_b = TreeUtils.findFirstNamedChildOfType("record_base_identifier", node.parent.parent)) !== null && _b !== void 0 ? _b : TreeUtils.findFirstNamedChildOfType("record_base_identifier", node.parent);
            // Handle records of function returns
            if (!type && node.parent.parent.parent) {
                type =
                    (_d = (_c = TreeUtils.getReturnTypeOrTypeAliasOfFunctionDefinition(node.parent.parent.parent)) === null || _c === void 0 ? void 0 : _c.parent) !== null && _d !== void 0 ? _d : undefined;
            }
            if (!type) {
                type = node;
            }
            if (type) {
                const definitionNode = program
                    .getTypeChecker()
                    .findDefinition(type.firstNamedChild ? type.firstNamedChild : type, sourceFile).symbol;
                if (definitionNode) {
                    const definitionTree = program.getSourceFile(definitionNode.node.tree.uri);
                    let aliasNode;
                    if (definitionNode.type === "FunctionParameter" &&
                        definitionNode.node.firstNamedChild) {
                        aliasNode = TreeUtils.getTypeOrTypeAliasOfFunctionParameter(definitionNode.node.firstNamedChild);
                    }
                    else if (definitionNode.type === "Function") {
                        aliasNode = TreeUtils.getReturnTypeOrTypeAliasOfFunctionDefinition(definitionNode.node);
                    }
                    else if (definitionNode.type === "FieldType") {
                        aliasNode = TreeUtils.findFirstNamedChildOfType("type_expression", definitionNode.node);
                    }
                    else if (definitionNode.type === "TypeAlias") {
                        return definitionNode.node;
                    }
                    if (aliasNode && definitionTree) {
                        const childNode = TreeUtils.descendantsOfType(aliasNode, "upper_case_identifier");
                        if (childNode.length > 0) {
                            const typeNode = program
                                .getTypeChecker()
                                .findDefinition(childNode[0], definitionTree).symbol;
                            if (typeNode) {
                                return typeNode.node;
                            }
                        }
                    }
                }
            }
        }
    }
    static getAllFieldsFromTypeAlias(node) {
        const result = [];
        if (node) {
            const fieldTypes = TreeUtils.descendantsOfType(node, "field_type");
            if (fieldTypes.length > 0) {
                fieldTypes.forEach((a) => {
                    const fieldName = TreeUtils.findFirstNamedChildOfType("lower_case_identifier", a);
                    const typeExpression = TreeUtils.findFirstNamedChildOfType("type_expression", a);
                    if (fieldName && typeExpression) {
                        result.push({ field: fieldName.text, type: typeExpression.text });
                    }
                });
            }
        }
        return result.length === 0 ? undefined : result;
    }
    static descendantsOfType(node, type) {
        return node.descendantsOfType(type);
    }
    static getNamedDescendantForPosition(node, position) {
        const previousCharColumn = position.character === 0 ? 0 : position.character - 1;
        const charBeforeCursor = node.text
            .split("\n")[position.line].substring(previousCharColumn, position.character);
        if (!functionNameRegex.test(charBeforeCursor)) {
            return node.namedDescendantForPosition({
                column: position.character,
                row: position.line,
            });
        }
        else {
            return node.namedDescendantForPosition({
                column: previousCharColumn,
                row: position.line,
            }, {
                column: position.character,
                row: position.line,
            });
        }
    }
    static getDescendantForPosition(node, position) {
        const previousCharColumn = position.character === 0 ? 0 : position.character - 1;
        const charBeforeCursor = node.text
            .split("\n")[position.line].substring(previousCharColumn, position.character);
        if (!functionNameRegex.test(charBeforeCursor)) {
            return node.descendantForPosition({
                column: position.character,
                row: position.line,
            });
        }
        else {
            return node.descendantForPosition({
                column: previousCharColumn,
                row: position.line,
            }, {
                column: position.character,
                row: position.line,
            });
        }
    }
    static getNamedDescendantForRange(sourceFile, range) {
        if ((0, positionUtil_1.positionEquals)(range.start, range.end)) {
            return this.getNamedDescendantForPosition(sourceFile.tree.rootNode, {
                character: range.start.character,
                line: range.start.line,
            });
        }
        else {
            return sourceFile.tree.rootNode.namedDescendantForPosition({
                column: range.start.character,
                row: range.start.line,
            }, {
                column: range.end.character,
                row: range.end.line,
            });
        }
    }
    static getDescendantForRange(sourceFile, range) {
        if ((0, positionUtil_1.positionEquals)(range.start, range.end)) {
            return this.getDescendantForPosition(sourceFile.tree.rootNode, {
                character: range.start.character,
                line: range.start.line,
            });
        }
        else {
            return sourceFile.tree.rootNode.descendantForPosition({
                column: range.start.character,
                row: range.start.line,
            }, {
                column: range.end.character,
                row: range.end.line,
            });
        }
    }
    static findPreviousNode(node, position) {
        function nodeHasTokens(n) {
            return n.endIndex - n.startIndex !== 0;
        }
        function findRightmostChildWithTokens(childrenList, startIndex) {
            for (let i = startIndex - 1; i >= 0; i--) {
                if (nodeHasTokens(childrenList[i])) {
                    return childrenList[i];
                }
            }
        }
        function findRightmostNode(n) {
            if (n.children.length === 0) {
                return n;
            }
            const candidate = findRightmostChildWithTokens(n.children, n.children.length);
            if (candidate) {
                return findRightmostNode(candidate);
            }
        }
        const children = node.children;
        if (children.length === 0) {
            return node;
        }
        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if ((0, positionUtil_1.comparePosition)(position, child.endPosition) < 0) {
                const lookInPreviousChild = (0, positionUtil_1.comparePosition)(position, child.startPosition) <= 0 ||
                    !nodeHasTokens(child);
                if (lookInPreviousChild) {
                    const candidate = findRightmostChildWithTokens(children, i);
                    if (candidate) {
                        return findRightmostNode(candidate);
                    }
                }
                else {
                    return this.findPreviousNode(child, position);
                }
            }
        }
        const candidate = findRightmostChildWithTokens(children, children.length);
        if (candidate) {
            return findRightmostNode(candidate);
        }
    }
    static getNamedDescendantForLineBeforePosition(node, position) {
        const previousLine = position.line === 0 ? 0 : position.line - 1;
        return node.namedDescendantForPosition({
            column: 0,
            row: previousLine,
        });
    }
    static getNamedDescendantForLineAfterPosition(node, position) {
        const followingLine = position.line + 1;
        return node.namedDescendantForPosition({
            column: 0,
            row: followingLine,
        });
    }
    static findParentOfType(typeToLookFor, node, topLevel = false) {
        var _a;
        if (node.type === typeToLookFor &&
            (!topLevel || ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === "file")) {
            return node;
        }
        if (node.parent) {
            return this.findParentOfType(typeToLookFor, node.parent, topLevel);
        }
    }
    static getLastImportNode(tree) {
        const allImportNodes = this.findAllImportClauseNodes(tree);
        if (allImportNodes === null || allImportNodes === void 0 ? void 0 : allImportNodes.length) {
            return allImportNodes[allImportNodes.length - 1];
        }
    }
    static isReferenceFullyQualified(node) {
        var _a, _b, _c;
        return (((_a = node.previousNamedSibling) === null || _a === void 0 ? void 0 : _a.type) === "dot" &&
            ((_c = (_b = node.previousNamedSibling) === null || _b === void 0 ? void 0 : _b.previousNamedSibling) === null || _c === void 0 ? void 0 : _c.type) ===
                "upper_case_identifier");
    }
    static getTypeAnnotation(valueDeclaration) {
        if ((valueDeclaration === null || valueDeclaration === void 0 ? void 0 : valueDeclaration.type) !== "value_declaration") {
            return;
        }
        let candidate = valueDeclaration.previousNamedSibling;
        // Skip comments
        while ((candidate === null || candidate === void 0 ? void 0 : candidate.type) === "line_comment" ||
            (candidate === null || candidate === void 0 ? void 0 : candidate.type) === "comment_block") {
            candidate = candidate.previousNamedSibling;
        }
        if ((candidate === null || candidate === void 0 ? void 0 : candidate.type) === "type_annotation") {
            return candidate;
        }
    }
    static getValueDeclaration(typeAnnotation) {
        if ((typeAnnotation === null || typeAnnotation === void 0 ? void 0 : typeAnnotation.type) !== "type_annotation") {
            return;
        }
        let candidate = typeAnnotation.nextNamedSibling;
        // Skip comments
        while ((candidate === null || candidate === void 0 ? void 0 : candidate.type) === "line_comment" ||
            (candidate === null || candidate === void 0 ? void 0 : candidate.type) === "comment_block") {
            candidate = candidate.nextNamedSibling;
        }
        if ((candidate === null || candidate === void 0 ? void 0 : candidate.type) === "value_declaration") {
            return candidate;
        }
    }
    /**
     * This gets a list of all ancestors of a type
     * in order from the closest declaration up to the top level declaration
     */
    static getAllAncestorsOfType(type, node) {
        const declarations = [];
        while (node.type !== "file") {
            if (node.type === type) {
                declarations.push(node);
            }
            if (node.parent) {
                node = node.parent;
            }
            else {
                break;
            }
        }
        return declarations;
    }
    /**
     * @deprecated Should not be used due to performance. Use bindings instead
     */
    static findAllImportClauseNodes(tree) {
        const result = tree.rootNode.children.filter((a) => a.type === "import_clause");
        return result.length === 0 ? undefined : result;
    }
    static isIdentifier(node) {
        return (node.type === "lower_case_identifier" ||
            node.type === "upper_case_identifier");
    }
    static isImport(node) {
        var _a, _b, _c, _d, _e;
        return (((_b = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.firstNamedChild) === null || _b === void 0 ? void 0 : _b.type) === "import" ||
            ((_e = (_d = (_c = node.parent) === null || _c === void 0 ? void 0 : _c.parent) === null || _d === void 0 ? void 0 : _d.firstNamedChild) === null || _e === void 0 ? void 0 : _e.type) === "import");
    }
    static nextNode(node) {
        // Move up until we have a sibling
        while (!node.nextNamedSibling && node.parent) {
            node = node.parent;
        }
        if (node.nextNamedSibling) {
            node = node.nextNamedSibling;
            // Move down the leftmost subtree
            while (node.firstNamedChild) {
                node = node.firstNamedChild;
            }
            return node;
        }
    }
    static findFieldReference(type, fieldName) {
        if (type.nodeType === "Record") {
            const fieldRefs = type.fieldReferences.get(fieldName);
            if (fieldRefs.length > 0) {
                return { name: fieldName, node: fieldRefs[0], type: "FieldType" };
            }
        }
    }
    static findImportAliasOfModule(moduleName, tree) {
        var _a, _b;
        const importClause = TreeUtils.findImportClauseByName(tree, moduleName);
        const asClause = importClause === null || importClause === void 0 ? void 0 : importClause.childForFieldName("asClause");
        if (asClause) {
            return (_a = asClause.childForFieldName("name")) === null || _a === void 0 ? void 0 : _a.text;
        }
        else {
            return (_b = importClause === null || importClause === void 0 ? void 0 : importClause.childForFieldName("moduleName")) === null || _b === void 0 ? void 0 : _b.text;
        }
    }
}
exports.TreeUtils = TreeUtils;
//# sourceMappingURL=treeUtils.js.map