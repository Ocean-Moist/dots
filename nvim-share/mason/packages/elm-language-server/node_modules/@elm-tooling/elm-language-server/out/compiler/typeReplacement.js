"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeReplacement = exports.resetReplaceTime = exports.replaceTime = void 0;
const perf_hooks_1 = require("perf_hooks");
const typeInference_1 = require("./typeInference");
exports.replaceTime = 0;
function resetReplaceTime() {
    exports.replaceTime = 0;
}
exports.resetReplaceTime = resetReplaceTime;
class TypeReplacement {
    constructor(replacements, freshen, keepRecordsMutable, varsToRemainRigid) {
        this.replacements = replacements;
        this.freshen = freshen;
        this.keepRecordsMutable = keepRecordsMutable;
        this.varsToRemainRigid = varsToRemainRigid;
        this.cachedReplacements = new Map();
    }
    static replace(type, replacements, keepRecordsMutable = false, varsToRemainRigid) {
        const start = perf_hooks_1.performance.now();
        try {
            if (!varsToRemainRigid && replacements.size === 0) {
                return type;
            }
            return new TypeReplacement(replacements, 
            /* freshen */ false, keepRecordsMutable, varsToRemainRigid).replace(type);
        }
        finally {
            exports.replaceTime += perf_hooks_1.performance.now() - start;
        }
    }
    static freshenVars(type) {
        return new TypeReplacement(new Map(), /* freshen */ true, false).replace(type);
    }
    static flexify(type) {
        return new TypeReplacement(new Map(), 
        /* freshen */ false, false, []).replace(type);
    }
    static freeze(type) {
        var _a, _b, _c;
        switch (type.nodeType) {
            case "Tuple":
                type.types.forEach(this.freeze.bind(this));
                break;
            case "Record":
            case "MutableRecord":
                (_b = (_a = type.baseType) === null || _a === void 0 ? void 0 : _a.fieldReferences) === null || _b === void 0 ? void 0 : _b.freeze();
                for (const field in type.fields) {
                    this.freeze(type.fields[field]);
                }
                type.fieldReferences.freeze();
                break;
            case "Union":
                type.params.forEach(this.freeze.bind(this));
                break;
            case "Function":
                this.freeze(type.return);
                type.params.forEach(this.freeze.bind(this));
                break;
        }
        (_c = type.alias) === null || _c === void 0 ? void 0 : _c.parameters.forEach(TypeReplacement.freeze.bind(this));
    }
    wouldChange(type) {
        const changeAllVars = this.freshen || !!this.varsToRemainRigid;
        const wouldChangeWorker = (type) => {
            var _a;
            let result = false;
            switch (type.nodeType) {
                case "Var":
                    result = changeAllVars || this.replacements.has(type);
                    break;
                case "Tuple":
                    result = type.types.some(wouldChangeWorker);
                    break;
                case "Record":
                    result =
                        Object.values(type.fields).some(wouldChangeWorker) ||
                            (type.baseType ? wouldChangeWorker(type.baseType) : false);
                    break;
                case "MutableRecord":
                    result =
                        !this.keepRecordsMutable ||
                            Object.values(type.fields).some(wouldChangeWorker) ||
                            (type.baseType ? wouldChangeWorker(type.baseType) : false);
                    break;
                case "Union":
                    result = type.params.some(wouldChangeWorker);
                    break;
                case "Function":
                    result =
                        wouldChangeWorker(type.return) ||
                            type.params.some(wouldChangeWorker);
                    break;
                case "Unit":
                case "Unknown":
                case "InProgressBinding":
                    result = false;
                    break;
            }
            if (!result) {
                result = !!((_a = type.alias) === null || _a === void 0 ? void 0 : _a.parameters.some(wouldChangeWorker));
            }
            return result;
        };
        return wouldChangeWorker(type);
    }
    replace(type) {
        var _a;
        if (!this.wouldChange(type)) {
            return type;
        }
        switch (type.nodeType) {
            case "Var":
                return (_a = this.getReplacement(type)) !== null && _a !== void 0 ? _a : type;
            case "Function":
                return this.replaceFunction(type);
            case "Union":
                return this.replaceUnion(type);
            case "Tuple":
                return this.replaceTuple(type);
            case "Record":
                return this.replaceRecord(type.fields, type.fieldReferences, false, type.baseType, type.alias);
            case "MutableRecord":
                return this.replaceRecord(type.fields, type.fieldReferences, true, type.baseType);
            case "Unit":
            case "InProgressBinding":
                return type;
            case "Unknown":
                return {
                    nodeType: "Unknown",
                    alias: this.replaceAlias(type.alias),
                };
        }
    }
    replaceAlias(alias) {
        if (alias) {
            return Object.assign(Object.assign({}, alias), { parameters: alias.parameters.map((param) => this.replace(param)) });
        }
    }
    replaceTuple(type) {
        return (0, typeInference_1.TTuple)(type.types.map((t) => this.replace(t)), this.replaceAlias(type.alias));
    }
    replaceFunction(type) {
        const params = type.params.map((param) => this.replace(param));
        return (0, typeInference_1.uncurryFunction)((0, typeInference_1.TFunction)(params, this.replace(type.return), this.replaceAlias(type.alias)));
    }
    replaceUnion(type) {
        if (type.params.length === 0 && !type.alias) {
            return type;
        }
        const params = type.params.map((param) => this.replace(param));
        return (0, typeInference_1.TUnion)(type.module, type.name, params, this.replaceAlias(type.alias));
    }
    replaceRecord(fields, fieldReferences, wasMutable, baseType, alias) {
        var _a;
        const oldBase = !baseType || baseType.nodeType !== "Var"
            ? undefined
            : this.getReplacement(baseType);
        let newBase = oldBase;
        if ((oldBase === null || oldBase === void 0 ? void 0 : oldBase.nodeType) === "Record") {
            newBase = oldBase.baseType;
        }
        else if (!oldBase) {
            if ((baseType === null || baseType === void 0 ? void 0 : baseType.nodeType) === "MutableRecord" && !this.keepRecordsMutable) {
                newBase = this.replace(baseType);
            }
            else {
                newBase = baseType;
            }
        }
        const baseFields = (_a = oldBase === null || oldBase === void 0 ? void 0 : oldBase.fields) !== null && _a !== void 0 ? _a : [];
        const baseFieldRefs = oldBase === null || oldBase === void 0 ? void 0 : oldBase.fieldReferences;
        const newFields = {};
        for (const field in baseFields) {
            newFields[field] = baseFields[field];
        }
        for (const field in fields) {
            newFields[field] = this.replace(fields[field]);
        }
        let newFieldReferences;
        if (!baseFieldRefs || baseFieldRefs.isEmpty()) {
            newFieldReferences = fieldReferences;
        }
        else if (fieldReferences.frozen) {
            newFieldReferences = fieldReferences.plus(baseFieldRefs);
        }
        else {
            fieldReferences.addAll(baseFieldRefs);
            newFieldReferences = fieldReferences;
        }
        if (wasMutable && this.keepRecordsMutable) {
            return (0, typeInference_1.TMutableRecord)(newFields, newBase, newFieldReferences);
        }
        else {
            return (0, typeInference_1.TRecord)(newFields, newBase, this.replaceAlias(alias), newFieldReferences);
        }
    }
    getReplacement(key) {
        const cachedReplacement = this.cachedReplacements.get(key);
        if (cachedReplacement) {
            return cachedReplacement;
        }
        const replacement = this.replacements.get(key);
        if (!replacement) {
            if (this.freshen || this.varsToRemainRigid) {
                if (key.rigid &&
                    (!this.varsToRemainRigid || this.varsToRemainRigid.includes(key))) {
                    return undefined;
                }
                else {
                    const newVar = (0, typeInference_1.TVar)(key.name);
                    newVar.alias = key.alias;
                    this.cachedReplacements.set(key, newVar);
                    return newVar;
                }
            }
            return undefined;
        }
        const replacedType = this.replace(replacement);
        this.cachedReplacements.set(key, replacedType);
        return replacedType;
    }
}
exports.TypeReplacement = TypeReplacement;
//# sourceMappingURL=typeReplacement.js.map