"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = void 0;
class Utils {
    static notUndefined(x) {
        return x !== undefined;
    }
    static notUndefinedOrNull(x) {
        return x !== undefined && x !== null;
    }
    static arrayEquals(a, b, itemEquals = (a, b) => a === b) {
        if (a === b) {
            return true;
        }
        if (a.length !== b.length) {
            return false;
        }
        return a.every((x, i) => itemEquals(x, b[i]));
    }
    static rangeEquals(a, b) {
        return (a.start.character === b.start.character &&
            a.start.line === b.start.line &&
            a.end.character === b.end.character &&
            a.end.line === b.end.line);
    }
    static rangeOverlaps(a, b) {
        if (b.start.line < a.start.line || b.end.line < a.start.line) {
            return false;
        }
        if (b.start.line > a.end.line || b.end.line > a.end.line) {
            return false;
        }
        if (b.start.line === a.start.line &&
            b.start.character < a.start.character) {
            return false;
        }
        if (b.end.line === a.end.line && b.end.character > a.end.character) {
            return false;
        }
        return true;
    }
    static getIndicesFromRange(range, text) {
        let startIndex = range.start.character;
        let endIndex = range.end.character;
        const regex = new RegExp(/\r\n|\r|\n/);
        const eolResult = regex.exec(text);
        const lines = text.split(regex);
        const eol = eolResult && eolResult.length > 0 ? eolResult[0] : "";
        for (let i = 0; i < range.end.line; i++) {
            if (i < range.start.line) {
                startIndex += lines[i].length + eol.length;
            }
            endIndex += lines[i].length + eol.length;
        }
        return [startIndex, endIndex];
    }
    static rotateArray(array, newStartIndex) {
        const newArray = [];
        for (let i = 0; i < array.length; i++) {
            newArray.push(array[newStartIndex]);
            newStartIndex = (newStartIndex + 1) % array.length;
        }
        return newArray;
    }
    static mergeChanges(a, b) {
        Object.entries(b).forEach(([uri, edits]) => {
            if (a[uri]) {
                a[uri].push(...edits);
            }
            else {
                a[uri] = edits;
            }
        });
    }
}
exports.Utils = Utils;
//# sourceMappingURL=utils.js.map