"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ASTProvider = void 0;
const tsyringe_1 = require("tsyringe");
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const elmWorkspaceMatcher_1 = require("../util/elmWorkspaceMatcher");
const textDocumentEvents_1 = require("../util/textDocumentEvents");
const treeUtils_1 = require("../util/treeUtils");
const utils_1 = require("../util/utils");
class ASTProvider {
    constructor() {
        this.treeChangeEvent = new vscode_languageserver_1.Emitter();
        this.onTreeChange = this.treeChangeEvent.event;
        this.treeDeleteEvent = new vscode_languageserver_1.Emitter();
        this.onTreeDelete = this.treeDeleteEvent.event;
        this.pendingRenames = new Map();
        this.handleChangeTextDocument = (params) => {
            var _a, _b, _c, _d, _e, _f, _g;
            this.connection.console.info(`Changed text document, going to parse it. ${params.uri}`);
            const forest = params.program.getForest(false); // Don't synchronize the forest, we are only looking at the tree
            // Source file could be undefined here
            const sourceFile = params.sourceFile;
            const newText = (_b = (_a = this.documentEvents.get(params.uri)) === null || _a === void 0 ? void 0 : _a.getText()) !== null && _b !== void 0 ? _b : "";
            if (sourceFile &&
                (sourceFile.tree.rootNode.text === newText || !sourceFile.writeable)) {
                return;
            }
            let tree = sourceFile === null || sourceFile === void 0 ? void 0 : sourceFile.tree;
            let hasContentChanges = false;
            if ("contentChanges" in params && params.contentChanges) {
                hasContentChanges = true;
                if (tree) {
                    this.applyChangesToTree(tree, params.contentChanges);
                }
            }
            const pendingRenameUri = this.pendingRenames.get(params.uri);
            this.pendingRenames.delete(params.uri);
            // Remove the old tree
            if (pendingRenameUri) {
                forest.removeTree(params.uri);
            }
            const oldNodes = (_c = tree === null || tree === void 0 ? void 0 : tree.rootNode.namedChildren) !== null && _c !== void 0 ? _c : [];
            const newTree = this.parser.parse(newText, hasContentChanges ? tree : undefined);
            let changedDeclaration;
            tree === null || tree === void 0 ? void 0 : tree.getChangedRanges(newTree).map((range) => [
                tree === null || tree === void 0 ? void 0 : tree.rootNode.descendantForPosition(range.startPosition),
                tree === null || tree === void 0 ? void 0 : tree.rootNode.descendantForPosition(range.endPosition),
            ]).map(([startNode, endNode]) => [
                startNode
                    ? treeUtils_1.TreeUtils.findParentOfType("value_declaration", startNode, true)
                    : undefined,
                endNode
                    ? treeUtils_1.TreeUtils.findParentOfType("value_declaration", endNode, true)
                    : undefined,
            ]).forEach(([startNode, endNode]) => {
                if (startNode &&
                    endNode &&
                    startNode.id === endNode.id &&
                    treeUtils_1.TreeUtils.getTypeAnnotation(startNode)) {
                    changedDeclaration = startNode;
                    params.program.getTypeCache().invalidateValueDeclaration(startNode);
                }
            });
            if (!changedDeclaration) {
                params.program.getTypeCache().invalidateProject();
            }
            tree = newTree;
            const newIds = new Set(newTree.rootNode.namedChildren.map((n) => n.id).values());
            oldNodes.forEach((node) => {
                if (node && !newIds.has(node.id)) {
                    params.program.getTypeCache().invalidateValueDeclaration(node);
                    params.program.getTypeCache().invalidateTypeAnnotation(node);
                    params.program.getTypeCache().invalidateTypeOrTypeAlias(node);
                }
            });
            if (tree) {
                // Reuse old source file for most cases
                const isTestFile = params.sourceFile
                    ? params.sourceFile.isTestFile
                    : (_e = (_d = params.program
                        .getSourceDirectoryOfFile(params.uri)) === null || _d === void 0 ? void 0 : _d.endsWith("tests")) !== null && _e !== void 0 ? _e : false;
                const isDependency = params.sourceFile
                    ? params.sourceFile.isDependency
                    : false;
                const sourceFile = forest.setSourceFile(pendingRenameUri !== null && pendingRenameUri !== void 0 ? pendingRenameUri : params.uri, true, tree, isTestFile, isDependency, (_f = params.sourceFile) === null || _f === void 0 ? void 0 : _f.project, (_g = params.sourceFile) === null || _g === void 0 ? void 0 : _g.maintainerAndPackageName);
                // The program now needs to be synchronized
                params.program.markAsDirty();
                setImmediate(() => {
                    if (tree) {
                        this.treeChangeEvent.fire({
                            sourceFile,
                            declaration: changedDeclaration,
                        });
                    }
                });
            }
        };
        this.parser = tsyringe_1.container.resolve("Parser");
        this.connection = tsyringe_1.container.resolve("Connection");
        this.documentEvents = tsyringe_1.container.resolve(textDocumentEvents_1.TextDocumentEvents);
        const handleChange = new elmWorkspaceMatcher_1.ElmWorkspaceMatcher((params) => vscode_uri_1.URI.parse(params.uri)).handle(this.handleChangeTextDocument.bind(this));
        this.documentEvents.onDidChange((params) => {
            void handleChange({
                uri: params.textDocument.uri,
                contentChanges: params.contentChanges,
            });
        });
        this.documentEvents.onDidOpen((params) => {
            void handleChange({
                uri: params.textDocument.uri,
            });
        });
        this.connection.onDidChangeWatchedFiles((params) => {
            params.changes.forEach((change) => {
                if (change.type === vscode_languageserver_1.FileChangeType.Changed ||
                    change.type === vscode_languageserver_1.FileChangeType.Created) {
                    void handleChange(change);
                }
                if (change.type === vscode_languageserver_1.FileChangeType.Deleted) {
                    void new elmWorkspaceMatcher_1.ElmWorkspaceMatcher((params) => vscode_uri_1.URI.parse(params.uri)).handle((params) => {
                        const forest = params.program.getForest(false);
                        forest.removeTree(params.uri);
                        this.treeDeleteEvent.fire({ uri: params.uri });
                    })(change);
                }
            });
        });
    }
    addPendingRename(oldUri, newUri) {
        this.pendingRenames.set(oldUri, newUri);
    }
    applyChangesToTree(tree, changes) {
        let text = tree.rootNode.text;
        if (!text) {
            return;
        }
        const multipleChanges = changes.length > 1;
        for (const change of changes) {
            const changeRecord = this.getChangeWithRange(change, text);
            const edit = this.getEditFromChange(changeRecord, text);
            tree === null || tree === void 0 ? void 0 : tree.edit(edit);
            // If there are multiple changes, we also need to take care to apply each change to the
            // rootNode text. Otherwise, the startIndex and endIndex for later changes will be off.
            if (multipleChanges) {
                text =
                    text.substring(0, edit.startIndex) +
                        change.text +
                        text.substring(edit.oldEndIndex);
            }
        }
    }
    getChangeWithRange(change, text) {
        if ("range" in change) {
            return change;
        }
        else {
            const regex = new RegExp(/\r\n|\r|\n/);
            const lines = text.split(regex);
            const range = {
                start: { line: 0, character: 0 },
                end: { line: lines.length, character: 0 },
            };
            return { text: change.text, range: range };
        }
    }
    getEditFromChange(change, text) {
        const [startIndex, endIndex] = utils_1.Utils.getIndicesFromRange(change.range, text);
        return {
            startIndex,
            oldEndIndex: endIndex,
            newEndIndex: startIndex + change.text.length,
            startPosition: this.toTSPoint(change.range.start),
            oldEndPosition: this.toTSPoint(change.range.end),
            newEndPosition: this.toTSPoint(this.addPositions(change.range.start, this.textToPosition(change.text))),
        };
    }
    textToPosition(text) {
        const lines = text.split(/\r\n|\r|\n/);
        return {
            line: lines.length - 1,
            character: lines[lines.length - 1].length,
        };
    }
    addPositions(pos1, pos2) {
        return {
            line: pos1.line + pos2.line,
            character: pos1.character + pos2.character,
        };
    }
    toTSPoint(position) {
        return { row: position.line, column: position.character };
    }
}
exports.ASTProvider = ASTProvider;
//# sourceMappingURL=astProvider.js.map