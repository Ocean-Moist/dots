"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_1 = require("vscode-languageserver");
const positionUtil_1 = require("../../positionUtil");
const refactorEditUtils_1 = require("../../util/refactorEditUtils");
const treeUtils_1 = require("../../util/treeUtils");
const diagnostics_1 = require("../../../compiler/diagnostics");
const codeActionProvider_1 = require("../codeActionProvider");
const errorCodes = [diagnostics_1.Diagnostics.MissingTypeAnnotation.code];
const fixId = "add_type_annotation";
codeActionProvider_1.CodeActionProvider.registerCodeAction({
    errorCodes,
    fixId,
    preferredAction: {
        priority: 3,
    },
    getCodeActions: (params) => {
        const edits = getEdits(params, params.range);
        if (edits.length > 0) {
            return [
                codeActionProvider_1.CodeActionProvider.getCodeAction(params, "Add inferred annotation", edits),
            ];
        }
        return [];
    },
    getFixAllCodeAction: (params) => {
        return codeActionProvider_1.CodeActionProvider.getFixAllCodeAction("Add all missing type annotations", params, errorCodes, fixId, (edits, diagnostic) => {
            const newEdits = getEdits(params, diagnostic.range);
            if (newEdits.length > 0 &&
                !edits.find((edit) => edit.newText === newEdits[0].newText)) {
                edits.push(...newEdits);
            }
        });
    },
});
// Handle adding annotation to let expr declaration
const refactorName = "add_type_annotation";
codeActionProvider_1.CodeActionProvider.registerRefactorAction(refactorName, {
    getAvailableActions: (params) => {
        var _a;
        const nodeAtPosition = treeUtils_1.TreeUtils.getNamedDescendantForPosition(params.sourceFile.tree.rootNode, params.range.start);
        if (((_a = nodeAtPosition.parent) === null || _a === void 0 ? void 0 : _a.type) === "function_declaration_left" &&
            treeUtils_1.TreeUtils.findParentOfType("let_in_expr", nodeAtPosition) &&
            nodeAtPosition.parent.parent &&
            !treeUtils_1.TreeUtils.getTypeAnnotation(nodeAtPosition.parent.parent)) {
            return [
                {
                    title: "Add inferred annotation",
                    kind: vscode_languageserver_1.CodeActionKind.RefactorExtract,
                    data: {
                        actionName: "add_type_annotation",
                        refactorName,
                        uri: params.sourceFile.uri,
                        range: params.range,
                    },
                },
            ];
        }
        return [];
    },
    getEditsForAction: (params) => {
        return { edits: getEdits(params, params.range) };
    },
});
function getEdits(params, range) {
    const nodeAtPosition = treeUtils_1.TreeUtils.getNamedDescendantForRange(params.sourceFile, range);
    const checker = params.program.getTypeChecker();
    if (nodeAtPosition.parent) {
        const typeString = checker.typeToString(checker.findType(nodeAtPosition.parent), params.sourceFile);
        const startPosition = positionUtil_1.PositionUtil.FROM_TS_POSITION(nodeAtPosition.startPosition).toVSPosition();
        return [
            vscode_languageserver_1.TextEdit.insert(startPosition, `${nodeAtPosition.text} : ${typeString}\n${(0, refactorEditUtils_1.getSpaces)(startPosition.character)}`),
        ];
    }
    else {
        return [];
    }
}
//# sourceMappingURL=addTypeAnnotationCodeAction.js.map