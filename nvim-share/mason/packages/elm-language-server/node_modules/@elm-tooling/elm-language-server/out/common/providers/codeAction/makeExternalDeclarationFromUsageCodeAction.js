"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const refactorEditUtils_1 = require("../../util/refactorEditUtils");
const treeUtils_1 = require("../../util/treeUtils");
const diagnostics_1 = require("../../../compiler/diagnostics");
const codeActionProvider_1 = require("../codeActionProvider");
const utils_1 = require("../../util/utils");
const errorCodes = [diagnostics_1.Diagnostics.MissingValue.code];
const fixId = "make_external_declaration_from_usage";
codeActionProvider_1.CodeActionProvider.registerCodeAction({
    errorCodes,
    fixId,
    getCodeActions: (params) => {
        const allEdits = getEdits(params, params.range);
        return allEdits
            .map(([edits, moduleName]) => {
            if (Object.keys(edits).length > 0) {
                return codeActionProvider_1.CodeActionProvider.getCodeAction(params, `Create function in module '${moduleName}'`, edits);
            }
        })
            .filter(utils_1.Utils.notUndefinedOrNull);
    },
    getFixAllCodeAction: (params) => {
        return codeActionProvider_1.CodeActionProvider.getFixAllCodeAction("Create all missing external functions", params, errorCodes, fixId, () => {
            // Not used
        }, (edits, diagnostic) => {
            const firstEdits = getEdits(params, diagnostic.range)[0];
            if (firstEdits) {
                utils_1.Utils.mergeChanges(edits, firstEdits[0]);
            }
        });
    },
});
function getEdits(params, range) {
    var _a, _b, _c;
    const nodeAtPosition = treeUtils_1.TreeUtils.getNamedDescendantForRange(params.sourceFile, range);
    if (nodeAtPosition.type === "value_qid" &&
        ((_a = nodeAtPosition.parent) === null || _a === void 0 ? void 0 : _a.type) === "value_expr") {
        const funcName = (_c = (_b = nodeAtPosition.lastNamedChild) === null || _b === void 0 ? void 0 : _b.text) !== null && _c !== void 0 ? _c : nodeAtPosition.text;
        const modulePrefix = nodeAtPosition.namedChildren
            .slice(0, -2)
            .map((n) => n.text)
            .join("");
        const checker = params.program.getTypeChecker();
        const moduleNames = checker
            .findImportModuleNameNodes(modulePrefix, params.sourceFile)
            .map((n) => n.text);
        return moduleNames
            .map((moduleName) => {
            const destinationSource = params.program.getSourceFileOfImportableModule(params.sourceFile, moduleName);
            if (destinationSource && destinationSource.writeable) {
                const type = checker.findType(nodeAtPosition);
                const typeString = checker.typeToString(type, params.sourceFile);
                const edit = refactorEditUtils_1.RefactorEditUtils.createTopLevelFunction(destinationSource.tree.rootNode.endPosition.row, funcName, typeString, type.nodeType === "Function" ? type.params.length : 0, `Debug.todo "TODO"`);
                const exposeEdit = refactorEditUtils_1.RefactorEditUtils.exposeValueInModule(destinationSource.tree, funcName);
                if (edit && exposeEdit) {
                    return [
                        { [destinationSource.uri]: [edit, exposeEdit] },
                        moduleName,
                    ];
                }
            }
        })
            .filter(utils_1.Utils.notUndefinedOrNull);
    }
    return [];
}
//# sourceMappingURL=makeExternalDeclarationFromUsageCodeAction.js.map