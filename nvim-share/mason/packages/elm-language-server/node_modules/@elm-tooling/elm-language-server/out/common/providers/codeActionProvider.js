"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeActionProvider = void 0;
const tsyringe_1 = require("tsyringe");
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const elmWorkspaceMatcher_1 = require("../util/elmWorkspaceMatcher");
const multiMap_1 = require("../util/multiMap");
const diagnosticsProvider_1 = require("./diagnostics/diagnosticsProvider");
const elmMakeDiagnostics_1 = require("./diagnostics/elmMakeDiagnostics");
const fileDiagnostics_1 = require("./diagnostics/fileDiagnostics");
const exposeUnexposeHandler_1 = require("./handlers/exposeUnexposeHandler");
const moveRefactoringHandler_1 = require("./handlers/moveRefactoringHandler");
const elmPackageCache_1 = require("../../compiler/elmPackageCache");
const positionUtil_1 = require("../positionUtil");
class CodeActionProvider {
    constructor(host) {
        var _a, _b;
        this.settings = tsyringe_1.container.resolve("Settings");
        this.elmMake = tsyringe_1.container.resolve(elmMakeDiagnostics_1.ElmMakeDiagnostics);
        this.connection = tsyringe_1.container.resolve("Connection");
        this.diagnosticsProvider = tsyringe_1.container.resolve(diagnosticsProvider_1.DiagnosticsProvider);
        this.onCodeAction = this.onCodeAction.bind(this);
        this.connection.onCodeAction(this.diagnosticsProvider.interruptDiagnostics(() => new elmWorkspaceMatcher_1.ElmWorkspaceMatcher((param) => vscode_uri_1.URI.parse(param.textDocument.uri)).handle(this.onCodeAction.bind(this))));
        if (this.settings.isCodeActionResolveSupported("edit")) {
            this.connection.onRequest(vscode_languageserver_1.CodeActionResolveRequest.method, new elmWorkspaceMatcher_1.ElmWorkspaceMatcher((codeAction) => vscode_uri_1.URI.parse(codeAction.data.uri)).handleResolve((codeAction, program, sourceFile) => this.onCodeActionResolve(codeAction, program, sourceFile)));
        }
        if ((_a = this.settings.extendedCapabilities) === null || _a === void 0 ? void 0 : _a.moveFunctionRefactoringSupport) {
            new moveRefactoringHandler_1.MoveRefactoringHandler();
        }
        if ((_b = this.settings.extendedCapabilities) === null || _b === void 0 ? void 0 : _b.exposeUnexposeSupport) {
            new exposeUnexposeHandler_1.ExposeUnexposeHandler();
        }
        setTimeout(() => {
            void new elmPackageCache_1.ElmPackageCache((uri) => __awaiter(this, void 0, void 0, function* () { return JSON.parse(yield host.readFile(uri)); }), host).loadAllPackageModules();
        }, 5000);
    }
    static registerCodeAction(registration) {
        registration.errorCodes.forEach((code) => {
            CodeActionProvider.errorCodeToRegistrationMap.set(code, registration);
        });
        if (registration.preferredAction) {
            CodeActionProvider.preferredActions.set(registration.fixId, registration.preferredAction);
        }
    }
    static registerRefactorAction(name, registration) {
        this.refactorRegistrations.set(name, registration);
        if (registration.preferredAction) {
            CodeActionProvider.preferredActions.set(name, registration.preferredAction);
        }
    }
    static getDiagnostics(params, diagnosticProvider) {
        return [
            ...params.program.getSyntacticDiagnostics(params.sourceFile),
            ...params.program.getSemanticDiagnostics(params.sourceFile),
            ...params.program.getSuggestionDiagnostics(params.sourceFile),
            ...diagnosticProvider
                .getCurrentDiagnostics(params.sourceFile.uri, 2 /* DiagnosticKind.ElmLS */)
                .map(diagnosticsProvider_1.convertToCompilerDiagnostic),
        ];
    }
    static forEachDiagnostic(params, errorCodes, callback) {
        const diagnosticProvider = tsyringe_1.container.resolve(diagnosticsProvider_1.DiagnosticsProvider);
        CodeActionProvider.getDiagnostics(params, diagnosticProvider).forEach((diagnostic) => {
            if (typeof diagnostic.code === "string" &&
                errorCodes.includes(diagnostic.code)) {
                callback(diagnostic);
            }
        });
    }
    static getCodeAction(params, title, edits, command) {
        const changes = Array.isArray(edits)
            ? { [params.sourceFile.uri]: edits }
            : edits;
        return {
            title,
            kind: vscode_languageserver_1.CodeActionKind.QuickFix,
            edit: { changes },
            command,
        };
    }
    static getFixAllCodeAction(title, params, errorCodes, fixId, callback, callbackChanges) {
        const edits = [];
        const changes = callbackChanges
            ? {}
            : {
                [params.sourceFile.uri]: edits,
            };
        const diagnostics = [];
        CodeActionProvider.forEachDiagnostic(params, errorCodes, (diagnostic) => {
            diagnostics.push(diagnostic);
            if (callbackChanges) {
                callbackChanges(changes, diagnostic);
            }
            else {
                callback(edits, diagnostic);
            }
        });
        const sortedEdits = edits.sort((a, b) => (0, positionUtil_1.comparePosition)(a.range.start, b.range.start));
        // Using object mutation here to fix the ranges
        sortedEdits.forEach((edit, i) => {
            var _a;
            const lastEditEnd = (_a = sortedEdits[i - 1]) === null || _a === void 0 ? void 0 : _a.range.end;
            const newEditStart = edit.range.start;
            // Handle if the ranges overlap
            if (lastEditEnd &&
                newEditStart &&
                (0, positionUtil_1.comparePosition)(lastEditEnd, newEditStart) > 0) {
                edit.range.start = lastEditEnd;
                if ((0, positionUtil_1.comparePosition)(edit.range.end, edit.range.start) < 0) {
                    edit.range.end = edit.range.start;
                }
            }
        });
        return {
            title,
            kind: vscode_languageserver_1.CodeActionKind.QuickFix,
            diagnostics,
            edit: { changes },
            data: { fixId, isFixAll: true },
        };
    }
    onCodeAction(params) {
        this.connection.console.info("A code action was requested");
        // Don't try to get them if there is a top level parse error
        // It can create many diagnostics which cause a huge performance hit
        // Code actions aren't useful in this case anyways
        if (params.sourceFile.tree.rootNode.type === "ERROR") {
            return [];
        }
        const make = this.elmMake.onCodeAction(params);
        const results = [];
        // For each diagnostic in the context, get the code action registration that
        // handles the diagnostic error code and ask for the code actions for that error
        // and the fix all code action for that error if there are other diagnostics with
        // the same error code
        params.context.diagnostics.forEach((diagnostic) => {
            const registrations = CodeActionProvider.errorCodeToRegistrationMap.getAll(diagnostic.data.code);
            // Set the params range to the diagnostic range so we get the correct nodes
            params.range = diagnostic.range;
            if (registrations) {
                results.push(...registrations.flatMap((reg) => {
                    var _a, _b;
                    const codeActions = (_b = (_a = reg
                        .getCodeActions(params)) === null || _a === void 0 ? void 0 : _a.map((codeAction) => this.addDiagnosticToCodeAction(codeAction, diagnostic)).map((codeAction) => (Object.assign(Object.assign({}, codeAction), { data: { fixId: reg.fixId } })))) !== null && _b !== void 0 ? _b : [];
                    if (codeActions.length > 0 &&
                        CodeActionProvider.getDiagnostics(params, this.diagnosticsProvider).some((diag) => !(0, fileDiagnostics_1.diagnosticsEquals)((0, diagnosticsProvider_1.convertFromCompilerDiagnostic)(diag), diagnostic) && reg.errorCodes.includes(diag.code))) {
                        const fixAllCodeAction = reg.getFixAllCodeAction(params);
                        if (fixAllCodeAction) {
                            codeActions === null || codeActions === void 0 ? void 0 : codeActions.push(fixAllCodeAction);
                        }
                    }
                    return codeActions;
                }));
            }
        });
        results.push(...Array.from(CodeActionProvider.refactorRegistrations.values()).flatMap((registration) => {
            const actions = registration.getAvailableActions(params);
            // Some LSP clients such as vim-lsp does not support codeAction/resolve capability,
            // but elm-language-server takes advantage of that capability to apply some refactor actions
            // so if codeAction/resolve is not available, just applying refactor actions here instead, not lazily.
            // This implmentation may bring performance defect to LSP clients without codeAction/resolve support.
            // However, that's not too worse than losing nice codeAction features.
            if (!this.settings.isCodeActionResolveSupported("edit")) {
                actions === null || actions === void 0 ? void 0 : actions.map((refactorAction) => this.applyRefactorEditsToAction(refactorAction, registration.getEditsForAction(params, refactorAction.data.actionName)));
            }
            return actions;
        }));
        return [
            ...results.map((codeAction, _, allActions) => (Object.assign(Object.assign({}, codeAction), { isPreferred: this.isPreferredFix(codeAction, allActions) }))),
            ...make,
        ];
    }
    onCodeActionResolve(codeAction, program, sourceFile) {
        var _a;
        const result = (_a = CodeActionProvider.refactorRegistrations
            .get(codeAction.data.refactorName)) === null || _a === void 0 ? void 0 : _a.getEditsForAction({
            textDocument: {
                uri: codeAction.data.uri,
            },
            context: { diagnostics: [] },
            range: codeAction.data.range,
            program,
            sourceFile,
        }, codeAction.data.actionName);
        if (result === null || result === void 0 ? void 0 : result.edits) {
            codeAction.edit = { changes: { [codeAction.data.uri]: result.edits } };
        }
        if (result === null || result === void 0 ? void 0 : result.renamePosition) {
            codeAction.data.renamePosition = result.renamePosition;
        }
        return codeAction;
    }
    addDiagnosticToCodeAction(codeAction, diagnostic) {
        codeAction.diagnostics = [diagnostic];
        return codeAction;
    }
    isPreferredFix(action, allActions) {
        if ("isFixAll" in action.data && action.data.isFixAll) {
            return false;
        }
        const fixIdOrRefactorName = "fixId" in action.data ? action.data.fixId : action.data.refactorName;
        const actionPriority = CodeActionProvider.preferredActions.get(fixIdOrRefactorName);
        if (!actionPriority) {
            return false;
        }
        return allActions.every((otherAction) => {
            if (otherAction === action) {
                return true;
            }
            if ("isFixAll" in otherAction.data && otherAction.data.isFixAll) {
                return true;
            }
            const otherFixIdOrRefactorName = "fixId" in otherAction.data
                ? otherAction.data.fixId
                : otherAction.data.refactorName;
            const otherActionPriority = CodeActionProvider.preferredActions.get(otherFixIdOrRefactorName);
            if (!otherActionPriority ||
                otherActionPriority.priority < actionPriority.priority) {
                return true;
            }
            else if (otherActionPriority.priority > actionPriority.priority) {
                return false;
            }
            if (actionPriority.thereCanOnlyBeOne &&
                fixIdOrRefactorName === otherFixIdOrRefactorName) {
                return false;
            }
            return true;
        });
    }
    applyRefactorEditsToAction(refactorAction, refactorEdit) {
        const { edits, renamePosition } = refactorEdit;
        if (edits) {
            refactorAction.data.renamePosition = renamePosition;
            refactorAction.edit = {
                changes: { [refactorAction.data.uri]: edits },
            };
        }
        return refactorAction;
    }
    /**
     * Only used for testing
     */
    static clearPreferredActions() {
        CodeActionProvider.preferredActions.clear();
    }
}
exports.CodeActionProvider = CodeActionProvider;
CodeActionProvider.errorCodeToRegistrationMap = new multiMap_1.MultiMap();
CodeActionProvider.refactorRegistrations = new Map();
CodeActionProvider.preferredActions = new Map();
//# sourceMappingURL=codeActionProvider.js.map