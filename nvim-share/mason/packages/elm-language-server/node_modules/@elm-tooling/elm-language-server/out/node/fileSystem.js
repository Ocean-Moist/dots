"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.execCmd = exports.execCmdSync = exports.isWindows = exports.createNodeFileSystemHost = void 0;
const fs_1 = __importDefault(require("fs"));
const globby_1 = __importDefault(require("globby"));
const util_1 = __importDefault(require("util"));
const chokidar_1 = __importDefault(require("chokidar"));
const vscode_uri_1 = require("vscode-uri");
const request_light_1 = require("request-light");
const protocol_1 = require("../common/protocol");
const vscode_languageserver_1 = require("vscode-languageserver");
const common_1 = require("../common");
const os_1 = __importDefault(require("os"));
const execa_1 = __importDefault(require("execa"));
const readFile = util_1.default.promisify(fs_1.default.readFile);
const readDir = util_1.default.promisify(fs_1.default.readdir);
const writeFile = util_1.default.promisify(fs_1.default.writeFile);
const mkdir = util_1.default.promisify(fs_1.default.mkdir);
function createNodeFileSystemHost(connection) {
    return {
        readFile: (uri) => (0, common_1.readFileWithCachedVirtualPackageFile)(uri, (uri) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const schemaProvider = schemaProviders[uri.scheme];
            if (schemaProvider) {
                return (_a = (yield schemaProvider(uri))) !== null && _a !== void 0 ? _a : "";
            }
            const bytes = yield connection.sendRequest(protocol_1.ReadFileRequest, uri.toString());
            return new TextDecoder().decode(new Uint8Array(bytes));
        }), {
            getVirtualPackageRoot,
            get: (uri) => schemaProviders["file"](uri),
            set: (uri, value) => __awaiter(this, void 0, void 0, function* () {
                yield mkdir(vscode_uri_1.Utils.dirname(uri).fsPath, { recursive: true });
                yield writeFile(uri.fsPath, value, { flag: "w+" });
            }),
        }),
        readFileSync: (uri) => fs_1.default.readFileSync(uri.fsPath, "utf-8"),
        readDirectory: (uri, include, depth) => __awaiter(this, void 0, void 0, function* () {
            const realUri = (0, common_1.convertToFileSystemUri)(uri);
            if (realUri.scheme === "http" || realUri.scheme === "https") {
                return [];
            }
            if (realUri.scheme === "file") {
                const result = depth === 1
                    ? yield readDir(realUri.fsPath)
                    : yield (0, globby_1.default)(
                    // Cleanup the path on windows, as globby does not like backslashes
                    vscode_uri_1.Utils.joinPath(realUri, include !== null && include !== void 0 ? include : "**").fsPath.replace(/\\/g, "/"), {
                        suppressErrors: true,
                    });
                return result.map((path) => vscode_uri_1.URI.file(path));
            }
            else {
                const result = yield connection.sendRequest(protocol_1.ReadDirectoryRequest, realUri.toString());
                return result.map((path) => vscode_uri_1.URI.parse(path));
            }
        }),
        readDirectorySync: (uri, include, exclude, depth) => {
            var _a, _b;
            const result = depth === 1
                ? fs_1.default.readdirSync(uri.fsPath)
                : globby_1.default.sync(
                // Cleanup the path on windows, as globby does not like backslashes
                [
                    ...((_a = include === null || include === void 0 ? void 0 : include.map((path) => vscode_uri_1.Utils.joinPath(uri, path).fsPath.replace(/\\/g, "/"))) !== null && _a !== void 0 ? _a : []),
                    ...((_b = exclude === null || exclude === void 0 ? void 0 : exclude.map((path) => `!${vscode_uri_1.Utils.joinPath(uri, path).fsPath.replace(/\\/g, "/")}`)) !== null && _b !== void 0 ? _b : []),
                ], {
                    suppressErrors: true,
                });
            return result.map((path) => vscode_uri_1.URI.file(path));
        },
        fileExists: (uri) => uri.scheme === "file" && fs_1.default.existsSync(uri.fsPath),
        watchFile: (uri, callback) => {
            const realUri = (0, common_1.convertToFileSystemUri)(uri);
            if (realUri.scheme === "file") {
                const watcher = chokidar_1.default.watch(realUri.fsPath);
                watcher.on("change", callback);
                return vscode_languageserver_1.Disposable.create(() => {
                    void watcher.close();
                });
            }
            return vscode_languageserver_1.Disposable.create(() => {
                //
            });
        },
        getElmPackagesRoot: (rootPath, clientSettings) => {
            const isVirtualFileSystem = rootPath.scheme !== "file";
            let elmVersion;
            if (isVirtualFileSystem) {
                elmVersion = "0.19.1";
            }
            else {
                try {
                    elmVersion = getElmVersion(clientSettings, rootPath, connection);
                }
                catch (error) {
                    if (error instanceof Error && error.stack) {
                        connection.console.warn(`Could not figure out elm version, this will impact how good the server works. \n ${error.stack}`);
                    }
                    if (!elmVersion) {
                        connection.console.warn(`Using elm 0.19.1 as a default`);
                        elmVersion = "0.19.1";
                    }
                }
            }
            if (isVirtualFileSystem) {
                return common_1.virtualPackagesRoot;
            }
            else {
                const elmHome = findElmHome();
                const packagesRoot = vscode_uri_1.URI.file(`${elmHome}/${elmVersion}/${packageOrPackagesFolder(elmVersion)}/`);
                // Run `elm make` to download dependencies
                try {
                    execCmdSync(connection, clientSettings.elmPath, "elm", { cmdArguments: ["make"] }, rootPath.fsPath);
                }
                catch (error) {
                    // On application projects, this will give a NO INPUT error message, but will still download the dependencies
                }
                return packagesRoot;
            }
        },
        execCmdSync: (...args) => execCmdSync(connection, ...args),
        execCmd: (...args) => execCmd(connection, ...args),
    };
}
exports.createNodeFileSystemHost = createNodeFileSystemHost;
const schemaProviders = {
    http: loadFileFromHttp,
    https: loadFileFromHttp,
    file: (uri) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            return yield readFile(uri.fsPath, "utf-8");
        }
        catch (_a) {
            return undefined;
        }
    }),
};
function loadFileFromHttp(uri) {
    const headers = { "Accept-Encoding": "gzip, deflate" };
    return (0, request_light_1.xhr)({ url: uri.toString(), followRedirects: 5, headers }).then((response) => {
        if (response.status !== 200) {
            return;
        }
        return response.responseText;
    }, (error) => {
        return Promise.reject(error.responseText ||
            (0, request_light_1.getErrorStatusDescription)(error.status) ||
            error.toString());
    });
}
function getVirtualPackageRoot() {
    return vscode_uri_1.Utils.joinPath(vscode_uri_1.URI.file(findElmHome()), "elm-language-server", "packages");
}
exports.isWindows = process.platform === "win32";
function findElmHome() {
    const elmHomeVar = process.env.ELM_HOME;
    if (elmHomeVar) {
        return elmHomeVar;
    }
    return exports.isWindows
        ? `${os_1.default.homedir()}/AppData/Roaming/elm`
        : `${os_1.default.homedir()}/.elm`;
}
/** Executes a command. Shows an error message if the command isn't found */
function execCmdSync(connection, cmdFromUser, cmdStatic, options = {}, cwd, input) {
    const cmd = cmdFromUser === "" ? cmdStatic : cmdFromUser;
    const preferLocal = cmdFromUser === "";
    const cmdArguments = options ? options.cmdArguments : [];
    try {
        return execa_1.default.sync(cmd, cmdArguments, {
            cwd,
            input,
            preferLocal,
            stripFinalNewline: false,
        });
    }
    catch (error) {
        connection.console.warn(JSON.stringify(error));
        if (error &&
            typeof error === "object" &&
            "code" in error &&
            error.code === "ENOENT") {
            connection.window.showErrorMessage(options.notFoundText
                ? options.notFoundText + ` I'm looking for '${cmd}' at '${cwd}'`
                : `Cannot find executable with name '${cmd}'`);
            throw "Executable not found";
        }
        else {
            throw error;
        }
    }
}
exports.execCmdSync = execCmdSync;
function execCmd(connection, cmdFromUser, cmdStatic, options, cwd, input) {
    return __awaiter(this, void 0, void 0, function* () {
        const [cmd, args] = cmdFromUser[0] === "" ? cmdStatic[0] : cmdFromUser;
        const preferLocal = cmdFromUser[0] === "";
        try {
            return yield (0, execa_1.default)(cmd, args, {
                cwd,
                input,
                preferLocal,
                stripFinalNewline: false,
            });
        }
        catch (error) {
            let notFound = false;
            if (error && typeof error === "object" && "code" in error) {
                notFound = error.code === "ENOENT";
                if (notFound && cmdStatic.length > 1) {
                    return execCmd(connection, cmdFromUser, cmdStatic.slice(1), options, cwd, input);
                }
            }
            connection.console.warn(JSON.stringify(error));
            if (notFound) {
                connection.window.showErrorMessage(options.notFoundText + ` I'm looking for commands at '${cwd}'`);
                throw "Executable not found";
            }
            else {
                throw error;
            }
        }
    });
}
exports.execCmd = execCmd;
function getElmVersion(settings, elmWorkspaceFolder, connection) {
    const options = {
        cmdArguments: ["--version"],
        notFoundText: "Elm binary not found, did you install and setup the path to your binary?",
    };
    const result = execCmdSync(connection, settings.elmPath, "elm", options, elmWorkspaceFolder.fsPath);
    const version = result.stdout.trim();
    connection.console.info(`Elm version ${version} detected.`);
    return version;
}
function packageOrPackagesFolder(elmVersion) {
    return elmVersion === "0.19.0" ? "package" : "packages";
}
//# sourceMappingURL=fileSystem.js.map