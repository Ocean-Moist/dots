"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Diagnostics = exports.error = exports.errorWithEndNode = void 0;
/* eslint-disable @typescript-eslint/naming-convention */
const vscode_languageserver_1 = require("vscode-languageserver");
const positionUtil_1 = require("../common/positionUtil");
const refactorEditUtils_1 = require("../common/util/refactorEditUtils");
function format(text, ...args) {
    return text.replace(/{(\d+)}/g, (_match, index) => `${args[+index]}`);
}
function errorWithEndNode(node, diagnostic, endNode, ...args) {
    var _a;
    return {
        range: {
            start: positionUtil_1.PositionUtil.FROM_TS_POSITION(node.startPosition).toVSPosition(),
            end: positionUtil_1.PositionUtil.FROM_TS_POSITION((_a = endNode === null || endNode === void 0 ? void 0 : endNode.endPosition) !== null && _a !== void 0 ? _a : node.endPosition).toVSPosition(),
        },
        message: format(diagnostic.message, ...args),
        code: diagnostic.code,
        severity: diagnostic.severity,
        source: "Elm",
        uri: node.tree.uri,
    };
}
exports.errorWithEndNode = errorWithEndNode;
function error(node, diagnostic, ...args) {
    return errorWithEndNode(node, diagnostic, undefined, ...args);
}
exports.error = error;
function diag(code, message, severity) {
    return { code, message, severity };
}
exports.Diagnostics = {
    AmbiguousType: diag("ambiguous_type", "The usage of the type `{0}` is ambiguous because it is exposed by multiple imports.", vscode_languageserver_1.DiagnosticSeverity.Error),
    AmbiguousVar: diag("ambiguous_var", "The usage of the variable `{0}` is ambiguous because it is exposed by multiple imports.", vscode_languageserver_1.DiagnosticSeverity.Error),
    AmbiguousVariant: diag("ambiguous_variant", "The usage of the variant `{0}` is ambiguous because it is exposed by multiple imports.", vscode_languageserver_1.DiagnosticSeverity.Error),
    ArgumentCount: diag("argument_count", "`{0}` is not a function, but it was given {1} arguments.", vscode_languageserver_1.DiagnosticSeverity.Error),
    CyclicDefinition: diag("cyclic_definition", "Value cannot be defined in terms of itself.", vscode_languageserver_1.DiagnosticSeverity.Error),
    ExportNotFound: diag("export_not_found", "Cannot find a {0} named `{1}` to expose.", vscode_languageserver_1.DiagnosticSeverity.Error),
    ExportOpenAlias: diag("export_open_alias", "Cannot use (..) when exposing a type alias.", vscode_languageserver_1.DiagnosticSeverity.Error),
    FieldAccessOnNonRecord: diag("field_access_on_non_record", "Cannot access fields on non-record type: `{0}`.", vscode_languageserver_1.DiagnosticSeverity.Error),
    General: diag("general", "General error: {0}", vscode_languageserver_1.DiagnosticSeverity.Error),
    ImportExposingNotFound: diag("import_exposing_not_found", "The `{0}` module does not expose `{1}`.", vscode_languageserver_1.DiagnosticSeverity.Error),
    ImportMissing: diag("import_resolve", "Could not find a module to import named `{0}` in `dependencies` or `source-directories`.", vscode_languageserver_1.DiagnosticSeverity.Error),
    ImportOpenAlias: diag("import_open_alias", "The `{0}` type alias cannot be followed by (..).", vscode_languageserver_1.DiagnosticSeverity.Error),
    IncompleteCasePattern: (n) => diag("incomplete_case_pattern", `This \`case\` does not have branches for all possibilities.\nMissing possibilities include:\n${(0, refactorEditUtils_1.getSpaces)(2)}${Array.from(Array(n))
        .map((_, i) => `{${i}}`)
        .join(`\n${(0, refactorEditUtils_1.getSpaces)(2)}`)}\n`, vscode_languageserver_1.DiagnosticSeverity.Error),
    InvalidPattern: diag("invalid_pattern", "Invalid pattern error.\nExpected: `{0}`\nFound: `{1}`", vscode_languageserver_1.DiagnosticSeverity.Error),
    MissingTypeAnnotation: diag("missing_type_annotation", "Missing type annotation: `{0}`.", vscode_languageserver_1.DiagnosticSeverity.Information),
    MissingValue: diag("missing_value", "No definition found for `{0}`.", vscode_languageserver_1.DiagnosticSeverity.Error),
    NonAssociativeOperator: diag("non_associative_operator", "Non associative operator.", vscode_languageserver_1.DiagnosticSeverity.Error),
    ParameterCountError: diag("parameter_count", "The {0} `{1}` expects {2} arguments, but got {3} instead.", vscode_languageserver_1.DiagnosticSeverity.Error),
    Parsing: diag("parsing", "Parsing error.", vscode_languageserver_1.DiagnosticSeverity.Error),
    PartialPattern: diag("partial_pattern", "Pattern does not cover all possibilities.", vscode_languageserver_1.DiagnosticSeverity.Error),
    RecordBaseId: diag("record_base_id", "Type must be a record, instead found: `{0}`.", vscode_languageserver_1.DiagnosticSeverity.Error),
    RecordField: diag("record_field", "The record does not have a `{0}` field.", vscode_languageserver_1.DiagnosticSeverity.Error),
    RecursiveAlias: (n) => diag("recursive_alias", n < 2
        ? "Alias problem. This type alias is recursive, forming an infinite type."
        : `Alias problem. This type alias is part of a mutually recursive set of type aliases:\n${Array.from(Array(n).keys())
            .map((i) => `{${i}}`)
            .join(" -> ")}`, vscode_languageserver_1.DiagnosticSeverity.Error),
    RecursiveDeclaration: (n) => diag("recursive_declaration", n < 2
        ? "Cyclic definition. The value `{0}` is defined directly in terms of itself, causing an infinite loop."
        : `Cyclic definition. The value \`{0}\`  depends on itself through the following chain of definitions:\n${Array.from(Array(n).keys())
            .map((i) => `{${i}}`)
            .join(" -> ")}`, vscode_languageserver_1.DiagnosticSeverity.Error),
    RecursiveLet: (n) => diag("recursive_let", n < 2
        ? "Cyclic value. The value `{0}` is defined directly in terms of itself, causing an infinite loop."
        : `Cyclic value. The value \`{0}\` depends on itself through the following chain of definitions:\n${Array.from(Array(n).keys())
            .map((i) => `{${i}}`)
            .join(" -> ")}`, vscode_languageserver_1.DiagnosticSeverity.Error),
    Redefinition: diag("redefinition", "A value named `{0}` is already defined.", vscode_languageserver_1.DiagnosticSeverity.Error),
    RedundantPattern: diag("redundant_pattern", "The {0} pattern is redundant", vscode_languageserver_1.DiagnosticSeverity.Error),
    TypeArgumentCount: diag("type_argument_count", "The type expected {0} arguments, but got {1} instead.", vscode_languageserver_1.DiagnosticSeverity.Error),
    TypeMismatch: diag("type_mismatch", "Type mismatch error.\nExpected: `{0}`\nFound: `{1}`", vscode_languageserver_1.DiagnosticSeverity.Error),
};
//# sourceMappingURL=diagnostics.js.map