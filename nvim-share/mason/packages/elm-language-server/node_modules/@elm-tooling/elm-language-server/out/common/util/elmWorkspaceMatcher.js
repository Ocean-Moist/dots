"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ElmWorkspaceMatcher = void 0;
const tsyringe_1 = require("tsyringe");
const noWorkspaceContainsError_1 = require("./noWorkspaceContainsError");
/**
 * Identifies the relevant ElmWorkspace for a given ParamType, either directly
 * (getElmWorkspaceFor) or when an event handler receives a ParamType
 * (handle) it returns a params object with a combined type ParamType and IParams
 * which has the program and sourceFile.
 */
class ElmWorkspaceMatcher {
    constructor(getUriFor) {
        this.getUriFor = getUriFor;
        this.elmWorkspaces = tsyringe_1.container.resolve("ElmWorkspaces");
    }
    handle(handler) {
        return (param, token) => __awaiter(this, void 0, void 0, function* () {
            yield this.waitForInitialization();
            const program = this.getProgramFor(param);
            return handler(Object.assign(Object.assign({}, param), { program, sourceFile: this.getSourceFileFor(param, program) }), token);
        });
    }
    handleResolve(handler) {
        return (param, token) => __awaiter(this, void 0, void 0, function* () {
            yield this.waitForInitialization();
            const program = this.getProgramFor(param);
            return handler(param, program, this.getSourceFileFor(param, program), token);
        });
    }
    getProgramFor(param) {
        const uri = this.getUriFor(param);
        const program = 
        // first look for a program where the file has been parsed to a tree
        this.elmWorkspaces.find((ws) => ws.hasDocument(uri)) ||
            // fallback: find a program where the file is in the source-directories
            this.elmWorkspaces.find((ws) => ws.isInSourceDirectory(uri.toString()));
        if (!program) {
            throw new noWorkspaceContainsError_1.NoWorkspaceContainsError(this.getUriFor(param));
        }
        return program;
    }
    getSourceFileFor(param, program) {
        const uri = this.getUriFor(param).toString();
        return program.getSourceFile(uri);
    }
    waitForInitialization() {
        return __awaiter(this, void 0, void 0, function* () {
            const uninitialized = this.elmWorkspaces.filter((ws) => !ws.isInitialized);
            if (uninitialized.length === 0) {
                return Promise.resolve();
            }
            // Ensure that the programs are initialized
            // We really should only need to wait until the root projects source directories are loaded, not the entire program
            // Ideally we would not have to initialize everything up front and the program could load lazliy
            // The problem is most of the program API is synchronous, but our readFile (what we to initialize) is async
            // Either we need to make the program API async or we need to make the readFile sync
            // A readFile sync would return an empty string if we need to load the file asychronously (not from a real file system), then we the file is loaded a change would be triggered with the actual contents
            // On the other hand, an async program API might work, but it is a lot to refactor and I'm not sure of the performance implications
            yield Promise.all(uninitialized.map((ws) => ws.init()));
        });
    }
}
exports.ElmWorkspaceMatcher = ElmWorkspaceMatcher;
//# sourceMappingURL=elmWorkspaceMatcher.js.map