import { Disposable } from "vscode-languageserver";
import { URI } from "vscode-uri";
import type { ICancellationToken } from "../common/cancellation";
import { IForest, IKernelSourceFile, ISourceFile } from "./forest";
import { IPossibleImportsCache } from "../common/util/possibleImportsCache";
import { Diagnostic } from "./diagnostics";
import { TypeCache } from "./typeCache";
import { TypeChecker } from "./typeChecker";
import { IFileSystemHost } from "../common/types";
export type ElmJson = IElmApplicationJson | IElmPackageJson;
interface IElmApplicationJson {
    type: "application";
    "source-directories": string[];
    "elm-version": string;
    dependencies: {
        direct: {
            [module: string]: string;
        };
        indirect: {
            [module: string]: string;
        };
    };
    "test-dependencies": {
        direct: {
            [module: string]: string;
        };
        indirect: {
            [module: string]: string;
        };
    };
}
interface IElmPackageJson {
    type: "package";
    name: string;
    summary: string;
    license: string;
    version: string;
    "exposed-modules": string[] | {
        [name: string]: string[];
    };
    "elm-version": string;
    dependencies: {
        [module: string]: string;
    };
    "test-dependencies": {
        [module: string]: string;
    };
}
export interface IProgram extends Disposable {
    init(progressCallback?: (percent: number) => void): Promise<void>;
    isInitialized: boolean;
    hasDocument(uri: URI): boolean;
    isInSourceDirectory(uri: string): boolean;
    getSourceDirectoryOfFile(uri: string): string | undefined;
    getSourceFile(uri: string): ISourceFile | undefined;
    getSourceFiles(): readonly ISourceFile[];
    getSourceFileOfImportableModule(sourceFile: ISourceFile, importableModuleName: string): ISourceFile | undefined;
    getKernelSourceFileOfImportableModule(sourceFile: ISourceFile, importableModuleName: string): IKernelSourceFile | undefined;
    getForest(synchronize?: boolean): IForest;
    getRootPath(): URI;
    getTypeCache(): TypeCache;
    getTypeChecker(): TypeChecker;
    markAsDirty(): void;
    getPossibleImportsCache(): IPossibleImportsCache;
    getSemanticDiagnostics(sourceFile: ISourceFile, cancellationToken?: ICancellationToken): Diagnostic[];
    getSemanticDiagnosticsAsync(sourceFile: ISourceFile, cancellationToken?: ICancellationToken): Promise<Diagnostic[]>;
    getSyntacticDiagnostics(sourceFile: ISourceFile): Diagnostic[];
    getSuggestionDiagnostics(sourceFile: ISourceFile, cancellationToken?: ICancellationToken): Diagnostic[];
    getImportableModules(sourceFile: ISourceFile): {
        moduleName: string;
        uri: string;
    }[];
}
export type ElmProject = IElmApplication | IElmPackage;
interface IElmProject {
    type: string;
    uri: string;
    dependencies: Map<string, IElmPackage>;
    testDependencies: Map<string, IElmPackage>;
    sourceDirectories: string[];
    testDirectories: string[];
    moduleToUriMap: Map<string, string>;
    testModuleToUriMap: Map<string, string>;
}
interface IElmApplication extends IElmProject {
    type: "application";
}
interface IElmPackage extends IElmProject {
    type: "package";
    maintainerAndPackageName: string;
    exposedModules: Set<string>;
    isDependency: boolean;
}
export type IProgramHost = IFileSystemHost;
export declare class Program implements IProgram {
    private rootPath;
    private parser;
    private connection;
    private settings;
    private typeCache;
    private typeChecker;
    private dirty;
    private possibleImportsCache;
    private diagnosticsCache;
    private rootProject;
    private forest;
    private elmPackageCache;
    private resolvedPackageCache;
    private host;
    private filesWatching;
    private _isInitialized;
    private _initializePromise;
    private _initializeProgressCallback;
    private disposables;
    constructor(rootPath: URI, programHost: IProgramHost);
    init(progressCallback?: (percent: number) => void): Promise<void>;
    get isInitialized(): boolean;
    hasDocument(uri: URI): boolean;
    isInSourceDirectory(uri: string): boolean;
    getSourceDirectoryOfFile(uri: string): string | undefined;
    getSourceFile(uri: string): ISourceFile | undefined;
    getSourceFiles(): readonly ISourceFile[];
    getSourceFileOfImportableModule(sourceFile: ISourceFile, importableModuleName: string): ISourceFile | undefined;
    private checkedKernelFiles;
    getKernelSourceFileOfImportableModule(sourceFile: ISourceFile, importableModuleName: string): IKernelSourceFile | undefined;
    getForest(synchronize?: boolean): IForest;
    getRootPath(): URI;
    getTypeCache(): TypeCache;
    getTypeChecker(): TypeChecker;
    markAsDirty(): void;
    getPossibleImportsCache(): IPossibleImportsCache;
    getSemanticDiagnostics(sourceFile: ISourceFile, cancellationToken?: ICancellationToken): Diagnostic[];
    getSemanticDiagnosticsAsync(sourceFile: ISourceFile, cancellationToken?: ICancellationToken): Promise<Diagnostic[]>;
    getSyntacticDiagnostics(sourceFile: ISourceFile): Diagnostic[];
    getSuggestionDiagnostics(sourceFile: ISourceFile, cancellationToken?: ICancellationToken): Diagnostic[];
    getImportableModules(sourceFile: ISourceFile): {
        moduleName: string;
        uri: string;
    }[];
    dispose(): void;
    private initWorkspace;
    private loadRootProject;
    private loadPackage;
    private loadDependencyMap;
    /**
     * Get all unique source directories from project dependency tree
     */
    private getSourceDirectories;
    private findElmFilesInProject;
    private findElmFilesInProjectWorker;
    private tryAddModule;
    private readAndAddToForest;
    private findExposedModulesOfDependencies;
    private loadElmJson;
}
export {};
