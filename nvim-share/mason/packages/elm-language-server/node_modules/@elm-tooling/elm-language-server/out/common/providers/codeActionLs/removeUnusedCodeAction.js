"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_1 = require("vscode-languageserver");
const refactorEditUtils_1 = require("../../util/refactorEditUtils");
const treeUtils_1 = require("../../util/treeUtils");
const utils_1 = require("../../util/utils");
const codeActionProvider_1 = require("../codeActionProvider");
const diagnosticsProvider_1 = require("../diagnostics/diagnosticsProvider");
const errorCodes = [
    "unused_import",
    "unused_imported_value",
    "unused_alias",
    "unused_top_level",
    "unused_pattern",
    "unused_value_constructor",
    "unused_type_alias",
];
const fixId = "remove_unused";
codeActionProvider_1.CodeActionProvider.registerCodeAction({
    errorCodes,
    fixId,
    getCodeActions: (params) => {
        return params.context.diagnostics
            .map((diagnostic) => {
            const { title, edits } = getEditsForDiagnostic(diagnostic, params.sourceFile);
            if (title) {
                return codeActionProvider_1.CodeActionProvider.getCodeAction(params, title, edits);
            }
        })
            .filter(utils_1.Utils.notUndefined);
    },
    getFixAllCodeAction: (params) => {
        const importsMap = new Map();
        return codeActionProvider_1.CodeActionProvider.getFixAllCodeAction("Remove all reported unused code", params, errorCodes, fixId, (edits, diagnostic) => {
            edits.push(...getEditsForDiagnostic((0, diagnosticsProvider_1.convertFromCompilerDiagnostic)(diagnostic), params.sourceFile, importsMap).edits);
        });
    },
});
function getEditsForDiagnostic(diagnostic, sourceFile, importsMap) {
    var _a, _b, _c, _d, _e;
    const addImportToSet = (module, value) => {
        if (!importsMap) {
            return;
        }
        let existing = importsMap.get(module);
        if (!existing) {
            existing = new Set();
            importsMap.set(module, existing);
        }
        existing.add(value);
    };
    switch (diagnostic.data.code) {
        case "unused_import": {
            const node = treeUtils_1.TreeUtils.getNamedDescendantForPosition(sourceFile.tree.rootNode, diagnostic.range.end);
            const moduleName = node.childForFieldName("moduleName");
            return {
                title: `Remove unused import \`${(_a = moduleName === null || moduleName === void 0 ? void 0 : moduleName.text) !== null && _a !== void 0 ? _a : node.text}\``,
                edits: [
                    vscode_languageserver_1.TextEdit.del(vscode_languageserver_1.Range.create(diagnostic.range.start, vscode_languageserver_1.Position.create(diagnostic.range.end.line + 1, 0))),
                ],
            };
        }
        case "unused_alias": {
            const node = treeUtils_1.TreeUtils.getNamedDescendantForPosition(sourceFile.tree.rootNode, diagnostic.range.end);
            return {
                title: `Remove unused alias \`${node.text}\``,
                edits: [
                    vscode_languageserver_1.TextEdit.del({
                        start: {
                            line: diagnostic.range.start.line,
                            character: diagnostic.range.start.character - 1,
                        },
                        end: diagnostic.range.end,
                    }),
                ],
            };
        }
        case "unused_top_level": {
            const node = treeUtils_1.TreeUtils.getNamedDescendantForPosition(sourceFile.tree.rootNode, diagnostic.range.start);
            const edit = refactorEditUtils_1.RefactorEditUtils.removeFunction(node);
            if (!edit) {
                break;
            }
            return {
                title: `Remove function \`${node.text}\``,
                edits: [edit],
            };
        }
        case "unused_pattern": {
            const node = treeUtils_1.TreeUtils.getNamedDescendantForPosition(sourceFile.tree.rootNode, diagnostic.range.start);
            const edit = ((_c = (_b = node.parent) === null || _b === void 0 ? void 0 : _b.parent) === null || _c === void 0 ? void 0 : _c.type) === "record_pattern"
                ? refactorEditUtils_1.RefactorEditUtils.removeRecordPatternValue(node.parent)
                : vscode_languageserver_1.TextEdit.replace(diagnostic.range, "_");
            return { title: `Fix unused pattern \`${node.text}\``, edits: [edit] };
        }
        case "unused_value_constructor": {
            const node = treeUtils_1.TreeUtils.getNamedDescendantForPosition(sourceFile.tree.rootNode, diagnostic.range.start);
            const edit = refactorEditUtils_1.RefactorEditUtils.removeTypeValue(node);
            if (!edit) {
                break;
            }
            return {
                title: `Remove unused value constructor \`${node.text}\``,
                edits: [edit],
            };
        }
        case "unused_type_alias": {
            const node = treeUtils_1.TreeUtils.getNamedDescendantForPosition(sourceFile.tree.rootNode, diagnostic.range.start);
            const edit = refactorEditUtils_1.RefactorEditUtils.removeTypeAlias(node);
            if (!edit) {
                break;
            }
            return {
                title: `Remove unused type alias \`${node.text}\``,
                edits: [edit],
            };
        }
        case "unused_imported_value": {
            const node = treeUtils_1.TreeUtils.getNamedDescendantForPosition(sourceFile.tree.rootNode, diagnostic.range.start);
            const importClause = treeUtils_1.TreeUtils.findParentOfType("import_clause", node);
            if (!importClause) {
                break;
            }
            const moduleName = treeUtils_1.TreeUtils.findFirstNamedChildOfType("upper_case_qid", importClause);
            if (!moduleName) {
                break;
            }
            const allValues = (_e = (_d = importClause
                .childForFieldName("exposing")) === null || _d === void 0 ? void 0 : _d.namedChildren.filter((n) => n.type === "exposed_value" || n.type === "exposed_type").map((n) => n.text)) !== null && _e !== void 0 ? _e : [];
            // This is only for the fix all code action
            // If we are removing all import values, we need to remove the entire exposing
            addImportToSet(moduleName.text, node.text);
            if (importsMap &&
                allValues.every((val) => { var _a; return (_a = importsMap.get(moduleName.text)) === null || _a === void 0 ? void 0 : _a.has(val); })) {
                const removeExposingExit = refactorEditUtils_1.RefactorEditUtils.removeImportExposingList(sourceFile.tree, moduleName.text);
                if (removeExposingExit) {
                    return {
                        edits: [removeExposingExit],
                    };
                }
            }
            const removeValueEdit = refactorEditUtils_1.RefactorEditUtils.removeValueFromImport(sourceFile.tree, moduleName.text, node.text);
            if (removeValueEdit) {
                // Detect if there are 2 or more values at the end of a exposing list that are removed
                // For example, if we are removing `foo` and `bar` in `(func, foo, bar)`
                // We need to add another edit to remove the comma before `foo`
                if (importsMap && allValues.length > 2) {
                    allValues.reverse();
                    const firstUsedIndex = allValues.findIndex((val) => { var _a; return !((_a = importsMap.get(moduleName.text)) === null || _a === void 0 ? void 0 : _a.has(val)); });
                    if (firstUsedIndex >= 2) {
                        const val = allValues[firstUsedIndex - 1];
                        const removeValueWithCommaEdit = refactorEditUtils_1.RefactorEditUtils.removeValueFromImport(sourceFile.tree, moduleName.text, val, 
                        /* forceRemovePrecedingComma */ true);
                        if (removeValueWithCommaEdit) {
                            return { edits: [removeValueWithCommaEdit, removeValueEdit] };
                        }
                    }
                }
                return {
                    title: `Remove unused ${node.type === "exposed_type" ? "type" : "value"} \`${node.text}\``,
                    edits: [removeValueEdit],
                };
            }
        }
    }
    return { edits: [] };
}
//# sourceMappingURL=removeUnusedCodeAction.js.map