"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileEventsHandler = void 0;
const tsyringe_1 = require("tsyringe");
const vscode_uri_1 = require("vscode-uri");
const positionUtil_1 = require("../../positionUtil");
const elmUtils_1 = require("../../../compiler/utils/elmUtils");
const elmWorkspaceMatcher_1 = require("../../util/elmWorkspaceMatcher");
const refactorEditUtils_1 = require("../../util/refactorEditUtils");
const renameUtils_1 = require("../../util/renameUtils");
const treeUtils_1 = require("../../util/treeUtils");
const astProvider_1 = require("../astProvider");
const renameProvider_1 = require("../renameProvider");
class FileEventsHandler {
    constructor(didCreateFile) {
        this.connection = tsyringe_1.container.resolve("Connection");
        this.astProvider = tsyringe_1.container.resolve(astProvider_1.ASTProvider);
        const onDidCreateFile = (params) => __awaiter(this, void 0, void 0, function* () {
            const edit = { changes: {} };
            for (const { uri } of params.files) {
                const changes = yield new elmWorkspaceMatcher_1.ElmWorkspaceMatcher(({ uri }) => vscode_uri_1.URI.parse(uri)).handle(this.onDidCreateFile.bind(this))({
                    uri,
                });
                if (changes && edit.changes) {
                    edit.changes[uri] = changes;
                }
            }
            yield this.connection.workspace.applyEdit(edit);
            // Used for testing
            if (didCreateFile) {
                for (const { uri } of params.files) {
                    didCreateFile(uri);
                }
            }
        });
        this.connection.workspace.onDidCreateFiles((params) => {
            void onDidCreateFile(params);
        });
        this.connection.workspace.onWillRenameFiles((params) => __awaiter(this, void 0, void 0, function* () {
            const edit = { changes: {} };
            for (const { oldUri, newUri } of params.files) {
                const workspaceEdit = yield new elmWorkspaceMatcher_1.ElmWorkspaceMatcher(({ oldUri }) => vscode_uri_1.URI.parse(oldUri)).handle(this.onWillRenameFile.bind(this))({
                    oldUri,
                    newUri,
                });
                if (workspaceEdit) {
                    this.mergeWorkspaceEdit(edit, workspaceEdit);
                }
            }
            return edit;
        }));
        this.connection.workspace.onWillDeleteFiles((params) => __awaiter(this, void 0, void 0, function* () {
            for (const { uri } of params.files) {
                yield new elmWorkspaceMatcher_1.ElmWorkspaceMatcher(({ uri }) => vscode_uri_1.URI.parse(uri)).handle(this.onWillDeleteFile.bind(this))({
                    uri,
                });
            }
            return null;
        }));
    }
    onDidCreateFile({ uri, program, }) {
        const moduleName = this.getModuleNameFromFile(uri, program);
        if (moduleName) {
            const addModuleDefinitionEdit = refactorEditUtils_1.RefactorEditUtils.addModuleDeclaration(moduleName);
            return [addModuleDefinitionEdit];
        }
    }
    onWillRenameFile({ oldUri, newUri, program, sourceFile, }) {
        // Handle folder rename
        if (!sourceFile) {
            return Array.from(program.getSourceFiles().values())
                .filter(({ uri }) => uri.startsWith(`${oldUri}/`))
                .map((sourceFile) => this.onWillRenameFile({
                oldUri: sourceFile.uri,
                newUri: sourceFile.uri.replace(oldUri, newUri),
                program,
                sourceFile,
            }))
                .reduce((prev, cur) => (cur ? this.mergeWorkspaceEdit(prev, cur) : prev), {});
        }
        const newModuleName = this.getModuleNameFromFile(newUri, program);
        const moduleNameNode = treeUtils_1.TreeUtils.getModuleNameNode(sourceFile.tree);
        if (newModuleName && moduleNameNode) {
            const moduleNodePosition = positionUtil_1.PositionUtil.FROM_TS_POSITION(moduleNameNode.endPosition).toVSPosition();
            const affectedNodes = renameUtils_1.RenameUtils.getRenameAffectedNodes(program, oldUri, moduleNodePosition);
            const [edits] = renameProvider_1.RenameProvider.getRenameEdits(affectedNodes, newModuleName);
            if (sourceFile.moduleName) {
                if (!sourceFile.isTestFile) {
                    sourceFile.project.moduleToUriMap.delete(sourceFile.moduleName);
                    sourceFile.project.moduleToUriMap.set(newModuleName, newUri);
                }
                sourceFile.project.testModuleToUriMap.delete(sourceFile.moduleName);
                sourceFile.project.testModuleToUriMap.set(newModuleName, newUri);
            }
            this.astProvider.addPendingRename(oldUri, newUri);
            return {
                changes: edits,
            };
        }
    }
    onWillDeleteFile({ uri, program }) {
        program.getForest().removeTree(uri);
    }
    getModuleNameFromFile(uri, program) {
        const sourceDir = program.getSourceDirectoryOfFile(uri);
        // The file is not in a source dir (shouldn't happen)
        if (!sourceDir) {
            return;
        }
        return (0, elmUtils_1.getModuleName)(uri, sourceDir);
    }
    mergeWorkspaceEdit(a, b) {
        // Merge changes
        if (b.changes) {
            Object.entries(b.changes).forEach(([uri, edits]) => {
                if (!a.changes) {
                    a.changes = {};
                }
                if (a.changes[uri]) {
                    a.changes[uri].push(...edits);
                }
                else {
                    a.changes[uri] = edits;
                }
            });
        }
        if (b.documentChanges) {
            if (!a.documentChanges) {
                a.documentChanges = [];
            }
            a.documentChanges.push(...b.documentChanges);
        }
        return a;
    }
}
exports.FileEventsHandler = FileEventsHandler;
//# sourceMappingURL=fileEventsHandler.js.map