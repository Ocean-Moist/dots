"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_languageserver_1 = require("vscode-languageserver");
const refactorEditUtils_1 = require("../../util/refactorEditUtils");
const treeUtils_1 = require("../../util/treeUtils");
const codeActionProvider_1 = require("../codeActionProvider");
const refactorName = "expose_unexpose";
codeActionProvider_1.CodeActionProvider.registerRefactorAction(refactorName, {
    preferredAction: {
        priority: 2,
    },
    getAvailableActions: (params) => {
        var _a, _b, _c, _d, _e, _f;
        const result = [];
        const nodeAtPosition = treeUtils_1.TreeUtils.getNamedDescendantForPosition(params.sourceFile.tree.rootNode, params.range.start);
        const tree = params.sourceFile.tree;
        if ((((_a = nodeAtPosition.parent) === null || _a === void 0 ? void 0 : _a.type) === "type_annotation" ||
            ((_b = nodeAtPosition.parent) === null || _b === void 0 ? void 0 : _b.type) === "function_declaration_left") &&
            !treeUtils_1.TreeUtils.findParentOfType("let_in_expr", nodeAtPosition)) {
            const functionName = nodeAtPosition.text;
            if (treeUtils_1.TreeUtils.isExposedFunctionOrPort(tree, functionName)) {
                result.push({
                    title: "Unexpose Function",
                    kind: vscode_languageserver_1.CodeActionKind.Refactor,
                    data: {
                        actionName: "unexpose_function",
                        refactorName,
                        uri: params.sourceFile.uri,
                        range: params.range,
                    },
                });
            }
            else {
                result.push({
                    title: "Expose Function",
                    kind: vscode_languageserver_1.CodeActionKind.Refactor,
                    data: {
                        actionName: "expose_function",
                        refactorName,
                        uri: params.sourceFile.uri,
                        range: params.range,
                    },
                });
            }
        }
        if (nodeAtPosition.type === "upper_case_identifier" &&
            (((_c = nodeAtPosition.parent) === null || _c === void 0 ? void 0 : _c.type) === "type_alias_declaration" ||
                ((_d = nodeAtPosition.parent) === null || _d === void 0 ? void 0 : _d.type) === "type_declaration")) {
            const typeName = nodeAtPosition.text;
            const alias = ((_e = nodeAtPosition.parent) === null || _e === void 0 ? void 0 : _e.type) === "type_alias_declaration"
                ? " Alias"
                : "";
            if (treeUtils_1.TreeUtils.isExposedTypeOrTypeAlias(tree, typeName)) {
                result.push({
                    title: `Unexpose Type${alias}`,
                    kind: vscode_languageserver_1.CodeActionKind.Refactor,
                    data: {
                        actionName: "unexpose_type",
                        refactorName,
                        uri: params.sourceFile.uri,
                        range: params.range,
                    },
                });
            }
            else {
                result.push({
                    title: `Expose Type${alias}`,
                    kind: vscode_languageserver_1.CodeActionKind.Refactor,
                    data: {
                        actionName: "expose_type",
                        refactorName,
                        uri: params.sourceFile.uri,
                        range: params.range,
                    },
                });
                if (((_f = nodeAtPosition.parent) === null || _f === void 0 ? void 0 : _f.type) === "type_declaration") {
                    result.push({
                        title: `Expose Type with Variants`,
                        kind: vscode_languageserver_1.CodeActionKind.Refactor,
                        data: {
                            actionName: "expose_type_with_variants",
                            refactorName,
                            uri: params.sourceFile.uri,
                            range: params.range,
                        },
                    });
                }
            }
        }
        return result;
    },
    getEditsForAction: (params, actionName) => {
        const nodeAtPosition = treeUtils_1.TreeUtils.getNamedDescendantForPosition(params.sourceFile.tree.rootNode, params.range.start);
        const tree = params.sourceFile.tree;
        switch (actionName) {
            case "unexpose_function":
            case "unexpose_type": {
                const edit = refactorEditUtils_1.RefactorEditUtils.unexposedValueInModule(tree, nodeAtPosition.text);
                return edit ? { edits: [edit] } : {};
            }
            case "expose_function":
            case "expose_type":
            case "expose_type_with_variants": {
                const edit = refactorEditUtils_1.RefactorEditUtils.exposeValueInModule(tree, nodeAtPosition.text, actionName === "expose_type_with_variants");
                return edit ? { edits: [edit] } : {};
            }
        }
        return {};
    },
});
//# sourceMappingURL=exposeUnexposeCodeAction.js.map